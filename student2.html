<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U — Student Puzzle (student2) — fallback-enabled</title>

  <!-- chessboard CSS (kept; used when chessboard works) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />

  <style>
    html,body{ overscroll-behavior-y: contain; height:100%; }
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; -webkit-font-smoothing:antialiased; display:flex; flex-direction:column; align-items:center; }
    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); margin:0 auto; max-width:920px; width:100%; box-sizing:border-box; }
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; width:100%; margin-bottom:10px; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    #board-wrapper{ width:100%; max-width:570px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; margin:0 auto; position:relative; }
    #board{ width:100%; aspect-ratio:1/1; border:1px solid #e6eefc; background:#fff; box-sizing:border-box; max-height:80vh; min-width:320px; min-height:320px; display:block; }
    .notation { margin-top:12px; padding:8px; border-radius:6px; border:1px solid #eef2ff; background:#fbfdff; min-height:44px; max-height:160px; overflow:auto; font-family:monospace; font-size:13px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .promote-modal{ display:none; }
    .fallback-board { display:grid; grid-template-columns: repeat(8, 1fr); width:100%; height:100%; }
    .square {
      position:relative; box-sizing:border-box; display:flex; align-items:center; justify-content:center; font-size:32px;
      user-select:none;
    }
    .light { background:#f0d9b5; }
    .dark { background:#b58863; color:#111; }
    .coord { position:absolute; bottom:4px; left:4px; font-size:10px; opacity:0.7; }
    .flip { transform: rotate(180deg); }
    /* responsive font for pieces */
    @media (max-width:900px){
      .square { font-size: calc(12px + 3vw); }
    }
    .controls .status { margin-left:auto; font-size:13px; color:#666; }
  </style>
</head>
<body>

  <!-- ACCESS CHECK -->
  <script>
    (function(){
      const allowedRoles = ['student2'];
      const role = localStorage.getItem('role');
      if(!role || allowedRoles.indexOf(role) === -1){
        try{ window.location.replace('index.html'); }catch(e){ window.location.href='index.html'; }
      }
    })();
  </script>

  <div class="panel" style="max-width:920px;">
    <div class="controls">
      <button id="undoBtn">Undo</button>
      <button id="flipBtn">Flip</button>
      <button id="resignBtn" style="background:#8b0f0f;">Resign</button>
      <button id="logoutBtn" style="background:#dc2626;">Logout</button>
      <div class="status" id="libStatus">Initializing…</div>
    </div>

    <div id="board-wrapper" class="panel" style="padding:10px;">
      <!-- chessboard.js target -->
      <div id="board" aria-label="Chessboard container"></div>
      <!-- fallback board will be inserted dynamically into #board when needed -->
    </div>

    <div id="msg" class="info" aria-live="polite"></div>

    <div id="movesList" class="notation" aria-live="polite" role="status">No moves yet.</div>
  </div>

  <!-- puzzle panel -->
  <div class="panel" style="margin-top:18px; max-width:920px;">
    <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
      <label class="small">Tactic:</label>
      <select id="tacticSelect"><option>— Loading —</option></select>

      <label class="small">Min rating:</label>
      <select id="ratingMin"><option>0</option><option>600</option><option selected>800</option><option>1000</option><option>1200</option></select>

      <label class="small">Max rating:</label>
      <select id="ratingMax"><option>99999</option><option>1000</option><option selected>2200</option><option>2400</option></select>

      <button id="loadPuzzleBtn">Load (first)</button>
      <button id="randomPuzzleBtn">Random</button>
    </div>
    <div id="puzzleInfo" class="muted small" style="margin-top:8px;">No puzzle loaded</div>
  </div>

  <!-- libs (chessboard.js and chess.js) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

  <script>
  (function(){
    // --- CONFIG ---
    const LIST_URL = '/IQ4U-Chess-Classroom/assets/puzzles_list.json'; // Option A list
    // --------------

    // DOM refs
    const libStatus = document.getElementById('libStatus');
    const boardEl = document.getElementById('board');
    const msgEl = document.getElementById('msg');
    const movesList = document.getElementById('movesList');
    const tacticSelect = document.getElementById('tacticSelect');
    const ratingMin = document.getElementById('ratingMin');
    const ratingMax = document.getElementById('ratingMax');
    const loadPuzzleBtn = document.getElementById('loadPuzzleBtn');
    const randomPuzzleBtn = document.getElementById('randomPuzzleBtn');
    const puzzleInfo = document.getElementById('puzzleInfo');
    const undoBtn = document.getElementById('undoBtn');
    const flipBtn = document.getElementById('flipBtn');
    const resignBtn = document.getElementById('resignBtn');

    // state
    let boardInstance = null;     // chessboard.js instance if created
    let useFallback = false;      // whether fallback renderer is active
    let fallbackFlip = false;
    let game = null;              // chess.js game instance (if loaded)
    let currentCandidateList = [];

    // unicode mapping for pieces (chess symbols)
    const UNICODE = {
      'P':'♙','N':'♘','B':'♗','R':'♖','Q':'♕','K':'♔',
      'p':'♟','n':'♞','b':'♝','r':'♜','q':'♛','k':'♚'
    };

    function setMsg(t, ms=0){
      if(msgEl) msgEl.textContent = t || '';
      if(ms>0) setTimeout(()=>{ if(msgEl && msgEl.textContent===t) msgEl.textContent=''; }, ms);
    }

    // Try to create normal chessboard.js board. If it fails or images blocked, fallback.
    async function tryCreateBoard(){
      // ensure chess.js exists
      if(typeof Chess === 'undefined'){
        libStatus.textContent = 'Chess lib missing';
        useFallback = true;
        createFallbackBoard();
        return;
      }

      // attempt to create chessboard (images may be blocked later)
      try {
        game = new Chess();
      } catch(e){
        game = null;
        libStatus.textContent = 'Chess engine failed';
      }

      try {
        if(typeof Chessboard !== 'undefined'){
          // create board with a safe pieceTheme pointing to local path (if available).
          // We still may be blocked if images are cross-origin; that's ok.
          boardInstance = Chessboard('board', {
            draggable: true,
            position: game ? game.fen() : 'start',
            pieceTheme: function(piece){ return '/IQ4U-Chess-Classroom/assets/pieces/cburnett/' + piece + '.svg'; },
            onDrop: async function(s,t){
              // default behavior: try move using chess.js; if not legal, snapback
              if(!game) return 'snapback';
              const mv = game.move({ from: s, to: t, promotion: 'q' });
              if(mv === null) return 'snapback';
              if(boardInstance) boardInstance.position(game.fen());
              refreshNotation();
            },
            onSnapEnd: function(){ if(boardInstance && game) boardInstance.position(game.fen()); }
          });
          libStatus.textContent = 'Chessboard initialized';
          // probe if piece images load (request wK as a quick test)
          probePieceImage('/IQ4U-Chess-Classroom/assets/pieces/cburnett/wK.svg', (ok)=>{
            if(!ok){
              // try fallback to inline unicode
              console.warn('Piece images failed to load; switching to fallback renderer.');
              destroyChessboardIfAny();
              useFallback = true;
              createFallbackBoard();
            } else {
              // success: keep chessboard
              useFallback = false;
            }
          });
          return;
        } else {
          libStatus.textContent = 'Chessboard.js missing';
          useFallback = true;
          createFallbackBoard();
        }
      } catch(err){
        console.warn('Chessboard init error', err);
        useFallback = true;
        createFallbackBoard();
      }
    }

    function destroyChessboardIfAny(){
      if(boardInstance && typeof boardInstance.destroy === 'function'){
        try{ boardInstance.destroy(); }catch(e){}
      }
      boardInstance = null;
      // clear DOM inside #board
      while(boardEl.firstChild) boardEl.removeChild(boardEl.firstChild);
    }

    function probePieceImage(url, cb){
      // probe the same-origin path (SVGs) or any URL — onerror indicates not available or blocked
      const img = new Image();
      let done=false;
      img.onload = function(){ if(done) return; done=true; cb(true); };
      img.onerror = function(){ if(done) return; done=true; cb(false); };
      // set a timeout to avoid waiting forever
      const to = setTimeout(()=>{ if(done) return; done=true; cb(false); }, 1500);
      img.src = url + '?t=' + Date.now();
    }

    // ---- Fallback board renderer (grid + unicode) ----
    function createFallbackBoard(){
      destroyChessboardIfAny();
      useFallback = true;
      // create grid
      const fallback = document.createElement('div');
      fallback.className = 'fallback-board' + (fallbackFlip ? ' flip' : '');
      fallback.style.width = '100%';
      fallback.style.height = '100%';
      // build 8x8 with coordinates a1 bottom-left
      const files = ['a','b','c','d','e','f','g','h'];
      const ranks = [8,7,6,5,4,3,2,1];
      for(let r=0;r<8;r++){
        for(let f=0;f<8;f++){
          const sq = document.createElement('div');
          const file = files[f], rank = ranks[r];
          const coord = file + rank;
          sq.className = 'square ' + (((r+f)%2===0)?'light':'dark');
          // coord label
          const coordSpan = document.createElement('div');
          coordSpan.className = 'coord';
          coordSpan.textContent = coord;
          sq.appendChild(coordSpan);
          sq.dataset.coord = coord;
          fallback.appendChild(sq);
        }
      }
      boardEl.appendChild(fallback);
      // draw pieces based on current FEN (if Chess available)
      renderPositionFromGame();
      libStatus.textContent = 'Fallback board active';
    }

    function renderPositionFromGame(){
      // find fallback grid
      const fallback = boardEl.querySelector('.fallback-board');
      if(!fallback) return;
      // clear pieces (leave coord)
      Array.from(fallback.children).forEach(cell=>{
        // remove previous piece nodes but keep coord span
        Array.from(cell.childNodes).forEach(n=>{
          if(n.nodeType===3) cell.removeChild(n);
        });
        // remove any element with class 'pieceGlyph'
        Array.from(cell.querySelectorAll('.pieceGlyph')).forEach(n=>n.remove());
      });

      let fenParts = null;
      if(game && typeof game.fen === 'function'){
        fenParts = game.fen().split(' ')[0];
      } else {
        // default start position FEN
        fenParts = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';
      }
      const rows = fenParts.split('/');
      // rows correspond to ranks 8..1
      for(let r=0;r<8;r++){
        const row = rows[r];
        let fileIndex = 0;
        for(let i=0;i<row.length;i++){
          const ch = row[i];
          if(/[1-8]/.test(ch)){
            fileIndex += parseInt(ch,10);
          } else {
            const files = ['a','b','c','d','e','f','g','h'];
            const rank = 8 - r;
            const file = files[fileIndex];
            const coord = file + rank;
            const cell = boardEl.querySelector('[data-coord="'+coord+'"]');
            if(cell){
              const glyph = document.createElement('div');
              glyph.className = 'pieceGlyph';
              glyph.style.fontSize = '1.6em';
              glyph.textContent = UNICODE[ch] || '';
              // insert before coord label
              cell.insertBefore(glyph, cell.firstChild);
            }
            fileIndex++;
          }
        }
      }
    }

    // flip fallback board
    function flipFallbackBoard(){
      const fallback = boardEl.querySelector('.fallback-board');
      if(!fallback) return;
      fallbackFlip = !fallbackFlip;
      if(fallbackFlip) fallback.classList.add('flip'); else fallback.classList.remove('flip');
    }

    // update notation listing
    function refreshNotation(){
      if(!movesList) return;
      if(!game || typeof game.history !== 'function'){ movesList.innerHTML = 'No moves yet.'; return; }
      const hist = game.history() || [];
      if(hist.length === 0){ movesList.innerHTML = 'No moves yet.'; return; }
      movesList.innerHTML = '';
      for(let i=0;i<hist.length;i+=2){
        const no = Math.floor(i/2)+1;
        const w = hist[i]||'';
        const b = hist[i+1]||'';
        const div = document.createElement('div');
        div.className = 'move';
        div.innerHTML = `<strong>${no}.</strong>&nbsp;${w}${ b ? ('\u00A0' + b) : '' }`;
        movesList.appendChild(div);
      }
    }

    // load puzzles_list.json (Option A) and populate tactics (derived from filenames)
    async function loadListAndPopulate(){
      try{
        const r = await fetch(LIST_URL, {cache:'no-cache'});
        if(!r.ok) throw new Error('List not found: ' + r.status);
        const files = await r.json();
        const manifest = { entries: [], tactics: {} };
        files.forEach(fn => {
          const key = fn.replace(/\.csv$/i,'').toLowerCase();
          const fileUrl = '/IQ4U-Chess-Classroom/assets/puzzle/' + fn;
          manifest.entries.push({ filename: fn, fileUrl, tactic: key });
          manifest.tactics[key] = manifest.tactics[key] || [];
          manifest.tactics[key].push(fn);
        });
        tacticSelect.innerHTML = '<option value="">— Select tactic —</option>';
        Object.keys(manifest.tactics).sort().forEach(t=>{
          const opt = document.createElement('option');
          opt.value = t;
          opt.textContent = t + ' (' + manifest.tactics[t].length + ')';
          tacticSelect.appendChild(opt);
        });
        window._clientManifest = manifest;
      }catch(e){
        console.warn('list load failed', e);
        tacticSelect.innerHTML = '<option>No list</option>';
      }
    }

    // CSV parsing helpers (same code as before)
    function normalizeHeaderCell(h){ return (h||'').toString().trim().toLowerCase().replace(/\s+/g,''); }
    function splitCsvHeader(line){
      const cols = []; let cur=''; let inQuote=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch==='"'){ inQuote=!inQuote; continue; }
        if(ch===',' && !inQuote){ cols.push(normalizeHeaderCell(cur)); cur=''; continue; }
        cur += ch;
      }
      cols.push(normalizeHeaderCell(cur));
      return cols;
    }
    function parseCsvRowToObject(cols,line){
      const vals=[]; let cur=''; let inQuote=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch==='"'){
          if(inQuote && line[i+1]==='"'){ cur+='"'; i++; continue; }
          inQuote=!inQuote; continue;
        }
        if(ch===',' && !inQuote){ vals.push(cur); cur=''; continue; }
        cur+=ch;
      }
      vals.push(cur);
      const obj={};
      for(let i=0;i<cols.length;i++) obj[cols[i]] = (vals[i]!==undefined)? vals[i].trim() : '';
      return obj;
    }

    async function streamCsvFilter(fileUrl, {minRating=0,maxRating=99999,onMatch=null,maxMatches=200} = {}){
      try{
        const resp = await fetch(fileUrl, {cache:'no-cache'});
        if(!resp.ok) throw new Error('fetch failed ' + resp.status);
        const reader = resp.body.getReader();
        const dec = new TextDecoder('utf-8');
        let { value, done } = await reader.read();
        let buf=''; let cols=null; let matches=0; let rowNum=0;
        while(!done){
          buf += dec.decode(value,{stream:true});
          let lines = buf.split(/\r?\n/);
          buf = lines.pop();
          for(const line of lines){
            if(!line) continue;
            if(!cols){ cols = splitCsvHeader(line); continue; }
            rowNum++;
            const rowObj = parseCsvRowToObject(cols,line);
            const rstr = (rowObj['rating']||'0').replace(/[^0-9]/g,'');
            const rating = parseInt(rstr,10)||0;
            if(rating >= minRating && rating <= maxRating){
              if(onMatch){
                const stop = await onMatch(rowObj, {fileUrl,rowNum});
                matches++;
                if(matches >= maxMatches){ reader.cancel().catch(()=>{}); return matches; }
                if(stop){ reader.cancel().catch(()=>{}); return matches; }
              }
            }
          }
          ({value,done} = await reader.read());
        }
        if(buf && cols){
          const rowObj = parseCsvRowToObject(cols,buf);
          const rstr = (rowObj['rating']||'0').replace(/[^0-9]/g,'');
          const rating = parseInt(rstr,10)||0;
          if(rating >= minRating && rating <= maxRating){
            if(onMatch) await onMatch(rowObj, {fileUrl,rowNum});
          }
        }
        return 0;
      }catch(e){ console.warn('stream error', e); return 0; }
    }

    // build candidate list for selected tactic
    async function buildCandidatesForTactic(tacticName){
      puzzleInfo.textContent = 'Scanning…';
      currentCandidateList = [];
      if(!window._clientManifest || !window._clientManifest.tactics || !window._clientManifest.tactics[tacticName]){ puzzleInfo.textContent='None'; return; }
      const files = window._clientManifest.tactics[tacticName];
      const minR = parseInt(ratingMin.value,10)||0;
      const maxR = parseInt(ratingMax.value,10)||99999;
      let total = 0;
      for(const fname of files){
        if(total >= 400) break;
        const fileUrl = '/IQ4U-Chess-Classroom/assets/puzzle/' + fname;
        await streamCsvFilter(fileUrl, {
          minRating: minR, maxRating: maxR, maxMatches:200,
          onMatch: async (row,meta)=>{
            currentCandidateList.push({row,meta});
            total++;
            if(total >= 400) return true;
            return false;
          }
        });
      }
      puzzleInfo.textContent = `${currentCandidateList.length} puzzles found`;
    }

    // load puzzle by index (first/random)
    async function loadPuzzleByCandidateIndex(idx){
      const cand = currentCandidateList[idx];
      if(!cand){ puzzleInfo.textContent='No puzzle'; return; }
      const raw = cand.row;
      const fen = (raw['fen']||'').trim();
      const pgn = (raw['pgn']||'').trim();
      const moves = (raw['moves']||'').trim();
      const desc = raw['puzzleid'] || raw['themes'] || 'Puzzle';
      puzzleInfo.textContent = 'Loading ' + desc;
      // ensure chess engine exists
      if(typeof Chess === 'undefined'){
        // no chess engine: show quick FEN fallback by drawing fen string (render pieces from fen)
        try{
          // create minimal fen->grid rendering without chess.js
          // parse fen and update fallback board
          parseFenToFallback(fen);
        }catch(e){ console.warn('fallback fen render failed', e); }
        return;
      }
      // use chess.js to load fen/pgn/moves
      try{
        if(fen){
          if(!game) game = new Chess();
          game.load(fen);
        } else if(pgn){
          if(!game) game = new Chess();
          try{ game.load_pgn(pgn); }catch(e){ console.warn('load_pgn failed', e); game.reset(); }
        } else if(moves){
          if(!game) game = new Chess();
          game.reset();
          const sanOnly = moves.replace(/\d+\.+/g,'').replace(/\(/g,'').replace(/\)/g,'').replace(/,+/g,' ').trim();
          const tokens = sanOnly.split(/\s+/).filter(t=>t);
          for(const san of tokens) try{ game.move(san, { sloppy:true }); }catch(e){}
        } else {
          // nothing usable
          puzzleInfo.textContent = 'Puzzle has no FEN/PGN/Moves';
          return;
        }

        // update board (chessboard.js or fallback)
        if(boardInstance && typeof boardInstance.position === 'function'){
          boardInstance.position(game.fen());
        } else {
          // ensure fallback board exists
          if(!boardEl.querySelector('.fallback-board')) createFallbackBoard();
          renderPositionFromGame();
        }
        refreshNotation();
        puzzleInfo.textContent = 'Loaded: ' + desc;
      }catch(e){
        console.warn('load puzzle error', e);
        puzzleInfo.textContent = 'Load error: ' + (e.message||'');
      }
    }

    // if chess.js missing parse FEN and display on fallback board
    function parseFenToFallback(fen){
      if(!fen) return;
      // create fallback if needed
      if(!boardEl.querySelector('.fallback-board')) createFallbackBoard();
      // temporary fake game: create minimal structure with fen
      // reuse renderPositionFromGame by creating a temporary game-like object:
      try{
        // quick replacement: create a minimal object whose fen() returns fen
        const savedGame = game;
        game = { fen: () => fen, history: () => [] };
        renderPositionFromGame();
        game = savedGame;
      }catch(e){ console.warn(e); }
    }

    // UI events
    tacticSelect.addEventListener('change', ()=>{ const t = tacticSelect.value; if(!t) return; buildCandidatesForTactic(t); });
    loadPuzzleBtn.addEventListener('click', ()=>{ loadPuzzleByCandidateIndex(0); });
    randomPuzzleBtn.addEventListener('click', ()=>{ if(currentCandidateList.length===0) { puzzleInfo.textContent='No puzzles'; return; } const i = Math.floor(Math.random()*currentCandidateList.length); loadPuzzleByCandidateIndex(i); });

    // basic controls
    undoBtn.addEventListener('click', ()=>{
      if(!game || typeof game.undo !== 'function') return;
      const mv = game.undo();
      if(mv){
        if(boardInstance && typeof boardInstance.position === 'function') boardInstance.position(game.fen());
        else renderPositionFromGame();
        refreshNotation();
      }
    });
    flipBtn.addEventListener('click', ()=>{
      if(boardInstance && boardEl.querySelector('.chessboard') ){
        // flip chessboard.js if available
        try{ boardInstance.flip(); }catch(e){}
      }
      // flip fallback
      flipFallbackBoard();
    });
    resignBtn.addEventListener('click', ()=>{
      if(game && typeof game.reset === 'function') game.reset();
      if(boardInstance && typeof boardInstance.position === 'function') boardInstance.position('start');
      else renderPositionFromGame();
      refreshNotation();
      puzzleInfo.textContent = 'Resigned / reset';
    });

    // boot sequence
    (async function boot(){
      setMsg('');
      // try create Chessboard first; if it fails, fallback will render
      await tryCreateBoard();
      // load list
      await loadListAndPopulate();
      setMsg('Ready');
    })();

    // expose debug helpers
    window._puzzleLoader = { candidates: () => currentCandidateList, manifest: () => window._clientManifest || null };

  })();
  </script>
</body>
</html>
