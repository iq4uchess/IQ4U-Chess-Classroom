<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U — Student Puzzle (student2)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    html,body{ overscroll-behavior-y: contain; height:100%; }
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; -webkit-font-smoothing:antialiased; display:flex; flex-direction:column; align-items:center; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); margin:0 auto; max-width:980px; width:100%; box-sizing:border-box; }
    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; text-align:center; }
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; width:100%; }
    #board-wrapper{ width:100%; max-width:760px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; margin:0 auto; position:relative; padding:16px; }
    #board-wrapper, #board { touch-action: none; -webkit-user-select: none; -webkit-touch-callout: none; user-select: none; -ms-touch-action: none; }
    #board{ width:100%; aspect-ratio: 1 / 1; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; max-height:88vh; min-width:520px; min-height:520px; box-shadow: 0 6px 18px rgba(2,6,23,0.04); border-radius:8px; padding:6px; }
    .resizer{ display:flex; gap:10px; align-items:center; background:transparent; justify-content:center; width:100%; }
    .resizer .range{ width:320px; }
    .resizer small{ color:#444; display:block; min-width:48px; text-align:center; font-size:13px; }
    textarea{ width:100%; max-width:720px; min-height:80px; padding:8px; border-radius:6px; border:1px solid #e6eefc; font-family:monospace; display:block; margin:0 auto; box-sizing:border-box; }
    .notation { margin-top:12px; padding:8px; border-radius:6px; border:1px solid #eef2ff; background:#fbfdff; min-height:44px; max-height:180px; overflow:auto; font-family:monospace; font-size:13px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .notation .move { white-space:normal; display:inline-block; padding:4px 8px; border-radius:6px; background:transparent; }
    .notation .move.current { background:#0f172a; color:#fff; }
    .tactic-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .solution-controls { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .solution-controls .small { margin-left:6px; margin-right:2px; }
    @media (max-width:900px){
      #board{ height:80vw; width:100%; aspect-ratio: auto; max-height:620px; min-width:300px; min-height:300px; }
      .resizer .range{ width:200px; }
    }
    .status-bubble { padding:8px 10px; border-radius:8px; background:#f3f6ff; border:1px solid #e6eeff; color:#0b2; font-weight:600; }
    .promote-modal { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; border-radius:10px; padding:12px; box-shadow:0 10px 30px rgba(2,6,23,0.2); z-index:9999; display:none; }
    .logout-btn { background:#dc2626; }
    .stats { margin-top:10px; display:flex; gap:16px; align-items:center; justify-content:flex-end; font-weight:600; color:#111; }
    .cb-last-move { outline: 3px solid rgba(255,200,0,0.95); outline-offset: -3px; box-shadow: inset 0 0 0 2px rgba(255,200,0,0.25); }
    .puzzle-meta { margin-left:8px; font-weight:600; color:#222; }
  </style>
</head>

<body>

<!-- ACCESS CHECK: strict for student2 only -->
<script>
(function(){
  const allowedRoles = ['student2'];
  const role = localStorage.getItem('role');
  if(!role || allowedRoles.indexOf(role) === -1){
    try{ window.location.replace('index.html'); }catch(e){ window.location.href='index.html'; }
  }
})();
</script>
  <div class="panel">
    <div class="controls" aria-hidden="false">
      <button id="undoBtn">Undo</button>
      <button id="flipBtn">Flip</button>
      <button id="resignBtn" title="Resign / Reset" style="background:#8b0f0f;">Resign</button>
      <button id="logoutBtn" class="logout-btn" style="margin-left:auto;">Logout</button>
    </div>

    <div class="resizer" aria-label="Board resizer controls" style="margin-top:6px;">
      <input id="boardSizeRange" name="board-size" class="range" type="range" min="360" max="1400" step="10" value="760" aria-label="Board size">
      <small id="boardSizeLabel">760px</small>
    </div>

    <div id="board-wrapper" style="margin-top:12px;">
      <div id="board" aria-label="Chessboard container"></div>
      <svg id="draw-overlay" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"></svg>
    </div>

    <div id="msg" class="info" aria-live="polite">Ready</div>

    <div id="movesList" class="notation" aria-live="polite" role="status">No moves yet.</div>
  </div>

  <!-- Puzzle controls -->
  <div class="panel" style="margin-top:18px;">
    <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
      <div class="tactic-row" aria-label="Puzzle controls">
        <label class="small">Tactic:</label>
        <select id="tacticSelect"><option>Loading tactics…</option></select>

        <label class="small">Min rating:</label>
        <select id="ratingMin">
          <option>0</option>
          <option>600</option>
          <option selected>800</option>
          <option>1000</option>
          <option>1200</option>
        </select>

        <label class="small">Max rating:</label>
        <select id="ratingMax">
          <option selected>99999</option>
          <option>1000</option>
          <option>1200</option>
          <option>1400</option>
          <option>1600</option>
        </select>

        <button id="loadPuzzleBtn">Load (first)</button>
        <button id="randomPuzzleBtn">Random</button>
      </div>

      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <button id="prevPuzzleBtn">Previous</button>
        <button id="nextPuzzleBtn">Next</button>
        <div class="puzzle-meta" id="currentPuzzleId">No puzzle</div>
      </div>
    </div>

    <div class="solution-controls" id="solutionControls" style="margin-top:12px;">
      <label>
        <input type="checkbox" id="autoOpponent" checked />
        <span class="small">Auto opponent moves</span>
      </label>

      <button id="showSolutionBtn">Show Solution</button>
      <button id="resetSolutionBtn">Reset Solution</button>

      <label class="small">Speed:</label>
      <select id="solutionSpeed">
        <option value="1200">1.2s</option>
        <option value="800">0.8s</option>
        <option value="500" selected>0.5s</option>
        <option value="250">0.25s</option>
      </select>

      <div id="solutionStatus" class="muted small" style="margin-left:auto;">
        No solution loaded
      </div>
    </div>

    <div class="stats" id="statsBar">
      <div>Correct: <span id="statCorrect">0</span></div>
      <div>Incorrect: <span id="statIncorrect">0</span></div>
      <div>Total attempts: <span id="statAttempts">0</span></div>
      <div>Puzzles: <span id="statPuzzles">0</span></div>
      <div>Avg rating: <span id="statAvgRating">0</span></div>
    </div>
  </div>

  <div class="panel multiplayer-panel" style="margin-top:18px;" id="multiplayerPanel">
    <div style="display:flex; gap:8px; align-items:center;">
      <label for="emailInputBottom" class="small">Your username:</label>
      <input id="emailInputBottom" name="username" type="text" placeholder="your username (e.g. student2)" />
      <button id="joinBtnBottom">Join Online</button>
    </div>

    <div style="margin-left:auto; display:flex; gap:8px; align-items:center; margin-top:10px;">
      <div id="multiplayStatus" class="muted">Not connected</div>
      <div id="pairedBubble" class="status-bubble" style="display:none;">Paired</div>
    </div>
  </div>

  <div class="promote-modal" id="promoteModal" role="dialog" aria-modal="true">
    <div style="font-weight:700; text-align:center; margin-bottom:8px;">
      Choose promotion
    </div>
    <div class="row">
      <button data-piece="q">Q</button>
      <button data-piece="r">R</button>
      <button data-piece="b">B</button>
      <button data-piece="n">N</button>
    </div>
  </div>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
<script>
// GLOBAL GAME INSTANCE - REQUIRED FOR MASTER SPECTATING
window.game = null;

(function(){
  // Config - USING RELATIVE PATH FOR PUZZLES
  const PIECES_BASE = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/';
  const LIST_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/puzzles_list.json';

  // DOM
  const boardEl = document.getElementById('board');
  const boardWrapper = document.getElementById('board-wrapper');
  const drawOverlay = document.getElementById('draw-overlay');
  const boardSizeRange = document.getElementById('boardSizeRange');
  const boardSizeLabel = document.getElementById('boardSizeLabel');
  const msgEl = document.getElementById('msg');
  const movesList = document.getElementById('movesList');

  const tacticSelect = document.getElementById('tacticSelect');
  const ratingMin = document.getElementById('ratingMin');
  const ratingMax = document.getElementById('ratingMax');
  const loadPuzzleBtn = document.getElementById('loadPuzzleBtn');
  const randomPuzzleBtn = document.getElementById('randomPuzzleBtn');
  const prevPuzzleBtn = document.getElementById('prevPuzzleBtn');
  const nextPuzzleBtn = document.getElementById('nextPuzzleBtn');
  const currentPuzzleIdEl = document.getElementById('currentPuzzleId');

  const autoOpponent = document.getElementById('autoOpponent');
  const showSolutionBtn = document.getElementById('showSolutionBtn');
  const resetSolutionBtn = document.getElementById('resetSolutionBtn');
  const solutionSpeed = document.getElementById('solutionSpeed');
  const solutionStatus = document.getElementById('solutionStatus');

  const statCorrectEl = document.getElementById('statCorrect');
  const statIncorrectEl = document.getElementById('statIncorrect');
  const statAttemptsEl = document.getElementById('statAttempts');
  const statPuzzlesEl = document.getElementById('statPuzzles');
  const statAvgRatingEl = document.getElementById('statAvgRating');

  const undoBtn = document.getElementById('undoBtn');
  const flipBtn = document.getElementById('flipBtn');
  const resignBtn = document.getElementById('resignBtn');
  const logoutBtn = document.getElementById('logoutBtn');

  const emailInputBottom = document.getElementById('emailInputBottom');
  const joinBtnBottom = document.getElementById('joinBtnBottom');
  const multiplayStatus = document.getElementById('multiplayStatus');
  const pairedBubble = document.getElementById('pairedBubble');

  // State
  let board = null;
  window.game = new Chess(); // EXPOSED GLOBALLY FOR SPECTATING
  let currentTheme = null;
  let currentCandidateList = [];
  let currentCandidateIndex = -1;

  // Solution state
  let solutionMoves = [];
  let solutionMoveTypes = [];
  let solutionIndex = 0;
  let initialFen = null;
  let solutionTimer = null;
  let initialSideToMove = null;
  let solutionDisplayed = false;

  // Stats
  let statCorrect = 0;
  let statIncorrect = 0;
  let statAttempts = 0;
  let statPuzzles = 0;
  let statRatingSum = 0;

  // FEN Emitter (for master spectating) - SIMPLE VERSION
  window.emitFenToMaster = function() {
    if (!window.game || !window.firebaseMultiplayer) return;
    try {
      const fen = window.game.fen();
      // Use the same method as student1.html
      if (window.firebaseMultiplayer.emitFen) {
        window.firebaseMultiplayer.emitFen({ fen: fen });
      }
    } catch(e) {
      console.warn('FEN emit failed:', e);
    }
  };

  // Helpers
  function setMsg(t,ms=0){
    if(msgEl) msgEl.textContent = t||'';
    if(ms>0) setTimeout(()=>{ if(msgEl && msgEl.textContent===t) msgEl.textContent=''; }, ms);
  }
  function pieceTheme(piece){ return PIECES_BASE + piece + '.svg'; }
  
  function createBoard(){
    if(board && typeof board.destroy==='function'){ try{ board.destroy(); }catch(e){} }
    if(!window.game) window.game = new Chess();
    board = Chessboard('board', {
      draggable: true,
      position: window.game ? window.game.fen() : 'start',
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: pieceTheme
    });
    try{ board.position(window.game.fen()); }catch(e){}
    updateOverlaySize();
  }
  
  function onSnapEnd(){ 
    if(board && window.game) board.position(window.game.fen());
  }

  /* ---- PROMOTION MODAL ---- */
  const promoteModal = document.getElementById('promoteModal');
  let pendingPromo = null;
  function showPromotionDialog(){ promoteModal.style.display='block'; }
  function hidePromotionDialog(){ promoteModal.style.display='none'; }
  promoteModal.addEventListener('click', function(e){
    if(e.target && e.target.dataset && e.target.dataset.piece){
      const p = e.target.dataset.piece;
      if(pendingPromo && pendingPromo.resolve) pendingPromo.resolve(p);
      pendingPromo = null;
      hidePromotionDialog();
    }
  });

  /* ---- LAST MOVE HIGHLIGHT ---- */
  let lastMoveSquares = [];
  function setPersistentLastMove(src, tgt){
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    ['square-'+src,'square-'+tgt].forEach(cls=>{
      const el = document.querySelector('.'+cls);
      if(el) el.classList.add('cb-last-move');
      lastMoveSquares.push(cls.replace('square-',''));
    });
  }

  /* ---- NOTATION ---- */
  function refreshNotation(highlightIndex=-1){
    try{
      if(!movesList) return;
      if(solutionDisplayed && solutionMoves.length){
        displayMovesInNotation(convertToSAN(solutionMoves, solutionMoveTypes), highlightIndex);
        return;
      }
      const hist = window.game ? window.game.history() : [];
      if(hist.length===0){ movesList.innerHTML='No moves yet.'; return; }
      displayMovesInNotation(hist, highlightIndex);
    }catch(e){}
  }

  function displayMovesInNotation(arr, highlightIndex){
    movesList.innerHTML='';
    for(let i=0;i<arr.length;i+=2){
      const no = Math.floor(i/2)+1;
      const div = document.createElement('div');
      div.className='move';
      div.innerHTML=`<strong>${no}.</strong> ${arr[i]||''} ${arr[i+1]||''}`;
      movesList.appendChild(div);
    }
  }

  function convertToSAN(tokens, types){
    if(!initialFen) return tokens;
    const san=[];
    const temp=new Chess(initialFen);
    tokens.forEach((t,i)=>{
      if(types[i]==='san'){
        const m=temp.move(t,{sloppy:true});
        san.push(m?m.san:t);
      }else{
        const m=t.match(/^([a-h][1-8])([a-h][1-8])([nbrq])?$/i);
        if(m){
          const mv=temp.move({from:m[1],to:m[2],promotion:m[3]});
          san.push(mv?mv.san:t);
        }else san.push(t);
      }
    });
    return san;
  }

  /* ---- BOARD DROP ---- */
  async function onDrop(source,target){
    const legal = window.game.moves({verbose:true});
    let promo = legal.find(m=>m.from===source && m.to===target && m.promotion);
    let p=null;
    if(promo){
      p=await new Promise(r=>{ pendingPromo={resolve:r}; showPromotionDialog(); });
      if(!p) p='q';
    }
    const mv=window.game.move({from:source,to:target,promotion:p});
    if(!mv) return 'snapback';
    board.position(window.game.fen());
    setPersistentLastMove(mv.from,mv.to);
    solutionDisplayed=false;
    refreshNotation();
    // Emit FEN to master
    setTimeout(() => window.emitFenToMaster(), 10);
    return;
  }

  /* ---- RESIZE ---- */
  function updateOverlaySize(){
    const r=boardEl.getBoundingClientRect();
    drawOverlay.style.width=r.width+'px';
    drawOverlay.style.height=r.height+'px';
  }

  boardSizeRange.addEventListener('input',e=>{
    const v=+e.target.value;
    boardWrapper.style.maxWidth=v+'px';
    boardSizeLabel.textContent=v+'px';
    board.resize();
    updateOverlaySize();
  });

  undoBtn.onclick=()=>{ 
    if(window.game.undo()){
      board.position(window.game.fen()); 
      refreshNotation(); 
      window.emitFenToMaster();
    }
  };
  
  flipBtn.onclick=()=>{ board.flip(); updateOverlaySize(); };
  
  resignBtn.onclick=()=>{ 
    window.game.reset(); 
    board.position('start'); 
    refreshNotation(); 
    window.emitFenToMaster();
  };
  
  logoutBtn.onclick=()=>{ 
    localStorage.clear(); 
    if (window.firebaseMultiplayer && window.firebaseMultiplayer.goOffline) {
      window.firebaseMultiplayer.goOffline();
    }
    location.href='index.html'; 
  };

  /* ---- PUZZLE SYSTEM ---- */
  let puzzlesList = [];
  let currentPuzzle = null;

  async function loadPuzzlesList() {
    try {
      // Try multiple paths in case one fails
      const paths = [
        LIST_URL,
        'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/puzzles_list.json',
        '/assets/puzzles_list.json',
        'assets/puzzles_list.json',
        'https://raw.githubusercontent.com/iq4uchess/IQ4U-Chess-Classroom/main/assets/puzzles_list.json'
      ];
      
      let loaded = false;
      let lastError = null;
      
      for (const url of paths) {
        try {
          console.log('Trying to load puzzles from:', url);
          const response = await fetch(url + '?t=' + Date.now());
          if (response.ok) {
            puzzlesList = await response.json();
            console.log('Loaded', puzzlesList.length, 'puzzles from', url);
            populateTacticSelect();
            loaded = true;
            break;
          }
        } catch(e) {
          lastError = e;
          console.warn('Failed to load from', url, e);
        }
      }
      
      if (!loaded) {
        // Fallback to sample data if loading fails
        console.log('Using fallback sample puzzles');
        puzzlesList = getSamplePuzzles();
        populateTacticSelect();
        setMsg('Using sample puzzles (network issue)', 3000);
      }
    } catch(e) {
      console.error('Failed to load puzzles:', e);
      // Use sample puzzles as last resort
      puzzlesList = getSamplePuzzles();
      populateTacticSelect();
      setMsg('Using sample puzzles', 3000);
    }
  }

  // Fallback sample puzzles
  function getSamplePuzzles() {
    return [
      {
        id: 1,
        fen: "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3",
        moves: ["Nxe5", "Nxe5", "d4"],
        moveTypes: ["san", "san", "san"],
        tactic: "Fork",
        rating: 1200
      },
      {
        id: 2,
        fen: "r1bqk1nr/pppp1ppp/2n5/2b1p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4",
        moves: ["O-O", "Nf6", "Ng5"],
        moveTypes: ["san", "san", "san"],
        tactic: "Attack",
        rating: 1100
      },
      {
        id: 3,
        fen: "r1bqkb1r/pppp1ppp/2n2n2/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 6 5",
        moves: ["d3", "Bc5", "O-O"],
        moveTypes: ["san", "san", "san"],
        tactic: "Development",
        rating: 1000
      },
      {
        id: 4,
        fen: "r2qkbnr/ppp2ppp/2np4/4p3/4P3/3P1N2/PPP2PPP/RNBQKB1R w KQkq - 0 5",
        moves: ["Bf4", "Bg4", "h3"],
        moveTypes: ["san", "san", "san"],
        tactic: "Pin",
        rating: 1300
      }
    ];
  }

  function populateTacticSelect() {
    tacticSelect.innerHTML = '';
    
    // Add "All" option first
    const allOpt = document.createElement('option');
    allOpt.value = '';
    allOpt.textContent = 'All tactics';
    tacticSelect.appendChild(allOpt);
    
    // Get unique tactics
    const tactics = [...new Set(puzzlesList.map(p => p.tactic || 'Unknown'))];
    
    tactics.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      tacticSelect.appendChild(opt);
    });
    
    filterCandidates();
  }

  function filterCandidates() {
    const tactic = tacticSelect.value;
    const minRating = parseInt(ratingMin.value) || 0;
    const maxRating = parseInt(ratingMax.value) || 99999;
    
    currentCandidateList = puzzlesList.filter(p => {
      if (tactic && p.tactic !== tactic) return false;
      const rating = p.rating || 0;
      return rating >= minRating && rating <= maxRating;
    });
    
    currentCandidateIndex = -1;
    setMsg(`Found ${currentCandidateList.length} puzzles`, 1500);
    
    // Update buttons state
    loadPuzzleBtn.disabled = currentCandidateList.length === 0;
    randomPuzzleBtn.disabled = currentCandidateList.length === 0;
    prevPuzzleBtn.disabled = true;
    nextPuzzleBtn.disabled = true;
  }

  function loadPuzzleAtIndex(index) {
    if (currentCandidateList.length === 0 || index < 0 || index >= currentCandidateList.length) {
      setMsg('No puzzles available', 1500);
      return;
    }
    
    currentCandidateIndex = index;
    currentPuzzle = currentCandidateList[index];
    
    // Reset game to puzzle FEN
    window.game.load(currentPuzzle.fen);
    if (board) board.position(window.game.fen());
    
    // Store solution data
    solutionMoves = currentPuzzle.moves || [];
    solutionMoveTypes = currentPuzzle.moveTypes || [];
    initialFen = currentPuzzle.fen;
    solutionIndex = 0;
    solutionDisplayed = false;
    
    // Clear any existing timer
    if (solutionTimer) {
      clearInterval(solutionTimer);
      solutionTimer = null;
      showSolutionBtn.textContent = 'Show Solution';
    }
    
    // Update UI
    currentPuzzleIdEl.textContent = `#${currentPuzzle.id || (index + 1)} (${currentPuzzle.rating || '?'})`;
    solutionStatus.textContent = `Loaded: ${currentPuzzle.tactic || 'Tactic'} (${currentPuzzle.rating || '?'})`;
    refreshNotation();
    
    // Update stats
    statPuzzles++;
    statRatingSum += (currentPuzzle.rating || 0);
    updateStats();
    
    // Update navigation buttons
    prevPuzzleBtn.disabled = currentCandidateIndex <= 0;
    nextPuzzleBtn.disabled = currentCandidateIndex >= currentCandidateList.length - 1;
    
    window.emitFenToMaster();
  }

  function playNextSolutionMove() {
    if (solutionIndex >= solutionMoves.length) {
      if (solutionTimer) {
        clearInterval(solutionTimer);
        solutionTimer = null;
        showSolutionBtn.textContent = 'Show Solution';
        solutionStatus.textContent = 'Solution complete';
      }
      return;
    }
    
    const move = solutionMoves[solutionIndex];
    const type = solutionMoveTypes[solutionIndex];
    
    try {
      if (type === 'san') {
        const mv = window.game.move(move, {sloppy: true});
        if (mv) {
          if (board) board.position(window.game.fen());
          setPersistentLastMove(mv.from, mv.to);
        }
      } else {
        // UCI-like format: e2e4 or e7e8q
        const from = move.slice(0, 2);
        const to = move.slice(2, 4);
        const promotion = move.length > 4 ? move[4] : undefined;
        const mv = window.game.move({from, to, promotion});
        if (mv) {
          if (board) board.position(window.game.fen());
          setPersistentLastMove(mv.from, mv.to);
        }
      }
      
      solutionIndex++;
      refreshNotation(solutionIndex - 1);
      window.emitFenToMaster();
    } catch(e) {
      console.warn('Solution move failed:', e);
    }
  }

  function updateStats() {
    statCorrectEl.textContent = statCorrect;
    statIncorrectEl.textContent = statIncorrect;
    statAttemptsEl.textContent = statAttempts;
    statPuzzlesEl.textContent = statPuzzles;
    const avg = statPuzzles > 0 ? Math.round(statRatingSum / statPuzzles) : 0;
    statAvgRatingEl.textContent = avg;
  }

  // Auto opponent simulation
  let autoOpponentTimer = null;
  
  function setupAutoOpponent() {
    if (autoOpponentTimer) {
      clearInterval(autoOpponentTimer);
      autoOpponentTimer = null;
    }
    
    if (autoOpponent.checked && currentPuzzle && !solutionDisplayed && solutionIndex < solutionMoves.length) {
      autoOpponentTimer = setInterval(() => {
        if (solutionIndex < solutionMoves.length) {
          playNextSolutionMove();
        } else {
          clearInterval(autoOpponentTimer);
          autoOpponentTimer = null;
        }
      }, 1500); // Auto opponent moves every 1.5 seconds
    }
  }

  // Event listeners for puzzle controls
  loadPuzzleBtn.addEventListener('click', () => {
    if (currentCandidateList.length > 0) {
      loadPuzzleAtIndex(0);
    }
  });

  randomPuzzleBtn.addEventListener('click', () => {
    if (currentCandidateList.length > 0) {
      const idx = Math.floor(Math.random() * currentCandidateList.length);
      loadPuzzleAtIndex(idx);
    }
  });

  prevPuzzleBtn.addEventListener('click', () => {
    if (currentCandidateList.length > 0 && currentCandidateIndex > 0) {
      loadPuzzleAtIndex(currentCandidateIndex - 1);
    }
  });

  nextPuzzleBtn.addEventListener('click', () => {
    if (currentCandidateList.length > 0 && currentCandidateIndex < currentCandidateList.length - 1) {
      loadPuzzleAtIndex(currentCandidateIndex + 1);
    }
  });

  tacticSelect.addEventListener('change', filterCandidates);
  ratingMin.addEventListener('change', filterCandidates);
  ratingMax.addEventListener('change', filterCandidates);

  showSolutionBtn.addEventListener('click', () => {
    if (!currentPuzzle) return;
    
    if (solutionTimer) {
      clearInterval(solutionTimer);
      solutionTimer = null;
      showSolutionBtn.textContent = 'Show Solution';
      solutionStatus.textContent = 'Solution paused';
      return;
    }
    
    // Reset to initial position
    window.game.load(initialFen);
    if (board) board.position(window.game.fen());
    solutionIndex = 0;
    solutionDisplayed = true;
    
    const speed = parseInt(solutionSpeed.value) || 500;
    solutionTimer = setInterval(playNextSolutionMove, speed);
    showSolutionBtn.textContent = 'Pause Solution';
    solutionStatus.textContent = 'Playing solution...';
    window.emitFenToMaster();
  });

  resetSolutionBtn.addEventListener('click', () => {
    if (solutionTimer) {
      clearInterval(solutionTimer);
      solutionTimer = null;
    }
    
    if (currentPuzzle) {
      window.game.load(initialFen);
      if (board) board.position(window.game.fen());
      solutionIndex = 0;
      solutionDisplayed = false;
      showSolutionBtn.textContent = 'Show Solution';
      solutionStatus.textContent = 'Solution reset';
      refreshNotation();
      window.emitFenToMaster();
    }
  });

  autoOpponent.addEventListener('change', () => {
    setupAutoOpponent();
    window.emitFenToMaster();
  });

  // Update speed when changed
  solutionSpeed.addEventListener('change', () => {
    if (solutionTimer) {
      clearInterval(solutionTimer);
      const speed = parseInt(solutionSpeed.value) || 500;
      solutionTimer = setInterval(playNextSolutionMove, speed);
    }
  });

  /* ---- BOOT ---- */
  (async function(){
    createBoard();
    refreshNotation();
    await loadPuzzlesList();
    setMsg('Ready', 700);
    
    // Auto-setup auto opponent
    autoOpponent.addEventListener('change', setupAutoOpponent);
  })();

})();
</script>
<!-- FIREBASE - IDENTICAL TO student1.html -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<script>
(function(){
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
    authDomain: "iq4u-chess-classroom.firebaseapp.com",
    databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "iq4u-chess-classroom",
    storageBucket: "iq4uchess-classroom.firebasedestorage.app",
    messagingSenderId: "833620718306",
    appId: "1:833620718306:web:b599bb6936fe0da4bb"
  };
  try{ firebase.initializeApp(FIREBASE_CONFIG); }catch(e){}

  (function(){
    const db = firebase.database();
    const onlineRef = db.ref('online');
    const gamesRef = db.ref('games');

    let myId = sessionStorage.getItem('iq4u_clientId') ||
      ('c_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', myId);

    let myEmail = '';
    let currentGameId = null;
    let presenceTimer = null;
    let isSpectated = false;

    function goOnline(email){
      myEmail = email || ('anon-'+myId);
      const node = onlineRef.child(myId);
      node.set({ email: myEmail, role: 'student', ts: firebase.database.ServerValue.TIMESTAMP });
      if(presenceTimer) clearInterval(presenceTimer);
      presenceTimer = setInterval(
        ()=>node.update({ ts: firebase.database.ServerValue.TIMESTAMP }),
        25000
      );
      document.getElementById('multiplayStatus').textContent =
        'Connected as ' + myEmail;
    }

    function goOffline(){
      if(presenceTimer) clearInterval(presenceTimer);
      onlineRef.child(myId).remove().catch(()=>{});
      document.getElementById('multiplayStatus').textContent = 'Not connected';
      isSpectated = false;
    }

    document.getElementById('joinBtnBottom').addEventListener('click', ()=>{
      const email = (document.getElementById('emailInputBottom').value||'').trim();
      if(!email) return alert('Enter username');
      goOnline(email);
    });

    /* =========================================================
       SPECTATE INVITE HANDLER (IDENTICAL TO student1.html)
       ========================================================= */
    db.ref('spectateInvites/'+myId).on('child_added', snap=>{
      const invite = snap.val();
      if(!invite) return;

      const fromEmail = invite.fromEmail || invite.fromId || 'Master';
      const accept = confirm(fromEmail + ' wants to spectate your board. Accept?');

      // Get current FEN - using window.game which is now globally available
      const currentFen = window.game ? window.game.fen() : 
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

      // Send response - IDENTICAL TO student1.html
      if(invite.fromId){
        const respPath = `spectateResponses/${invite.fromId}/${myId}`;
        
        db.ref(respPath).set({
          studentId: myId,
          studentEmail: myEmail || null,
          accepted: accept,
          boardId: invite.boardId || null,
          fen: accept ? currentFen : null,
          ts: firebase.database.ServerValue.TIMESTAMP
        }).catch(err=>{
          console.warn('[STUDENT2] spectate response failed', err);
        });
      }

      // If accepted, set flag
      if (accept) {
        isSpectated = true;
        document.getElementById('multiplayStatus').textContent = 'Master is spectating';
      }

      snap.ref.remove().catch(()=>{});
    });

    /* =========================================================
       FIREBASE MULTIPLAYER OBJECT (IDENTICAL TO student1.html)
       ========================================================= */
    window.firebaseMultiplayer = {
      emitMove: function(arg){
        if(!currentGameId) return;
        db.ref('moves/'+currentGameId).push({
          payload: arg,
          by: myId,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      },
      emitFen: function(arg){
        // Write to moves/<myId> path - exactly like student1.html
        db.ref('moves/'+myId).push({
          payload: arg,
          by: myId,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      },
      getMyId: ()=>myId,
      getMyEmail: ()=>myEmail,
      goOffline: goOffline
    };

    // Auto-join if username exists
    setTimeout(() => {
      const saved = (emailInputBottom && emailInputBottom.value) ? emailInputBottom.value.trim() : 
                   (localStorage.getItem('username') || localStorage.getItem('email') || '');
      if(saved){
        goOnline(saved);
      }
    }, 500);

  })();
})();
</script>

</body>
</html>
