<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Master Dashboard - IQ 4U Academy</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    :root{ --card-gap:12px; --card-bg:#fff; --card-border:#ddd; --control-height:44px; font-family:Arial,Helvetica,sans-serif; color:#222;}
    html,body{ height:100%; margin:0; background:#f5f7fb; }
    .container{ margin:16px auto; max-width:1200px; padding-bottom:28px; }
    h1{ margin:0 0 12px 0; font-size:20px; }
    .boards-grid{ display:grid; grid-template-columns:1fr 1fr; gap:var(--card-gap); }
    .board-card{ background:var(--card-bg); border:1px solid var(--card-border); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:10px; min-height:260px; box-shadow:0 1px 3px rgba(20,30,40,0.05); }
    .top-strip{ display:flex; align-items:center; justify-content:flex-start; gap:8px; height:var(--control-height); }
    .student-label{ font-weight:600; text-align:center; display:flex; align-items:center; gap:8px; justify-content:center; }
    .controls{ display:flex; gap:8px; align-items:center; width:100%; }
    .controls select, .controls button, .controls input[type=range]{ height:32px; padding:4px 8px; border-radius:6px; border:1px solid #ccc; background:#fff; }
    .board-inner{ width:100%; display:flex; justify-content:center; }
    .board-holder{ box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff; }
    .debug{ font-family:monospace; font-size:12px; background:#fbfcfd; border:1px solid #eef2f6; padding:6px; border-radius:6px; max-height:80px; overflow:auto; display:none; } /* kept hidden */
    .notif-area{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; width:100%; }
    .notifications { flex: 1 1 260px; min-width:160px; max-width:460px; background:#fff; border:1px solid #eef2f6; padding:8px; border-radius:6px; font-size:13px; color:#333; box-sizing:border-box; max-height:88px; overflow:auto; }
    .notation { flex:1 1 200px; min-width:160px; max-width:999px; background:#fbfdff; border:1px solid #eef2ff; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; white-space:normal; display:flex; flex-wrap:wrap; gap:8px; align-items:center; box-sizing:border-box; min-height:44px; }
    .notation .move { padding:4px 8px; border-radius:6px; background:transparent; }
    .footer-actions{ display:flex; justify-content:flex-end; margin-top:18px; gap:8px; }
    .btn-logout{ background:#ef4444; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .multiplayer-panel { margin-top: 10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-start; }
    @media(max-width:900px){ .boards-grid{ grid-template-columns:1fr; padding:0 12px; } .notif-area{ flex-direction:column; } }
    .status-small { font-size:12px; color:#666; min-width:150px; }
    .notif-item { font-size:12px; padding:4px 6px; border-radius:4px; background:#f7f9fc; margin-bottom:6px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Master Dashboard - IQ 4U Academy</h1>

    <div class="boards-grid" id="boardsGrid"></div>

    <div class="footer-actions">
      <button id="globalLogout" class="btn-logout">Logout</button>
    </div>
  </div>

  <!-- jQuery (required by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- chessboard.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
  (async function(){
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasedestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb693d0736fe0da4bb"
    };
    try{ firebase.initializeApp(FIREBASE_CONFIG); }catch(e){}

    const db = firebase.database();
    const onlineRef = db.ref('online');
    const gamesRef = db.ref('games');

    // MASTER identity will be derived from Firebase Auth when present
    let MASTER_ID = null;
    let MASTER_NAME = localStorage.getItem('username') || localStorage.getItem('email') || 'master';

    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    const STUDENTS = [
      { id: 'student1', name: 'Student 1' },
      { id: 'student2', name: 'Student 2' },
      { id: 'student3', name: 'Student 3' },
      { id: 'student4', name: 'Student 4' }
    ];
    const STUDENT_IDS = STUDENTS.map(s => s.id.toLowerCase());
    const STUDENT_NAMES = STUDENTS.map(s => s.name.toLowerCase());

    const onlineMap = {};   // clientId => {email, role, ts}
    const boardsState = {}; // per-board state

    // track last online count to avoid duplicate "Players online" messages
    let lastOnlineCount = null;

    // ---------- ensure chess.js ----------
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    async function ensureChess(){
      if(typeof Chess !== 'undefined') return;
      try{
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        window.Chess = mod.default || mod.Chess || mod;
      }catch(e){}
      if(typeof Chess !== 'undefined') return;
      await new Promise(resolve=>{
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = true;
        s.onload = ()=> setTimeout(resolve, 10);
        s.onerror = ()=> resolve();
        document.head.appendChild(s);
      });
    }

    async function pickPieceTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const r = await fetch(test, { method:'HEAD', cache:'no-store' }); return r.ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // ---------- build UI ----------
    const grid = document.getElementById('boardsGrid');
    const theme = await pickPieceTheme();
    for(let i=0;i<STUDENTS.length;i++){
      const s = STUDENTS[i];
      const card = createCard(s, theme, i);
      grid.appendChild(card);
    }

    await ensureChess();
    for(const s of STUDENTS) initEngineAndBoard(s.id);

    // ---------- functions (unchanged UI helpers) ----------
    function createCard(student, pieceTheme, index){
      const card = document.createElement('div'); card.className = 'board-card'; card.dataset.studentId = student.id;

      const label = document.createElement('div'); label.className = 'student-label';
      label.innerHTML = `<span class="label-text">${student.name}</span><span class="badge-holder" style="margin-left:10px"></span><span class="path-holder" style="margin-left:8px;font-size:11px;color:#666"></span>`;
      card.appendChild(label);

      const top = document.createElement('div'); top.className = 'top-strip';
      top.innerHTML = `<div class="controls"><span class="label-small" style="margin-right:6px;">Size</span>
        <input id="size-slider-${student.id}" name="size-slider" type="range" min="200" max="800" value="" class="size-slider" data-sid="${student.id}">
        <button class="icon flip-btn" data-sid="${student.id}" title="Flip">Flip</button>
      </div>`;
      card.appendChild(top);

      const boardInnerWrap = document.createElement('div'); boardInnerWrap.className = 'board-inner';
      const boardHolder = document.createElement('div'); boardHolder.className = 'board-holder';
      const boardDiv = document.createElement('div'); boardDiv.id = 'board_' + student.id;
      boardHolder.appendChild(boardDiv); boardInnerWrap.appendChild(boardHolder); card.appendChild(boardInnerWrap);

      const notifArea = document.createElement('div'); notifArea.className = 'notif-area';
      notifArea.innerHTML = `
        <div class="notifications" id="notif_${student.id}"></div>
        <div class="notation" id="notation_${student.id}">No moves.</div>
      `;
      card.appendChild(notifArea);

      const debug = document.createElement('div'); debug.className = 'debug'; debug.id = 'debug_' + student.id; debug.textContent = 'ready'; card.appendChild(debug);

      const multiplayPanel = document.createElement('div');
      multiplayPanel.className = 'multiplayer-panel';
      multiplayPanel.innerHTML = `
        <select id="master-students-${student.id}" name="master-students" style="padding:6px 8px; border-radius:6px; border:1px solid #ccc; min-width:180px;"><option value="">Select student</option></select>
        <button id="master-spectate-${student.id}" name="master-spectate-btn" style="padding:8px 12px; border-radius:6px; background:#0f172a; color:#fff; border:none; cursor:pointer;">Spectate</button>
        <span id="master-status-${student.id}" class="status-small">ready</span>
      `;
      card.appendChild(multiplayPanel);

      const defaultSize = (index < 2) ? 570 : 360;
      boardsState[student.id] = {
        size: defaultSize,
        flip: false,
        watchedClientId: null,
        listeners: {},
        boardObj: null,
        game: null,
        pieceTheme,
        gameMoveListeners: {},
        moveRecords: {},
        processedMoveKeys: new Set(),
        lastNotif: null
      };

      const sizeSlider = top.querySelector('.size-slider');
      sizeSlider.value = defaultSize;
      sizeSlider.addEventListener('input', e => {
        const px = Number(e.target.value);
        boardsState[student.id].size = px;
        setBoardSize(student.id, px);
      });
      top.querySelector('.flip-btn').addEventListener('click', () => {
        const st = boardsState[student.id];
        st.flip = !st.flip;
        if(st.boardObj && typeof st.boardObj.flip === 'function') st.boardObj.flip();
      });

      const masterStudentsSelect = multiplayPanel.querySelector(`#master-students-${student.id}`);
      const masterSpectateBtn = multiplayPanel.querySelector(`#master-spectate-${student.id}`);
      const masterStatus = multiplayPanel.querySelector(`#master-status-${student.id}`);

      masterSpectateBtn.addEventListener('click', () => {
        const selectedStudent = masterStudentsSelect.value;
        if(!selectedStudent){ alert('Select a student'); return; }
        if(!MASTER_ID){ alert('Sign-in required for master to send invites'); return; }
        sendSpectateInvite(student.id, selectedStudent);
        masterStatus.textContent = `Invite sent to ${selectedStudent}`;
        addNotification(student.id, `Invite sent to ${selectedStudent}`);
      });

      return card;
    }

    function initEngineAndBoard(studentId){
      const st = boardsState[studentId];
      if(!st) return;
      try{ st.game = (typeof Chess !== 'undefined') ? new Chess() : null; }catch(e){ st.game = null; console.warn('Chess engine init failed', e); }
      try{
        st.boardObj = Chessboard('board_' + studentId, {
          draggable: false,
          position: st.game && typeof st.game.fen === 'function' ? st.game.fen() : 'start',
          pieceTheme: st.pieceTheme
        });
      }catch(e){ console.error('Chessboard init failed', e); }
      setBoardSize(studentId, st.size);
    }

    function setBoardSize(boardId, px){
      const st = boardsState[boardId];
      if(!st) return;
      const div = document.getElementById('board_' + boardId);
      if(!div) return;
      const holder = div.parentElement;
      if(holder){ holder.style.width = px + 'px'; holder.style.height = px + 'px'; }
      try{ if(st.boardObj && typeof st.boardObj.resize === 'function') st.boardObj.resize(); }catch(e){}
    }

    // ---------- select population (only true online students) ----------
    function isLikelyStudentEntry(email){
      if(!email) return false;
      const e = String(email).toLowerCase().trim();
      return STUDENT_IDS.includes(e) || STUDENT_NAMES.includes(e) || STUDENT_NAMES.some(n => e.indexOf(n) !== -1) || STUDENT_IDS.some(id => e.indexOf(id) !== -1);
    }

    function populateSelectForBoard(boardId){
      const sel = document.querySelector(`#master-students-${boardId}`);
      if(!sel) return;
      const prev = sel.value;
      sel.innerHTML = '';
      const title = document.createElement('option'); title.value=''; title.textContent='Select student'; sel.appendChild(title);

      const now = Date.now();
      const ONLINE_WINDOW_MS = 45_000;
      const onlineIds = Object.keys(onlineMap || {}).filter(id => {
        const entry = onlineMap[id] || {};
        if(!entry.ts || Number(entry.ts) < (now - ONLINE_WINDOW_MS)) return false;
        return (entry.role && String(entry.role).toLowerCase() === 'student') || isLikelyStudentEntry(entry.email);
      });

      if(onlineIds.length === 0){
        const none = document.createElement('option'); none.value=''; none.disabled=true; none.textContent='No online students'; sel.appendChild(none); return;
      }
      onlineIds.forEach(id => {
        const e = onlineMap[id];
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = `${e && e.email ? e.email : id} (${id.slice(0,6)})`;
        sel.appendChild(opt);
      });
      if(prev && Array.from(sel.options).some(o=>o.value===prev)) sel.value = prev;
    }

    function updateMasterStudentsList(boardId){ populateSelectForBoard(boardId); }

    function refreshBadge(boardId){
      const st = boardsState[boardId];
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId);
      if(!card) return;
      const badgeHolder = card.querySelector('.badge-holder');
      const pathHolder = card.querySelector('.path-holder');
      badgeHolder.innerHTML = '';
      pathHolder.textContent = st.watchedClientId ? `moves/${st.watchedClientId}` : '';
      if(!st.watchedClientId) return;
      const span = document.createElement('span');
      span.className = onlineMap[st.watchedClientId] ? 'online-badge' : 'offline-badge';
      span.textContent = onlineMap[st.watchedClientId] ? 'online' : 'offline';
      badgeHolder.appendChild(span);
    }

    // ---------- notifications ----------
    function addNotification(boardId, msg){
      const el = document.getElementById('notif_' + boardId);
      if(!el) return;
      const st = boardsState[boardId];
      if(st && st.lastNotif === msg) return;
      st.lastNotif = msg;
      const item = document.createElement('div');
      item.className = 'notif-item';
      item.textContent = `${new Date().toLocaleTimeString()} â€” ${msg}`;
      el.insertBefore(item, el.firstChild);
      while(el.children.length > 10) el.removeChild(el.lastChild);
      setTimeout(() => {
        try{
          if(item && item.parentElement) item.parentElement.removeChild(item);
          if(st && st.lastNotif === msg) st.lastNotif = null;
        }catch(e){}
      }, 10000);
    }

    // ---------- spectate invite flow ----------
    function sendSpectateInvite(boardId, clientId){
      if(!clientId) return;
      if(!MASTER_ID) return addNotification(boardId, 'Sign in required to send invite');
      try{
        const inviteRef = db.ref(`spectateInvites/${clientId}/${MASTER_ID}`);
        const payload = { type:'spectate', fromId:MASTER_ID, fromEmail:MASTER_NAME, boardId:boardId||null, ts: firebase.database.ServerValue.TIMESTAMP };
        inviteRef.set(payload).then(()=> addNotification(boardId, `Invite sent to ${clientId}`)).catch(err=> addNotification(boardId, `Invite send failed: ${err && err.message}`));
        setTimeout(()=> inviteRef.remove().catch(()=>{}), 60000);
      }catch(e){ addNotification(boardId, 'Invite send error'); }
    }

    // Listen for responses (spectateResponses/<MASTER_ID>) -> show accepted/declined notifications and start watching when accepted
    function listenForSpectateResponsesForMaster(masterUid){
      if(!masterUid) return;
      const respRef = db.ref(`spectateResponses/${masterUid}`);
      respRef.on('child_added', snap => {
        const resp = snap.val();
        if(!resp) return;
        const studentId = resp.studentId || resp.fromId || snap.key;
        const accepted = !!resp.accepted;
        const boardId = resp.boardId || null;
        const targetBoard = boardId || findBoardForStudentId(studentId) || STUDENTS[0].id;
        if(accepted){
          addNotification(targetBoard, `Invite accepted by ${studentId}`);
          boardsState[targetBoard].watchedClientId = studentId;
          refreshBadge(targetBoard);
          const sel = document.querySelector(`#master-students-${targetBoard}`);
          if(sel && !Array.from(sel.options).some(o => o.value === studentId)){
            const opt = document.createElement('option');
            opt.value = studentId;
            opt.textContent = `${onlineMap[studentId] ? onlineMap[studentId].email : studentId} (${studentId.slice(0,6)})`;
            sel.appendChild(opt);
          }
          if(sel) sel.value = studentId;
          // clear previous moveRecords for this board
          boardsState[targetBoard].moveRecords = {};
          boardsState[targetBoard].processedMoveKeys = new Set();
          startWatching(targetBoard, studentId);
        } else {
          addNotification(targetBoard, `Invite declined by ${studentId}`);
        }
        snap.ref.remove().catch(()=>{});
      });
      function findBoardForStudentId(id){ for(const s of STUDENTS) if(s.id === id) return s.id; return null; }
    }

    // ---------- watching & replay (same logic as previously) ----------
    const CANDIDATE_PATHS = ['','game','move','moves'];
    function startWatching(boardId, clientId){
      const st = boardsState[boardId];
      if(!st) return;
      stopWatching(boardId, {clearRecords:false});
      st.watchedClientId = clientId;
      refreshBadge(boardId);
      addNotification(boardId, `Start watching ${clientId}`);
      st.listeners = {};
      CANDIDATE_PATHS.forEach(p => {
        const path = p ? `games/${clientId}/${p}` : `games/${clientId}`;
        const ref = db.ref(path);
        const onValue = snap => { const v = snap.val(); if(!v) return; ingestPayload(boardId, snap.key || path, v); };
        ref.on('value', onValue, err => addNotification(boardId, `Listener error @ ${path}: ${err && err.message}`));
        const onChildAdded = snap => { const v = snap.val(); const key = snap.key || (path + '/' + Math.random().toString(36).slice(2,6)); ingestPayloadWithMeta(boardId, key, v); };
        ref.on('child_added', onChildAdded, err=>{});
        st.listeners[path] = { ref, handlers:{ value:onValue, child_added:onChildAdded } };
      });

      try{
        const movesPath = `moves/${clientId}`;
        const movesRef = db.ref(movesPath);
        const onMoveAdded = snap => { const key = snap.key; const v = snap.val(); ingestPayloadWithMeta(boardId, key, v); };
        movesRef.on('child_added', onMoveAdded, err=>{});
        st.listeners[movesPath] = { ref: movesRef, handlers:{ child_added:onMoveAdded } };
      }catch(e){ addNotification(boardId, 'Moves listener failed'); }

      attachGameMoveListenersForStudent(clientId, boardId);
      const onGameChildAdded = snap => { const data = snap.val(); if(!data) return; const id = snap.key; const involved = (data.white === clientId)||(data.black === clientId); if(involved) attachMovesListenerForGame(id, boardId); };
      gamesRef.on('child_added', onGameChildAdded);
      st.listeners[`games_root_child_added_for_${clientId}`] = { ref: gamesRef, handlers:{ child_added:onGameChildAdded } };
    }

    function attachGameMoveListenersForStudent(clientId, boardId){
      const st = boardsState[boardId];
      try{
        const attachIfNot = (gameId) => { if(!gameId) return; if(st.gameMoveListeners && st.gameMoveListeners[`moves/${gameId}`]) return; attachMovesListenerForGame(gameId, boardId); };
        gamesRef.orderByChild('white').equalTo(clientId).once('value').then(snap => { snap.forEach(child => attachIfNot(child.key)); }).catch(()=>{});
        gamesRef.orderByChild('black').equalTo(clientId).once('value').then(snap => { snap.forEach(child => attachIfNot(child.key)); }).catch(()=>{});
      }catch(e){}
    }

    function attachMovesListenerForGame(gameId, boardId){
      if(!gameId) return;
      const st = boardsState[boardId];
      if(!st) return;
      const path = `moves/${gameId}`;
      if(st.gameMoveListeners && st.gameMoveListeners[path]) return;
      const ref = db.ref(path);
      const onChildAdded = snap => { const key = snap.key; const v = snap.val(); ingestPayloadWithMeta(boardId, key, v); };
      ref.on('child_added', onChildAdded, err=>{});
      st.gameMoveListeners[path] = { ref, handlers:{ child_added:onChildAdded } };
      addNotification(boardId, `Attached to game moves/${gameId}`);
    }

    function stopWatching(boardId, opts){
      const st = boardsState[boardId];
      if(!st) return;
      opts = opts || {};
      try{
        Object.keys(st.listeners || {}).forEach(path => {
          const L = st.listeners[path];
          if(L && L.ref && L.handlers){
            if(L.handlers.value) L.ref.off('value', L.handlers.value);
            if(L.handlers.child_added) L.ref.off('child_added', L.handlers.child_added);
            if(L.handlers.child_changed) L.ref.off('child_changed', L.handlers.child_changed);
          }
        });
      }catch(e){}
      try{
        Object.keys(st.gameMoveListeners || {}).forEach(path => {
          const L = st.gameMoveListeners[path];
          if(L && L.ref && L.handlers){
            if(L.handlers.child_added) L.ref.off('child_added', L.handlers.child_added);
          }
        });
      }catch(e){}
      st.listeners = {};
      st.gameMoveListeners = {};
      st.watchedClientId = null;
      refreshBadge(boardId);
      addNotification(boardId, 'Stopped watching');
      clearNotation(boardId);
      if(opts.clearRecords){
        st.moveRecords = {};
        st.processedMoveKeys = new Set();
      }
    }

    // ---------- ingestion + replay ----------
    function ingestPayloadWithMeta(boardId, key, value){
      const payload = (value && value.payload) ? value.payload : value;
      const ts = value && (value.ts || (value.payload && value.payload.ts)) ? (value.ts || (value.payload && value.payload.ts)) : Date.now();
      const st = boardsState[boardId];
      if(!st) return;
      st.moveRecords[key] = { payload, ts: Number(ts) || Date.now() };
      replayMoveRecords(boardId);
    }

    function ingestPayload(boardId, key, value){
      if(!value) return;
      const st = boardsState[boardId];
      if(!st) return;
      if(typeof value === 'object' && !Array.isArray(value)){
        if(value.moves && typeof value.moves === 'object'){
          Object.keys(value.moves).forEach(k => ingestPayloadWithMeta(boardId, k, value.moves[k]));
          return;
        }
        const syntheticKey = key || ('snap_'+Math.random().toString(36).slice(2,8));
        ingestPayloadWithMeta(boardId, syntheticKey, value);
      } else {
        const syntheticKey = key || ('snap_'+Math.random().toString(36).slice(2,8));
        ingestPayloadWithMeta(boardId, syntheticKey, { fen: value, ts: Date.now() });
      }
    }

    function replayMoveRecords(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      try{
        const entries = Object.keys(st.moveRecords).map(k => ({ key:k, ts: st.moveRecords[k].ts || 0, payload: st.moveRecords[k].payload }));
        entries.sort((a,b) => (a.ts - b.ts) || (a.key < b.key ? -1 : (a.key > b.key ? 1 : 0)));
        try{ st.game = (typeof Chess !== 'undefined') ? new Chess() : st.game; }catch(e){}
        st.processedMoveKeys = new Set();
        for(const e of entries){
          const mv = e.payload && (e.payload.move || e.payload);
          if(e.payload && e.payload.fen && (!mv || (typeof mv === 'object' && !mv.from && !mv.to))){
            try{ if(st.game && typeof st.game.load === 'function') st.game.load(e.payload.fen); }catch(_){}
            st.processedMoveKeys.add(e.key);
            continue;
          }
          if(mv){
            if(typeof mv === 'string'){
              const s = mv.replace(/[^a-h1-8qnbrk]/ig,'');
              if(s.length >= 4){
                const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : undefined;
                try{ st.game.move({ from, to, promotion: prom || undefined }); st.processedMoveKeys.add(e.key); }catch(_){}
                continue;
              }
            } else if(typeof mv === 'object'){
              const from = mv.from || mv.f || (mv.u && mv.u.slice && mv.u.slice(0,2));
              const to = mv.to || mv.t || (mv.u && mv.u.slice && mv.u.slice(2,4));
              const promotion = mv.promotion || mv.prom || null;
              if(from && to && typeof st.game.move === 'function'){
                try{ const applied = st.game.move({ from, to, promotion: promotion || undefined }); if(applied) st.processedMoveKeys.add(e.key); }catch(_){}
                continue;
              }
            }
          }
        }
        const pos = st.game && typeof st.game.fen === 'function' ? st.game.fen() : null;
        if(pos && st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(pos);
        updateNotation(boardId);
      }catch(e){ addNotification(boardId, 'Replay error: ' + (e && e.message)); }
    }

    function updateNotation(boardId){
      const st = boardsState[boardId];
      const notEl = document.getElementById('notation_' + boardId);
      if(!st || !notEl) return;
      try{
        if(!st.game || typeof st.game.history !== 'function'){ notEl.innerHTML = 'No moves.'; return; }
        const hist = st.game.history() || [];
        if(hist.length === 0){ notEl.innerHTML = 'No moves.'; return; }
        notEl.innerHTML = '';
        for(let i=0;i<hist.length;i+=2){
          const no = Math.floor(i/2)+1;
          const w = hist[i]||'';
          const b = hist[i+1]||'';
          const div = document.createElement('div');
          div.className = 'move';
          div.innerHTML = `<strong>${no}.</strong>&nbsp;${w}${ b ? ('\u00A0' + b) : '' }`;
          notEl.appendChild(div);
        }
      }catch(e){ console.warn('updateNotation error', e); }
    }
    function clearNotation(boardId){ const notEl = document.getElementById('notation_' + boardId); if(notEl) notEl.innerHTML = 'No moves.'; }

    // ---------- presence & listeners (attach after auth) ----------
    function attachPresenceAndListenersForMaster(uid, displayName, email){
      if(!uid) return;
      MASTER_ID = uid;
      MASTER_NAME = displayName || localStorage.getItem('username') || localStorage.getItem('email') || email || 'master';

      // publish master presence under /online/<uid> with required shape
      try{
        const n = onlineRef.child(MASTER_ID);
        const payload = { name: MASTER_NAME, email: email || '', role: 'master', ts: firebase.database.ServerValue.TIMESTAMP };
        n.set(payload).catch(()=>{});
        // remove on disconnect
        try{ n.onDisconnect().remove(); }catch(e){}
        // refresh timestamp periodically
        setInterval(()=> n.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
      }catch(e){}

      // online list watcher (only valid while authenticated)
      onlineRef.on('value', snap => {
        const val = snap.val() || {};
        for(const k in onlineMap) delete onlineMap[k];
        let countRecent = 0;
        const now = Date.now();
        const ONLINE_WINDOW_MS = 45_000;
        for(const id in val){
          if(!val.hasOwnProperty(id)) continue;
          const rec = val[id] || {};
          const ts = rec.ts || 0;
          onlineMap[id] = { email: rec.email || id, role: rec.role || null, ts };
          if(Number(ts) > (now - ONLINE_WINDOW_MS)) countRecent++;
        }

        if(lastOnlineCount === null || lastOnlineCount !== countRecent){
          lastOnlineCount = countRecent;
          STUDENTS.forEach(s => addNotification(s.id, `Players online: ${countRecent}`));
        }

        STUDENTS.forEach(s => populateSelectForBoard(s.id));
        STUDENTS.forEach(s => updateMasterStudentsList(s.id));
        STUDENTS.forEach(s => refreshBadge(s.id));
      });

      // spectateResponses listener for master
      listenForSpectateResponsesForMaster(MASTER_ID);
    }

    // ---------- start watching / moves logic (reused above) ----------
    // (startWatching, attachGameMoveListenersForStudent, attachMovesListenerForGame, stopWatching,
    //  ingestPayloadWithMeta, ingestPayload, replayMoveRecords, updateNotation already defined)

    // ---------- AUTH boot: require master to sign in ----------
    // If your master account is a service account or a special auth user, you must sign-in on this page.
    // For simplicity, we expect you to sign in previously or use other auth flows. We will detect auth state.
    firebase.auth().onAuthStateChanged(user => {
      if(user){
        // user is authenticated - use real UID
        const uid = user.uid;
        const displayName = user.displayName || null;
        const email = user.email || '';
        console.log('Master signed in as', uid, email);
        attachPresenceAndListenersForMaster(uid, displayName, email);
      } else {
        // not signed in. Show status and keep UI active but restrict invites
        // Optionally you can redirect to index.html to sign in
        console.warn('No auth user for master page. Master features disabled until sign-in.');
        // If you want to automatically sign the master in using a saved token or custom flow,
        // implement sign-in here (omitted for security).
      }
    });

    // ---------- utilities ----------
    function getDebugElem(boardId){ return document.getElementById('debug_' + boardId); }

    document.getElementById('globalLogout').addEventListener('click', async () => {
      try{ localStorage.removeItem('role'); localStorage.removeItem('username'); localStorage.removeItem('email'); }catch(e){}
      try{ if(MASTER_ID) onlineRef.child(MASTER_ID).remove().catch(()=>{}); }catch(e){}
      // sign out if auth available
      if(firebase.auth){
        try{ await firebase.auth().signOut(); }catch(e){}
      }
      // clear local session storage id
      try{ sessionStorage.removeItem('iq4u_clientId'); }catch(e){}
      window.location.href = 'index.html';
    });

    window.addEventListener('beforeunload', () => {
      try{ if(MASTER_ID) onlineRef.child(MASTER_ID).remove().catch(()=>{}); }catch(e){}
      STUDENTS.forEach(s => stopWatching(s.id, { clearRecords:true }));
    });

  })();
  </script>
</body>
</html>
