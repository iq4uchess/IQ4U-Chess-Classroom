<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Master Dashboard - IQ 4U Academy</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    :root{ --card-gap:12px; --card-bg:#fff; --card-border:#ddd; --control-height:44px; font-family:Arial,Helvetica,sans-serif; color:#222;}
    html,body{ height:100%; margin:0; background:#f5f7fb; }
    .container{ margin:16px auto; max-width:1200px; padding-bottom:28px; }
    h1{ margin:0 0 12px 0; font-size:20px; }
    .boards-grid{ display:grid; grid-template-columns:1fr 1fr; gap:var(--card-gap); }
    .board-card{ background:var(--card-bg); border:1px solid var(--card-border); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:10px; min-height:260px; box-shadow:0 1px 3px rgba(20,30,40,0.05); }
    .top-strip{ display:flex; align-items:center; justify-content:flex-start; gap:8px; height:var(--control-height); }
    .student-label{ font-weight:600; text-align:center; display:flex; align-items:center; gap:8px; justify-content:center; }
    .controls{ display:flex; gap:8px; align-items:center; width:100%; }
    .controls select, .controls button, .controls input[type=range]{ height:32px; padding:4px 8px; border-radius:6px; border:1px solid #ccc; background:#fff; }
    .board-inner{ width:100%; display:flex; justify-content:center; }
    .board-holder{ box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff; position: relative; }
    
    /* Arrow overlay */
    .arrow-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    
    .notif-area{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; width:100%; }
    .notifications { flex: 1 1 260px; min-width:160px; max-width:460px; background:#fff; border:1px solid #eef2f6; padding:8px; border-radius:6px; font-size:13px; color:#333; box-sizing:border-box; max-height:88px; overflow:auto; }
    .notation { flex:1 1 200px; min-width:160px; max-width:999px; background:#fbfdff; border:1px solid #eef2ff; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; white-space:normal; display:flex; flex-wrap:wrap; gap:8px; align-items:center; box-sizing:border-box; min-height:44px; }
    .notation .move { padding:4px 8px; border-radius:6px; background:transparent; }
    .footer-actions{ display:flex; justify-content:flex-end; margin-top:18px; gap:8px; }
    .btn-logout{ background:#ef4444; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    
    /* Engine controls styling - Lichess Style */
    .engine-panel { 
      margin-top: 10px; 
      display:flex; 
      gap:8px; 
      align-items:center; 
      flex-wrap:wrap; 
      justify-content:flex-start; 
      padding:8px; 
      background:#f8f9fa; 
      border-radius:6px; 
      border:1px solid #eef2f6; 
    }
    .engine-toggle { 
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .toggle-slider {
      background-color: #3b82f6;
    }
    input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    .engine-label {
      font-size: 12px;
      font-weight: 600;
      color: #333;
    }
    
    /* Engine status */
    .engine-status {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      background: #fff;
      border: 1px solid #eef2f6;
      min-width: 120px;
    }
    .status-analyzing {
      color: #3b82f6;
    }
    .status-ready {
      color: #10b981;
    }
    .status-idle {
      color: #6b7280;
    }
    
    /* Depth controls */
    .depth-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    .depth-slider {
      width: 80px;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #e5e7eb;
      border-radius: 3px;
      outline: none;
    }
    .depth-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3b82f6;
      cursor: pointer;
    }
    .depth-value {
      font-weight: 600;
      color: #3b82f6;
      min-width: 20px;
      text-align: center;
    }
    
    /* Best move display - Lichess Style */
    .best-move-container {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: #f0f9ff;
      border-radius: 6px;
      border: 1px solid #e0f2fe;
    }
    .best-move-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
    }
    .best-move-value {
      font-family: monospace;
      font-weight: bold;
      font-size: 14px;
      color: #065f46;
      background: #d1fae5;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #10b981;
    }
    
    /* Top moves strip - Lichess Style */
    .best-moves-strip {
      margin-top: 8px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #eef2f6;
      display: none;
    }
    .best-moves-strip.active {
      display: block;
    }
    .best-moves-header {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .best-moves-container {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .best-move-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .best-move-number {
      font-size: 11px;
      color: #666;
      font-weight: 600;
    }
    .best-move-san {
      font-family: monospace;
      font-weight: 600;
      padding: 4px 8px;
      background: white;
      border-radius: 4px;
      border: 1px solid #e5e7eb;
      font-size: 13px;
      min-width: 50px;
      text-align: center;
      transition: all 0.2s;
    }
    .best-move-item.main .best-move-san {
      background: #d1fae5;
      border-color: #10b981;
      color: #065f46;
      font-weight: bold;
      transform: scale(1.05);
    }
    
    /* Lichess-style evaluation bar */
    .eval-bar {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 14px;
      background: #f3f4f6;
      z-index: 5;
    }
    .eval-bar-fill {
      position: absolute;
      left: 0;
      right: 0;
      background: #3b82f6;
      transition: height 0.3s;
    }
    .eval-bar-text {
      position: absolute;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 10px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3);
      padding: 2px 0;
      z-index: 6;
    }
    
    /* Multiplayer panel */
    .multiplayer-panel { margin-top: 10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-start; }
    .status-small { font-size:12px; color:#666; min-width:150px; }
    .notif-item { font-size:12px; padding:4px 6px; border-radius:4px; background:#f7f9fc; margin-bottom:6px; }
    
    /* Connection status */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1000;
      background: #d1fae5;
      border: 1px solid #10b981;
      color: #065f46;
    }
    .connection-status.disconnected {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }
    
    /* Stockfish loading */
    .stockfish-loading {
      font-size: 11px;
      color: #6b7280;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .loading-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid #e5e7eb;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @media(max-width:900px){ 
      .boards-grid{ grid-template-columns:1fr; padding:0 12px; } 
      .notif-area{ flex-direction:column; }
      .best-moves-container {
        gap: 8px;
      }
      .engine-panel {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <!-- Connection Status Indicator -->
  <div id="connectionStatus" class="connection-status">✅ Connected</div>

  <div class="container">
    <h1>Master Dashboard - IQ 4U Academy</h1>

    <div class="boards-grid" id="boardsGrid"></div>

    <div class="footer-actions">
      <button id="globalLogout" class="btn-logout">Logout</button>
    </div>
  </div>

  <!-- jQuery (required by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- chessboard.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
  (async function(){
    // ---------- CONFIG ----------
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb6936fe0da4bb"
    };
    
    try{ 
      firebase.initializeApp(FIREBASE_CONFIG); 
      console.log('✅ Firebase initialized');
    } catch(e){ 
      console.error('❌ Firebase init failed:', e);
    }
    
    const db = firebase.database();
    const onlineRef = db.ref('online');

    const MASTER_ID = sessionStorage.getItem('iq4u_clientId') || ('m_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', MASTER_ID);
    const MASTER_NAME = localStorage.getItem('username') || localStorage.getItem('email') || 'master';

    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    // Stockfish paths
    const STOCKFISH_JS = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/stockfish/stockfish-17.1-lite-single-03e3232.js';

    const STUDENTS = [
      { id: 'student1', name: 'Student 1' },
      { id: 'student2', name: 'Student 2' },
      { id: 'student3', name: 'Student 3' },
      { id: 'student4', name: 'Student 4' }
    ];

    const onlineMap = {};   // clientId => {email, role, ts}
    const boardsState = {}; // per-board state

    // ---------- ensure chess.js loaded ----------
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    async function ensureChess(){
      if(typeof Chess !== 'undefined') return;
      try{
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        window.Chess = mod.default || mod.Chess || mod;
      }catch(e){}
      if(typeof Chess !== 'undefined') return;
      await new Promise(resolve=>{
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = true;
        s.onload = ()=> setTimeout(resolve, 10);
        s.onerror = ()=> resolve();
        document.head.appendChild(s);
      });
    }

    async function pickPieceTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const r = await fetch(test, { method:'HEAD', cache:'no-store' }); return r.ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // ---------- build UI (DOM only) ----------
    const grid = document.getElementById('boardsGrid');
    const theme = await pickPieceTheme();
    for(let i=0;i<STUDENTS.length;i++){
      const s = STUDENTS[i];
      const card = createCard(s, theme, i);
      grid.appendChild(card);
    }

    // wait and then initialize chessboards
    await ensureChess();
    for(const s of STUDENTS){
      initBoard(s.id);
    }

    // ---------- SINGLE AUTHORITATIVE PIPELINE ----------
    const CANDIDATE_PATHS = ['','game','move','moves'];

    function startWatching(boardId, clientId){
      const st = boardsState[boardId];
      if(!st) return;
      stopWatching(boardId); // teardown previous
      st.watchedClientId = clientId;
      
      // Update UI
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(sel) sel.value = clientId;
      refreshBadge(boardId);
      addNotification(boardId, `Watching ${clientId}`);
      
      // Reset game state
      try{ st.game = new Chess(); } catch(e){ st.game = null; }
      if(st.boardObj) st.boardObj.position('start');
      updateNotation(boardId);
      clearArrow(boardId);
      hideBestMoves(boardId);
      updateEvalBar(boardId, 0);

      // Attach listeners for each candidate path
      st.listeners = {};
      CANDIDATE_PATHS.forEach(p => {
        const path = p ? `games/${clientId}/${p}` : `games/${clientId}`;
        const ref = db.ref(path);
        
        // value listener
        const onValue = snap => {
          const v = snap.val();
          if(!v) return;
          normalizeAndApply(boardId, v);
        };
        ref.on('value', onValue);

        // child_added for move streams
        const onChildAdded = snap => {
          const v = snap.val();
          if(p === 'moves' || typeof v === 'object'){
            const candidate = v && (v.payload || v);
            if(candidate && (candidate.move || candidate.fen || candidate.from)){
              normalizeAndApply(boardId, v);
            } else {
              // Fetch all moves in order
              ref.limitToLast(500).once('value').then(snap2 => {
                const ordered = {};
                snap2.forEach(child => ordered[child.key] = child.val());
                normalizeAndApply(boardId, { moves: ordered });
              }).catch(()=>{});
            }
          } else {
            normalizeAndApply(boardId, v);
          }
        };
        ref.on('child_added', onChildAdded);

        // child_changed - apply updates
        const onChildChanged = snap => {
          normalizeAndApply(boardId, snap.val());
        };
        ref.on('child_changed', onChildChanged);

        // save for teardown
        st.listeners[path] = { ref, handlers: { value: onValue, child_added: onChildAdded, child_changed: onChildChanged } };
      });

      // Also listen to moves/{clientId} for real-time move syncing
      try{
        const movesPath = `moves/${clientId}`;
        const movesRef = db.ref(movesPath);
        const onMoveAdded = snap => {
          const m = snap.val();
          if(!m) return;
          if(m.by === MASTER_ID) return;
          const candidate = m.payload || m;
          if(candidate && (candidate.move || candidate.fen)){
            normalizeAndApply(boardId, candidate);
          }
        };
        movesRef.on('child_added', onMoveAdded);
        st.listeners[movesPath] = { ref: movesRef, handlers: { child_added: onMoveAdded } };
      }catch(e){ console.error('Moves listener failed:', e); }

      // initial one-shot fetch
      try{
        const movesRef = db.ref(`games/${clientId}/moves`);
        movesRef.limitToLast(500).once('value').then(snap => {
          if(!snap.exists()) return;
          const ordered = {};
          snap.forEach(child => ordered[child.key] = child.val());
          normalizeAndApply(boardId, { moves: ordered });
        }).catch(()=>{});
      }catch(e){}

      // Start engine if not running
      if(!st.engineRunning) {
        setTimeout(() => toggleEngine(boardId), 1000);
      }
    }

    function stopWatching(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      
      // Stop engine
      if(st.engineRunning) {
        if (st.analysisTimeout) {
          clearTimeout(st.analysisTimeout);
          st.analysisTimeout = null;
        }
        if (st.engineWorker) {
          try {
            st.engineWorker.postMessage('quit');
            setTimeout(() => st.engineWorker.terminate(), 100);
          } catch(e) {}
          st.engineWorker = null;
        }
        st.engineRunning = false;
        updateEngineStatus(boardId, 'Idle');
        clearArrow(boardId);
        hideBestMoves(boardId);
        updateEvalBar(boardId, 0);
      }
      
      // Clean up Firebase listeners
      try{
        Object.keys(st.listeners || {}).forEach(path => {
          const L = st.listeners[path];
          if(L && L.ref && L.handlers){
            if(L.handlers.value) L.ref.off('value', L.handlers.value);
            if(L.handlers.child_added) L.ref.off('child_added', L.handlers.child_added);
            if(L.handlers.child_changed) L.ref.off('child_changed', L.handlers.child_changed);
          }
        });
      }catch(e){}
      
      st.listeners = {};
      st.watchedClientId = null;
      refreshBadge(boardId);
      addNotification(boardId, 'Stopped watching');
      clearNotation(boardId);
      hideBestMoves(boardId);
      updateEvalBar(boardId, 0);
      
      // Reset board
      try{ 
        if(st.game && typeof st.game.load === 'function'){ 
          st.game.load('start'); 
        }
        if(st.boardObj && typeof st.boardObj.position === 'function') {
          st.boardObj.position('start'); 
        }
      }catch(e){}
    }

    // ---------- NORMALIZE AND APPLY ----------
    function normalizeAndApply(boardId, record){
      const st = boardsState[boardId];
      if(!st) return;
      try{
        if(record === null || typeof record === 'undefined'){ return; }
        if(typeof record === 'string'){ applyFenToBoard(boardId, record); return; }
        if(record.payload && typeof record.payload === 'object') record = record.payload;

        if(record.moves && typeof record.moves === 'object' && Object.keys(record.moves).length > 0){
          applyMovesChildList(boardId, record.moves);
          return;
        }

        const fenCandidates = ['fen','FEN','sfen','currentFen','position','board_fen','board'];
        for(const k of fenCandidates){ 
          if(record[k] && typeof record[k] === 'string'){ 
            applyFenToBoard(boardId, record[k]); 
            return; 
          } 
        }

        if(record.move){ 
          tryApplyMoveShape(boardId, record.move, record.fen || null); 
          return; 
        }

        const directMoveFields = ['lastMove','last_move','last','moveString','move_uci','uci','from','to'];
        for(const k of directMoveFields){ 
          if(record[k]){ 
            tryApplyMoveShape(boardId, record, record.fen || null); 
            return; 
          } 
        }

        const keys = Object.keys(record || {});
        for(let i = keys.length - 1; i >= 0; i--){
          const cand = record[keys[i]];
          if(cand && (cand.payload || cand.fen || cand.move || typeof cand === 'string')){ 
            normalizeAndApply(boardId, cand); 
            return; 
          }
        }
      }catch(e){ 
        console.error('Normalize error:', e);
      }
    }

    function applyMovesChildList(boardId, movesObj){
      const st = boardsState[boardId];
      if(!st) return;
      try{
        const entries = Object.keys(movesObj).map(k => {
          const rec = movesObj[k] || {};
          const payload = rec.payload || rec;
          const ts = rec.ts || (payload && payload.ts) || 0;
          return { key: k, ts: Number(ts) || 0, payload, raw: rec };
        });
        entries.sort((a,b) => (a.ts - b.ts) || (a.key < b.key ? -1 : (a.key > b.key ? 1 : 0)));
        
        try{ 
          st.game = new Chess(); 
        }catch(e){ 
          st.game = null; 
          return; 
        }
        
        for(const e of entries){
          const mv = (e.payload && e.payload.move) || e.payload;
          if(!mv) continue;
          
          if(typeof mv === 'string'){
            const s = mv.replace(/[^a-h1-8qnbrk]/ig,'');
            if(s.length >= 4){
              const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : undefined;
              if(st.game && typeof st.game.move === 'function') {
                try {
                  st.game.move({ from, to, promotion: prom || undefined });
                } catch(e) {}
              }
            }
          } else if(typeof mv === 'object' && mv.from && mv.to){
            if(st.game && typeof st.game.move === 'function') {
              try {
                st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
              } catch(e) {}
            }
          }
        }
        
        const pos = st.game && typeof st.game.fen === 'function' ? st.game.fen() : null;
        if(pos && st.boardObj && typeof st.boardObj.position === 'function'){
          st.boardObj.position(pos);
        }
        
        updateNotation(boardId);
        
        // Trigger engine analysis if running
        if(st.engineRunning) {
          setTimeout(() => analyzePosition(boardId), 300);
        }
      }catch(e){ 
        console.error('Apply moves error:', e);
      }
    }

    function tryApplyMoveShape(boardId, m, fallbackFen){
      const st = boardsState[boardId];
      if(!st) return false;
      try{
        if(!m) return false;
        if(typeof m === 'string'){
          const s = m.replace(/[^a-h1-8qnbrk]/ig,'');
          if(s.length >= 4){ 
            const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : null; 
            applyMoveToBoard(boardId, { from, to, promotion: prom }, fallbackFen); 
            return true; 
          }
          const m2 = m.match(/([a-h][1-8]).*?([a-h][1-8])/i);
          if(m2){ 
            applyMoveToBoard(boardId, { from: m2[1], to: m2[2] }, fallbackFen); 
            return true; 
          }
          return false;
        }
        if(typeof m === 'object'){
          const from = m.from || m.f || (m.u && m.u.slice(0,2));
          const to = m.to || m.t || (m.u && m.u.slice(2,4));
          const promotion = m.promotion || m.prom || null;
          if(from && to){ 
            applyMoveToBoard(boardId, { from, to, promotion }, fallbackFen); 
            return true; 
          }
          if(m.payload) return tryApplyMoveShape(boardId, m.payload, fallbackFen);
        }
        return false;
      }catch(e){ 
        console.error('Apply move shape error:', e);
        return false; 
      }
    }

    function applyFenToBoard(boardId, fen){
      const st = boardsState[boardId];
      if(!st || !fen) return;
      try{
        if(st.game && typeof st.game.load === 'function'){ 
          st.game.load(fen); 
          if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen()); 
          updateNotation(boardId);
          
          // Trigger engine analysis if running
          if(st.engineRunning) {
            setTimeout(() => analyzePosition(boardId), 300);
          }
        }
        else if(st.boardObj && typeof st.boardObj.position === 'function'){ 
          st.boardObj.position(fen); 
        }
      }catch(e){ 
        console.error('Apply FEN error:', e);
      }
    }

    function applyMoveToBoard(boardId, mv, fallbackFen){
      const st = boardsState[boardId];
      if(!st || !mv || !mv.from || !mv.to) return;
      try{
        if(st.game && typeof st.game.move === 'function'){
          const applied = st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
          if(applied === null){
            if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
            return;
          } else {
            if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen());
            updateNotation(boardId);
            
            // Trigger engine analysis if running
            if(st.engineRunning) {
              setTimeout(() => analyzePosition(boardId), 300);
            }
          }
        } else {
          if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
        }
      }catch(e){ 
        console.error('Apply move error:', e);
      }
    }

    // ---------- STOCKFISH ENGINE INTEGRATION (Lichess Style) ----------
    async function initStockfish(boardId) {
      const st = boardsState[boardId];
      if (!st) return false;
      
      // Clean up existing worker
      if (st.engineWorker) {
        try {
          st.engineWorker.postMessage('quit');
          setTimeout(() => st.engineWorker.terminate(), 100);
        } catch(e) {}
        st.engineWorker = null;
      }
      
      try {
        // Create Stockfish worker
        const worker = new Worker(STOCKFISH_JS);
        st.engineWorker = worker;
        st.engineReady = false;
        st.bestMoves = [];
        st.currentEval = 0;
        st.depthReached = 0;
        
        worker.onmessage = function(event) {
          const line = event.data;
          
          // Handle engine initialization
          if (line === 'uciok') {
            st.engineReady = true;
            worker.postMessage('setoption name MultiPV value 6');
            worker.postMessage('setoption name UCI_AnalyseMode value true');
            worker.postMessage('isready');
          } else if (line === 'readyok') {
            updateEngineStatus(boardId, 'Ready');
            if (st.pendingAnalysis) {
              analyzePosition(boardId);
              st.pendingAnalysis = false;
            }
          } 
          // Parse analysis results
          else if (line.startsWith('info')) {
            parseStockfishInfo(boardId, line);
          }
          // Parse best move
          else if (line.startsWith('bestmove')) {
            parseBestMove(boardId, line);
          }
        };
        
        worker.onerror = function(error) {
          console.error(`Stockfish error for board ${boardId}:`, error);
          updateEngineStatus(boardId, 'Error');
          // Try to restart engine
          setTimeout(() => {
            if (st.engineRunning) {
              initStockfish(boardId);
            }
          }, 2000);
        };
        
        // Initialize engine
        worker.postMessage('uci');
        updateEngineStatus(boardId, 'Loading...');
        return true;
      } catch (error) {
        console.error('Failed to init Stockfish:', error);
        updateEngineStatus(boardId, 'Failed');
        return false;
      }
    }

    function parseStockfishInfo(boardId, line) {
      const st = boardsState[boardId];
      if (!st) return;
      
      // Extract depth
      const depthMatch = line.match(/depth\s+(\d+)/);
      if (depthMatch) {
        const depth = parseInt(depthMatch[1]);
        st.depthReached = Math.max(st.depthReached, depth);
        const progressEl = document.getElementById(`depth-value-${boardId}`);
        if (progressEl) {
          progressEl.textContent = depth;
        }
      }
      
      // Extract evaluation
      const evalMatch = line.match(/score\s+cp\s+(-?\d+)/);
      if (evalMatch) {
        const cpScore = parseInt(evalMatch[1]);
        st.currentEval = cpScore / 100;
        updateEvalBar(boardId, st.currentEval);
      }
      
      // Check for mate score
      const mateMatch = line.match(/score\s+mate\s+(-?\d+)/);
      if (mateMatch) {
        const mateIn = parseInt(mateMatch[1]);
        st.currentEval = mateIn > 0 ? `M${mateIn}` : `M${-mateIn}`;
        updateEvalBar(boardId, mateIn > 0 ? 100 : -100);
      }
      
      // Parse top moves when MultiPV is present
      const pvMatch = line.match(/multipv\s+(\d+)/);
      if (pvMatch && line.includes('pv')) {
        const pvIndex = parseInt(pvMatch[1]) - 1;
        const moveMatch = line.match(/pv\s+([\w\s]+)/);
        if (moveMatch) {
          const moves = moveMatch[1].trim().split(/\s+/);
          const bestMove = moves[0];
          
          if (!st.bestMoves) st.bestMoves = [];
          st.bestMoves[pvIndex] = {
            move: bestMove,
            san: uciToSan(boardId, bestMove) || bestMove
          };
          
          // Update best moves display in real-time
          updateBestMovesDisplay(boardId);
        }
      }
    }

    function parseBestMove(boardId, line) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const bestMoveMatch = line.match(/bestmove\s+(\w+)/);
      if (bestMoveMatch) {
        const bestMove = bestMoveMatch[1];
        const sanMove = uciToSan(boardId, bestMove) || bestMove;
        
        st.bestMove = bestMove;
        st.bestMoveSan = sanMove;
        
        // Update best move display
        const bestMoveEl = document.getElementById(`best-move-value-${boardId}`);
        if (bestMoveEl) {
          bestMoveEl.textContent = sanMove;
        }
        
        // Draw arrow for best move
        if (bestMove && bestMove.length >= 4) {
          drawBestMoveArrow(boardId, bestMove);
        }
        
        // Show best moves strip
        showBestMoves(boardId);
        
        // Schedule next analysis
        if (st.engineRunning) {
          clearTimeout(st.analysisTimeout);
          // Analyze continuously but less frequently after reaching target depth
          st.analysisTimeout = setTimeout(() => analyzePosition(boardId), 2000);
        }
        
        updateEngineStatus(boardId, 'Ready');
      }
    }

    function uciToSan(boardId, uciMove) {
      const st = boardsState[boardId];
      if (!st || !st.game || !uciMove || uciMove.length < 4) return uciMove;
      
      try {
        const from = uciMove.substring(0, 2);
        const to = uciMove.substring(2, 4);
        const promotion = uciMove.length > 4 ? uciMove.substring(4) : null;
        
        const moveObj = {
          from: from,
          to: to,
          promotion: promotion || undefined
        };
        
        const move = st.game.move(moveObj);
        if (move && move.san) {
          // Undo the move
          st.game.undo();
          return move.san;
        }
      } catch(e) {
        console.error('Failed to convert UCI to SAN:', e);
      }
      
      return uciMove;
    }

    function analyzePosition(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.engineRunning || !st.game || !st.engineWorker) return;
      
      // Clear previous timeout
      if (st.analysisTimeout) {
        clearTimeout(st.analysisTimeout);
        st.analysisTimeout = null;
      }
      
      // Reset analysis state
      st.bestMoves = [];
      st.depthReached = 0;
      hideBestMoves(boardId);
      clearArrow(boardId);
      
      try {
        const fen = st.game.fen ? st.game.fen() : 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
        
        // Don't analyze starting position
        if (fen === 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1') {
          updateEngineStatus(boardId, 'Start position');
          st.analysisTimeout = setTimeout(() => analyzePosition(boardId), 2000);
          return;
        }
        
        if (!st.engineReady) {
          st.pendingAnalysis = true;
          return;
        }
        
        // Set position and analyze with infinite search
        st.engineWorker.postMessage(`position fen ${fen}`);
        st.engineWorker.postMessage(`go depth ${st.analysisDepth}`);
        
        updateEngineStatus(boardId, 'Analyzing...');
      } catch (e) {
        console.error('Analysis error:', e);
        updateEngineStatus(boardId, 'Error');
        // Retry after error
        st.analysisTimeout = setTimeout(() => analyzePosition(boardId), 2000);
      }
    }

    function toggleEngine(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const toggleSwitch = document.getElementById(`engine-switch-${boardId}`);
      
      if (!st.engineRunning) {
        // Start engine
        st.engineRunning = true;
        if (toggleSwitch) {
          toggleSwitch.checked = true;
        }
        updateEngineStatus(boardId, 'Loading engine...');
        
        initStockfish(boardId).then(success => {
          if (success) {
            addNotification(boardId, `Engine started`);
            
            // Start analysis after a delay
            setTimeout(() => analyzePosition(boardId), 500);
          } else {
            st.engineRunning = false;
            if (toggleSwitch) {
              toggleSwitch.checked = false;
            }
            updateEngineStatus(boardId, 'Failed to load');
            addNotification(boardId, 'Failed to start engine');
          }
        });
      } else {
        // Stop engine
        st.engineRunning = false;
        
        if (st.analysisTimeout) {
          clearTimeout(st.analysisTimeout);
          st.analysisTimeout = null;
        }
        
        if (st.engineWorker) {
          try {
            st.engineWorker.postMessage('quit');
            setTimeout(() => st.engineWorker.terminate(), 100);
          } catch(e) {}
          st.engineWorker = null;
        }
        
        if (toggleSwitch) {
          toggleSwitch.checked = false;
        }
        
        updateEngineStatus(boardId, 'Idle');
        clearArrow(boardId);
        hideBestMoves(boardId);
        updateEvalBar(boardId, 0);
        
        addNotification(boardId, 'Engine stopped');
      }
    }

    function updateEngineStatus(boardId, status) {
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      if (!statusEl) return;
      
      statusEl.textContent = status;
      
      // Update status class
      statusEl.className = 'engine-status';
      if (status === 'Analyzing...') {
        statusEl.classList.add('status-analyzing');
      } else if (status === 'Ready') {
        statusEl.classList.add('status-ready');
      } else {
        statusEl.classList.add('status-idle');
      }
    }

    // ---------- EVALUATION BAR ----------
    function updateEvalBar(boardId, evalScore) {
      const evalBar = document.getElementById(`eval-bar-fill-${boardId}`);
      const evalText = document.getElementById(`eval-bar-text-${boardId}`);
      if (!evalBar || !evalText) return;
      
      let percentage, displayText;
      
      if (typeof evalScore === 'string' && evalScore.startsWith('M')) {
        // Mate score
        displayText = `#${evalScore.substring(1)}`;
        percentage = evalScore.startsWith('M-') ? 0 : 100;
      } else {
        // Centipawn evaluation
        const numEval = typeof evalScore === 'number' ? evalScore : parseFloat(evalScore) || 0;
        
        // Convert to percentage (0-100%)
        // Sigmoid-like function to compress extreme values
        const sigmoid = 2 / (1 + Math.exp(-Math.abs(numEval) / 5)) - 1;
        percentage = 50 + (numEval > 0 ? sigmoid * 50 : -sigmoid * 50);
        
        // Clamp between 0 and 100
        percentage = Math.max(0, Math.min(100, percentage));
        
        displayText = (numEval > 0 ? '+' : '') + numEval.toFixed(1);
      }
      
      // Set bar height (inverse because SVG coordinates)
      evalBar.style.height = `${percentage}%`;
      evalBar.style.top = `${100 - percentage}%`;
      
      // Update text
      evalText.textContent = displayText;
      evalText.style.top = `${Math.max(10, Math.min(90, 100 - percentage))}%`;
    }

    // ---------- BEST MOVES DISPLAY ----------
    function updateBestMovesDisplay(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.bestMoves || st.bestMoves.length === 0) return;
      
      const bestMovesContainer = document.getElementById(`best-moves-container-${boardId}`);
      if (!bestMovesContainer) return;
      
      // Clear existing moves
      bestMovesContainer.innerHTML = '';
      
      // Show only top 6 moves
      const movesToShow = st.bestMoves.filter(Boolean).slice(0, 6);
      
      movesToShow.forEach((moveData, index) => {
        const moveItem = document.createElement('div');
        moveItem.className = 'best-move-item';
        if (index === 0) {
          moveItem.classList.add('main');
        }
        
        const moveNumber = document.createElement('div');
        moveNumber.className = 'best-move-number';
        moveNumber.textContent = index + 1;
        
        const moveSan = document.createElement('div');
        moveSan.className = 'best-move-san';
        moveSan.textContent = moveData.san || moveData.move;
        
        moveItem.appendChild(moveNumber);
        moveItem.appendChild(moveSan);
        bestMovesContainer.appendChild(moveItem);
      });
    }

    function showBestMoves(boardId) {
      const bestMovesStrip = document.getElementById(`best-moves-${boardId}`);
      if (bestMovesStrip) {
        bestMovesStrip.classList.add('active');
      }
    }

    function hideBestMoves(boardId) {
      const bestMovesStrip = document.getElementById(`best-moves-${boardId}`);
      if (bestMovesStrip) {
        bestMovesStrip.classList.remove('active');
      }
    }

    // ---------- ARROW FUNCTIONS (Lichess style) ----------
    function initArrowOverlay(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const arrowOverlay = document.getElementById(`arrows_${boardId}`);
      if (!arrowOverlay) return;
      
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.className = 'arrow-svg';
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '10';
      
      arrowOverlay.innerHTML = '';
      arrowOverlay.appendChild(svg);
      st.arrowSvg = svg;
    }

    function drawBestMoveArrow(boardId, uciMove) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg || !uciMove || uciMove.length < 4) return;
      
      clearArrow(boardId);
      
      const from = uciMove.substring(0, 2);
      const to = uciMove.substring(2, 4);
      
      // Lichess-style arrow: bright green with gradient
      const arrow = {
        from: from,
        to: to,
        color: '#10b981', // Bright green
        width: 3,
        opacity: 0.9,
        headSize: 0.25 // Relative to square size
      };
      
      drawArrow(boardId, arrow);
    }

    function drawArrow(boardId, arrow) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      
      st.arrowSvg.innerHTML = '';
      
      const boardEl = document.getElementById(`board_${boardId}`);
      if (!boardEl) return;
      
      const boardRect = boardEl.getBoundingClientRect();
      const squareSize = boardRect.width / 8;
      
      const fromSquare = arrow.from.toLowerCase();
      const toSquare = arrow.to.toLowerCase();
      
      if (fromSquare.length !== 2 || toSquare.length !== 2) return;
      
      const fromFile = fromSquare.charCodeAt(0) - 97;
      const fromRank = parseInt(fromSquare.charAt(1)) - 1;
      const toFile = toSquare.charCodeAt(0) - 97;
      const toRank = parseInt(toSquare.charAt(1)) - 1;
      
      let x1, y1, x2, y2;
      if (st.flip) {
        x1 = (7 - fromFile) * squareSize + squareSize / 2;
        y1 = fromRank * squareSize + squareSize / 2;
        x2 = (7 - toFile) * squareSize + squareSize / 2;
        y2 = toRank * squareSize + squareSize / 2;
      } else {
        x1 = fromFile * squareSize + squareSize / 2;
        y1 = (7 - fromRank) * squareSize + squareSize / 2;
        x2 = toFile * squareSize + squareSize / 2;
        y2 = (7 - toRank) * squareSize + squareSize / 2;
      }
      
      // Calculate arrow length and angle
      const dx = x2 - x1;
      const dy = y2 - y1;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      // Adjust endpoint to not overlap the piece
      const adjust = squareSize * 0.2;
      const x2_adj = x2 - Math.cos(angle) * adjust;
      const y2_adj = y2 - Math.sin(angle) * adjust;
      
      // Draw arrow line with gradient for Lichess effect
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2_adj);
      line.setAttribute('y2', y2_adj);
      line.setAttribute('stroke', arrow.color);
      line.setAttribute('stroke-width', arrow.width);
      line.setAttribute('stroke-opacity', arrow.opacity);
      line.setAttribute('stroke-linecap', 'round');
      st.arrowSvg.appendChild(line);
      
      // Draw arrowhead (triangle) like Lichess
      const headLength = squareSize * arrow.headSize;
      const headAngle = Math.PI / 6;
      
      const x3 = x2_adj - headLength * Math.cos(angle - headAngle);
      const y3 = y2_adj - headLength * Math.sin(angle - headAngle);
      const x4 = x2_adj - headLength * Math.cos(angle + headAngle);
      const y4 = y2_adj - headLength * Math.sin(angle + headAngle);
      
      const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      polygon.setAttribute('points', `${x2_adj},${y2_adj} ${x3},${y3} ${x4},${y4}`);
      polygon.setAttribute('fill', arrow.color);
      polygon.setAttribute('fill-opacity', arrow.opacity);
      st.arrowSvg.appendChild(polygon);
    }

    function clearArrow(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      st.arrowSvg.innerHTML = '';
    }

    // ---------- UI HELPER FUNCTIONS ----------
    function createCard(student, pieceTheme, index){
      const card = document.createElement('div'); 
      card.className = 'board-card'; 
      card.dataset.studentId = student.id;

      const label = document.createElement('div'); 
      label.className = 'student-label';
      label.innerHTML = `<span class="label-text">${student.name}</span><span class="badge-holder" style="margin-left:10px"></span><span class="path-holder" style="margin-left:8px;font-size:11px;color:#666"></span>`;
      card.appendChild(label);

      const top = document.createElement('div'); 
      top.className = 'top-strip';
      top.innerHTML = `<div class="controls">
        <span class="label-small" style="margin-right:6px;">Size</span>
        <input id="size-slider-${student.id}" name="size-slider" type="range" min="200" max="800" value="" class="size-slider" data-sid="${student.id}">
        <button class="icon flip-btn" data-sid="${student.id}" title="Flip">Flip</button>
        <select id="player-select-${student.id}" name="player-select" class="player-select" data-sid="${student.id}" style="min-width:180px;">
          <option value="">View students</option>
        </select>
      </div>`;
      card.appendChild(top);

      const boardInnerWrap = document.createElement('div'); 
      boardInnerWrap.className = 'board-inner';
      const boardHolder = document.createElement('div'); 
      boardHolder.className = 'board-holder';
      boardHolder.style.position = 'relative';
      
      // Add evaluation bar (right side)
      const evalBar = document.createElement('div');
      evalBar.className = 'eval-bar';
      evalBar.id = `eval-bar-${student.id}`;
      evalBar.innerHTML = `
        <div id="eval-bar-fill-${student.id}" class="eval-bar-fill" style="height: 50%; top: 50%;"></div>
        <div id="eval-bar-text-${student.id}" class="eval-bar-text" style="top: 50%;">0.0</div>
      `;
      
      // Add arrow overlay
      const arrowOverlay = document.createElement('div');
      arrowOverlay.className = 'arrow-overlay';
      arrowOverlay.id = 'arrows_' + student.id;
      
      const boardDiv = document.createElement('div'); 
      boardDiv.id = 'board_' + student.id;
      
      boardHolder.appendChild(boardDiv);
      boardHolder.appendChild(evalBar);
      boardHolder.appendChild(arrowOverlay);
      boardInnerWrap.appendChild(boardHolder); 
      card.appendChild(boardInnerWrap);

      const notifArea = document.createElement('div'); 
      notifArea.className = 'notif-area';
      notifArea.innerHTML = `
        <div class="notifications" id="notif_${student.id}"></div>
        <div class="notation" id="notation_${student.id}">No moves.</div>
      `;
      card.appendChild(notifArea);

      // Engine analysis panel - Lichess Style
      const enginePanel = document.createElement('div');
      enginePanel.className = 'engine-panel';
      enginePanel.innerHTML = `
        <div class="engine-toggle">
          <label class="toggle-switch">
            <input type="checkbox" id="engine-switch-${student.id}">
            <span class="toggle-slider"></span>
          </label>
          <span class="engine-label">Stockfish 17.1</span>
        </div>
        
        <div class="depth-controls">
          <span style="font-size:12px; color:#666;">Depth:</span>
          <input type="range" min="1" max="22" value="15" class="depth-slider" id="depth-slider-${student.id}">
          <span id="depth-value-${student.id}" class="depth-value">15</span>
        </div>
        
        <div class="best-move-container">
          <span class="best-move-label">Best:</span>
          <span id="best-move-value-${student.id}" class="best-move-value">--</span>
        </div>
        
        <span id="engine-status-${student.id}" class="engine-status status-idle">Idle</span>
      `;
      card.appendChild(enginePanel);
      
      // Best moves strip - Lichess Style
      const bestMovesStrip = document.createElement('div');
      bestMovesStrip.className = 'best-moves-strip';
      bestMovesStrip.id = `best-moves-${student.id}`;
      bestMovesStrip.innerHTML = `
        <div class="best-moves-header">
          <span>Top Moves</span>
        </div>
        <div class="best-moves-container" id="best-moves-container-${student.id}"></div>
      `;
      card.appendChild(bestMovesStrip);

      const defaultSize = (index < 2) ? 570 : 360;
      boardsState[student.id] = {
        size: defaultSize,
        flip: false,
        watchedClientId: null,
        listeners: {},
        boardObj: null,
        game: null,
        pieceTheme,
        // Stockfish engine properties
        engineWorker: null,
        engineRunning: false,
        engineReady: false,
        pendingAnalysis: false,
        analysisDepth: 15,
        bestMove: null,
        bestMoveSan: null,
        bestMoves: [],
        currentEval: 0,
        depthReached: 0,
        analysisTimeout: null,
        arrowSvg: null
      };

      // Event listeners
      const sizeSlider = top.querySelector('.size-slider');
      sizeSlider.value = defaultSize;
      sizeSlider.addEventListener('input', e => {
        const px = Number(e.target.value);
        boardsState[student.id].size = px;
        setBoardSize(student.id, px);
      });
      
      top.querySelector('.flip-btn').addEventListener('click', () => {
        const st = boardsState[student.id];
        st.flip = !st.flip;
        if(st.boardObj && typeof st.boardObj.flip === 'function') st.boardObj.flip();
        if (st.bestMove) {
          setTimeout(() => drawBestMoveArrow(student.id, st.bestMove), 100);
        }
      });

      const playerSelect = top.querySelector('.player-select');
      playerSelect.addEventListener('change', e => {
        const client = e.target.value || null;
        if(!client) {
          stopWatching(student.id);
        } else {
          startWatching(student.id, client);
        }
      });

      // Engine event listeners
      const engineSwitch = enginePanel.querySelector(`#engine-switch-${student.id}`);
      const depthSlider = enginePanel.querySelector(`#depth-slider-${student.id}`);
      const depthValue = enginePanel.querySelector(`#depth-value-${student.id}`);

      engineSwitch.addEventListener('change', () => {
        toggleEngine(student.id);
      });

      depthSlider.addEventListener('input', (e) => {
        const depth = parseInt(e.target.value);
        depthValue.textContent = depth;
        const st = boardsState[student.id];
        if(st) {
          st.analysisDepth = depth;
          if (st.engineRunning) {
            // Restart analysis with new depth
            if (st.analysisTimeout) {
              clearTimeout(st.analysisTimeout);
            }
            analyzePosition(student.id);
          }
        }
      });

      return card;
    }

    function initBoard(studentId){
      const st = boardsState[studentId];
      if(!st) return;
      try{ 
        st.game = new Chess();
      }catch(e){ 
        console.warn('Chess engine init failed:', e);
        st.game = null;
      }
      try{
        st.boardObj = Chessboard('board_' + studentId, {
          draggable: false,
          position: 'start',
          pieceTheme: st.pieceTheme
        });
      }catch(e){ 
        console.error('Chessboard init failed', e);
      }
      setBoardSize(studentId, st.size);
      initArrowOverlay(studentId);
      updateEvalBar(studentId, 0);
    }

    function setBoardSize(boardId, px){
      const st = boardsState[boardId];
      if(!st) return;
      const div = document.getElementById('board_' + boardId);
      if(!div) return;
      const holder = div.parentElement;
      if(holder){ 
        holder.style.width = px + 'px'; 
        holder.style.height = px + 'px'; 
      }
      try{ 
        if(st.boardObj && typeof st.boardObj.resize === 'function') 
          st.boardObj.resize(); 
      }catch(e){}
    }

    // ---------- PRESENCE & ONLINE UPDATES ----------
    onlineRef.on('value', snap => {
      const val = snap.val() || {};
      for(const k in onlineMap) delete onlineMap[k];
      for(const id in val){ 
        if(!val.hasOwnProperty(id)) continue; 
        onlineMap[id] = { email: val[id].email || id, role: val[id].role || null, ts: val[id].ts || Date.now() }; 
      }
      STUDENTS.forEach(s => populateSelectForBoard(s.id));
      STUDENTS.forEach(s => refreshBadge(s.id));
    });

    // Publish master presence
    try{
      const n = onlineRef.child(MASTER_ID);
      n.set({ email: MASTER_NAME, role: 'master', ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
      n.onDisconnect().remove();
      setInterval(()=> n.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
    }catch(e){}

    // ---------- UI UPDATE FUNCTIONS ----------
    function populateSelectForBoard(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(!sel) return;
      const prev = sel.value;
      sel.innerHTML = '';
      const title = document.createElement('option'); title.value=''; title.textContent='View students'; sel.appendChild(title);

      const onlineIds = Object.keys(onlineMap).filter(id => id !== MASTER_ID);
      if(onlineIds.length === 0){
        const none = document.createElement('option'); none.value=''; none.disabled=true; none.textContent='No online'; sel.appendChild(none); sel.value=''; return;
      }
      
      onlineIds.forEach(id => { 
        const opt = document.createElement('option'); 
        opt.value = id; 
        opt.textContent = `${onlineMap[id].email} (${id.slice(0,6)})`; 
        sel.appendChild(opt); 
      });

      const prefer = st.watchedClientId || prev;
      if(prefer && Array.from(sel.options).some(o => o.value === prefer)) sel.value = prefer; else sel.value = '';
    }

    function refreshBadge(boardId){
      const st = boardsState[boardId];
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId);
      if(!card) return;
      const badgeHolder = card.querySelector('.badge-holder');
      const pathHolder = card.querySelector('.path-holder');
      badgeHolder.innerHTML = '';
      pathHolder.textContent = st.watchedClientId ? `moves/${st.watchedClientId}` : '';
      if(!st.watchedClientId) return;
      const span = document.createElement('span');
      span.style.cssText = 'font-size:11px; padding:2px 6px; border-radius:3px; background:#d1fae5; color:#065f46; border:1px solid #a7f3d0;';
      span.textContent = onlineMap[st.watchedClientId] ? 'online' : 'offline';
      badgeHolder.appendChild(span);
    }

    function addNotification(boardId, msg){
      const el = document.getElementById('notif_' + boardId);
      if(!el) return;
      const st = boardsState[boardId];
      if(st && st.lastNotif === msg) return;
      st.lastNotif = msg;
      const item = document.createElement('div');
      item.className = 'notif-item';
      item.textContent = `${new Date().toLocaleTimeString()} — ${msg}`;
      el.insertBefore(item, el.firstChild);
      while(el.children.length > 5) el.removeChild(el.lastChild);
    }

    function updateNotation(boardId){
      const st = boardsState[boardId];
      const notEl = document.getElementById('notation_' + boardId);
      if(!st || !notEl) return;
      try{
        if(!st.game || typeof st.game.history !== 'function'){ notEl.innerHTML = 'No moves.'; return; }
        const hist = st.game.history() || [];
        if(hist.length === 0){ notEl.innerHTML = 'No moves.'; return; }
        notEl.innerHTML = '';
        for(let i=0;i<hist.length;i+=2){
          const no = Math.floor(i/2)+1;
          const w = hist[i]||'';
          const b = hist[i+1]||'';
          const div = document.createElement('div');
          div.className = 'move';
          div.innerHTML = `<strong>${no}.</strong>&nbsp;${w}${ b ? ('\u00A0' + b) : '' }`;
          notEl.appendChild(div);
        }
      }catch(e){ console.warn('updateNotation error', e); }
    }
    
    function clearNotation(boardId){ 
      const notEl = document.getElementById('notation_' + boardId); 
      if(notEl) notEl.innerHTML = 'No moves.'; 
    }

    // ---------- CONNECTION STATUS ----------
    const connectedRef = db.ref('.info/connected');
    connectedRef.on('value', function(snap) {
      const statusElement = document.getElementById('connectionStatus');
      if (snap.val() === true) {
        if (statusElement) {
          statusElement.textContent = '✅ Connected';
          statusElement.className = 'connection-status';
        }
      } else {
        if (statusElement) {
          statusElement.textContent = '❌ Disconnected';
          statusElement.className = 'connection-status disconnected';
        }
      }
    });

    // ---------- UTILITIES ----------
    document.getElementById('globalLogout').addEventListener('click', () => {
      try{ 
        localStorage.removeItem('role'); 
        localStorage.removeItem('username'); 
        localStorage.removeItem('email'); 
        sessionStorage.removeItem('iq4u_clientId'); 
      }catch(e){}
      try{ 
        onlineRef.child(MASTER_ID).remove().catch(()=>{}); 
      }catch(e){}
      window.location.href = 'index.html';
    });

    window.addEventListener('beforeunload', () => {
      try{ 
        onlineRef.child(MASTER_ID).remove().catch(()=>{}); 
      }catch(e){}
      STUDENTS.forEach(s => stopWatching(s.id));
    });

  })();
  </script>
</body>
</html>
