<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Master Dashboard - IQ 4U Academy</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/favicon-16x16.png">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    :root{ --card-gap:12px; --card-bg:#fff; --card-border:#ddd; --control-height:44px; font-family:Arial,Helvetica,sans-serif; color:#222;}
    html,body{ height:100%; margin:0; background:#f5f7fb; }
    .container{ margin:16px auto; max-width:1200px; padding-bottom:28px; }
    
    /* Header styles */
    .header-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 0 16px;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    h1{ margin:0; font-size:20px; display:flex; align-items:center; gap:8px; }
    .logo-img { height: 32px; width: 32px; }
    
    /* Connection status in header */
    .connection-status-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 20px;
    }
    
    .connection-status-text {
      font-size: 12px;
      font-weight: 600;
    }
    
    .connection-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      transition: all 0.3s ease;
    }
    
    .connection-dot.connected {
      background-color: #10b981; /* Green */
      box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
      animation: pulse 2s infinite;
    }
    
    .connection-dot.disconnected {
      background-color: #ef4444; /* Red */
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
    }
    
    .connection-dot.connecting {
      background-color: #f59e0b; /* Yellow */
      box-shadow: 0 0 8px rgba(245, 158, 11, 0.6);
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.6; }
      100% { opacity: 1; }
    }
    
    /* Logout button at top right */
    .header-actions { display: flex; align-items: center; gap: 12px; }
    .btn-logout{ 
      background:#ef4444; 
      color:#fff; 
      border:none; 
      padding:8px 16px; 
      border-radius:8px; 
      cursor:pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background-color 0.2s;
    }
    .btn-logout:hover { background:#dc2626; }
    
    .boards-grid{ display:grid; grid-template-columns:repeat(auto-fill, minmax(500px, 1fr)); gap:var(--card-gap); padding: 0 16px; }
    .board-card{ 
      background:var(--card-bg); 
      border:1px solid var(--card-border); 
      border-radius:8px; 
      padding:10px; 
      display:flex; 
      flex-direction:column; 
      gap:10px; 
      min-height:260px; 
      box-shadow:0 1px 3px rgba(20,30,40,0.05);
      position: relative;
    }
    
    /* Student label at top */
    .student-label{ 
      font-weight:600; 
      text-align:center; 
      display:flex; 
      align-items:center; 
      gap:8px; 
      justify-content:center;
      margin-bottom: 8px;
      font-size: 16px;
    }
    
    /* Control strip - positioned at top right of board */
    .control-strip {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 6px;
      align-items: center;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 6px;
      padding: 6px 8px;
      border: 1px solid #e5e7eb;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 20;
      max-width: 300px;
      min-width: 200px;
    }
    
    .control-strip label {
      font-size: 11px;
      font-weight: 600;
      color: #4b5563;
      white-space: nowrap;
    }
    
    .control-strip select {
      height: 28px;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      background: #fff;
      font-size: 12px;
      min-width: 160px;
      max-width: 200px;
    }
    
    .top-strip{ 
      display:flex; 
      align-items:center; 
      justify-content:flex-start; 
      gap:8px; 
      height:var(--control-height);
      margin-top: 10px;
    }
    
    .controls{ 
      display:flex; 
      gap:8px; 
      align-items:center; 
      width:100%; 
      flex-wrap:wrap;
    }
    
    .controls button, .controls input[type=range]{ 
      height:32px; 
      padding:4px 8px; 
      border-radius:6px; 
      border:1px solid #ccc; 
      background:#fff; 
    }
    
    .board-inner{ 
      width:100%; 
      display:flex; 
      justify-content:center;
      margin-top: 40px; /* Add space for control strip */
    }
    
    .board-holder{ 
      box-sizing:border-box; 
      border-radius:6px; 
      overflow:hidden; 
      background:#fff; 
      position: relative;
      border: 1px solid #ddd;
    }
    
    /* Board visualization - temporary */
    .board-placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f9fa;
      color: #6c757d;
      font-size: 14px;
    }
    
    .debug{ 
      font-family:monospace; 
      font-size:12px; 
      background:#fbfcfd; 
      border:1px solid #eef2f6; 
      padding:6px; 
      border-radius:6px; 
      max-height:80px; 
      overflow:auto; 
      display:none; 
    }
    
    /* Arrow overlay */
    .arrow-overlay { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      pointer-events: none; 
      z-index: 10; 
    }
    
    .notif-area{ 
      display:flex; 
      gap:12px; 
      align-items:flex-start; 
      flex-wrap:wrap; 
      width:100%; 
      margin-top: 10px;
    }
    
    .notifications { 
      flex: 1 1 260px; 
      min-width:160px; 
      max-width:460px; 
      background:#fff; 
      border:1px solid #eef2f6; 
      padding:8px; 
      border-radius:6px; 
      font-size:13px; 
      color:#333; 
      box-sizing:border-box; 
      max-height:88px; 
      overflow:auto; 
    }
    
    .notation { 
      flex:1 1 200px; 
      min-width:160px; 
      max-width:999px; 
      background:#fbfdff; 
      border:1px solid #eef2ff; 
      padding:8px; 
      border-radius:6px; 
      font-family:monospace; 
      font-size:13px; 
      white-space:normal; 
      display:flex; 
      flex-wrap:wrap; 
      gap:8px; 
      align-items:center; 
      box-sizing:border-box; 
      min-height:44px; 
    }
    
    .notation .move { 
      padding:4px 8px; 
      border-radius:6px; 
      background:transparent; 
    }
    
    /* Engine controls styling */
    .engine-panel { 
      margin-top: 10px; 
      display:flex; 
      gap:8px; 
      align-items:center; 
      flex-wrap:wrap; 
      justify-content:flex-start; 
      padding:8px; 
      background:#f8f9fa; 
      border-radius:6px; 
      border:1px solid #eef2f6; 
    }
    
    .engine-btn { 
      padding:6px 12px; 
      border-radius:6px; 
      background:#3b82f6; 
      color:#fff; 
      border:none; 
      cursor:pointer; 
      font-size:12px; 
    }
    
    .engine-btn-stop { 
      background:#ef4444; 
    }
    
    .engine-btn-next { 
      background:#10b981; 
    }
    
    .engine-status { 
      font-size:12px; 
      color:#666; 
      padding:4px 8px; 
      background:#fff; 
      border-radius:4px; 
      border:1px solid #eef2f6; 
      min-width:120px; 
    }
    
    .eval-display { 
      font-size:12px; 
      font-weight:bold; 
      padding:4px 8px; 
      border-radius:4px; 
    }
    
    .eval-positive { 
      background: #d1fae5; 
      color: #065f46; 
    }
    
    .eval-negative { 
      background: #fee2e2; 
      color: #991b1b; 
    }
    
    .eval-neutral { 
      background: #e5e7eb; 
      color: #4b5563; 
    }
    
    /* Best move display */
    .best-move-display { 
      font-size:13px; 
      padding:4px 8px; 
      background:#f0f9ff; 
      border-radius:4px; 
      border:1px solid #e0f2fe; 
      margin-left:8px; 
    }
    
    .variation-moves { 
      font-size:11px; 
      color:#666; 
      margin-left:8px; 
    }
    
    .move-san { 
      display:inline-block; 
      padding:2px 6px; 
      margin:0 2px; 
      background:#f3f4f6; 
      border-radius:3px; 
    }
    
    /* Move quality display */
    .move-quality-display { 
      font-size:11px; 
      font-weight:bold; 
      padding:2px 6px; 
      border-radius:4px; 
      margin-left:8px; 
    }
    
    /* MultiPV move display */
    .multi-pv-move {
      display: inline-block;
      margin-right: 6px;
      padding: 2px 6px;
      border-radius: 3px;
      background: #f3f4f6;
      font-size: 11px;
      font-weight: bold;
    }
    
    .multi-pv-move.best {
      background: #d1fae5;
      color: #065f46;
    }
    
    .multi-pv-move.second-best {
      background: #f0f9ff;
      color: #0369a1;
    }
    
    /* Analysis Grid Styles */
    .analysis-grid { 
      margin-top: 12px; 
      background: #f8fafc; 
      border: 1px solid #e2e8f0; 
      border-radius: 6px; 
      padding: 10px; 
      font-size: 11px; 
      display: none; 
      grid-template-columns: 1fr 1fr; 
      gap: 8px; 
    }
    
    .analysis-toggle-btn { 
      margin-top: 8px; 
      font-size: 11px; 
      padding: 4px 8px; 
    }
    
    /* Move explanation tooltip */
    .move-explanation {
      font-size: 10px;
      color: #666;
      margin-top: 4px;
      font-style: italic;
      max-width: 200px;
      line-height: 1.3;
    }
    
    /* Old connection status (removed from fixed position) */
    .connection-status {
      display: none; /* We'll use the header version instead */
    }
    
    /* Enhanced arrow styles */
    .arrow-svg line { stroke-linecap: round; }
    
    /* Multi-watch styling */
    .multi-watch-controls { 
      display:flex; 
      gap:6px; 
      align-items:center; 
      margin-left:auto; 
    }
    
    .watch-mode-label { 
      font-size:11px; 
      color:#666; 
    }
    
    .watch-mode-btn { 
      padding:4px 8px; 
      font-size:11px; 
      border-radius:4px; 
      background:#f3f4f6; 
      border:1px solid #d1d5db; 
      cursor:pointer; 
    }
    
    .watch-mode-btn.active { 
      background:#3b82f6; 
      color:white; 
      border-color:#2563eb; 
    }
    
    .player-badge { 
      display:inline-block; 
      padding:2px 6px; 
      border-radius:4px; 
      font-size:11px; 
      margin-left:4px; 
      font-weight:bold; 
    }
    
    .player-badge.white { 
      background:#f3f4f6; 
      color:#111827; 
    }
    
    .player-badge.black { 
      background:#1f2937; 
      color:#f9fafb; 
    }
    
    .game-info { 
      font-size:12px; 
      color:#666; 
      margin-left:12px; 
    }
    
    /* Footer actions removed - logout is in header */
    .footer-actions{ display:none; }
    
    @media(max-width:900px){ 
      .boards-grid{ grid-template-columns:1fr; padding:0 12px; } 
      .notif-area{ flex-direction:column; } 
      .analysis-grid { grid-template-columns: 1fr; } 
      .controls { flex-wrap: wrap; }
      .control-strip {
        position: relative;
        top: auto;
        right: auto;
        margin: 10px auto;
        max-width: 90%;
      }
      .board-inner {
        margin-top: 10px;
      }
      .header-container {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      .header-left {
        width: 100%;
        justify-content: space-between;
      }
      .header-actions {
        align-self: flex-end;
        width: 100%;
        justify-content: flex-end;
      }
      .connection-status-container {
        margin-left: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header with logo, connection status, and logout -->
    <div class="header-container">
      <div class="header-left">
        <img src="https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/android-chrome-192x192.png" alt="IQ4U Logo" class="logo-img">
        <h1>Master Dashboard - IQ 4U Academy</h1>
        
        <!-- Firebase Connection Status in Header -->
        <div class="connection-status-container">
          <div class="connection-dot connecting" id="firebaseConnectionDot"></div>
          <span class="connection-status-text" id="firebaseConnectionText">Connecting...</span>
        </div>
      </div>
      <div class="header-actions">
        <button id="globalLogout" class="btn-logout">Logout</button>
      </div>
    </div>

    <div class="boards-grid" id="boardsGrid"></div>

    <!-- Footer actions removed - logout is now in header -->
  </div>

  <!-- jQuery (required by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- FIXED: Correct chessboard.js URL -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
  (async function(){
    // ---------- CONFIG ----------
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb6936fe0da4bb"
    };
    
    try{ 
      firebase.initializeApp(FIREBASE_CONFIG); 
      console.log('✅ Firebase initialized');
      updateFirebaseConnectionStatus(true, 'Connected');
    } catch(e){ 
      console.error('❌ Firebase init failed:', e);
      updateFirebaseConnectionStatus(false, 'Connection Failed');
    }
    
    const db = firebase.database();
    const onlineRef = db.ref('online');

    const MASTER_ID = sessionStorage.getItem('iq4u_clientId') || ('m_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', MASTER_ID);
    const MASTER_NAME = localStorage.getItem('username') || localStorage.getItem('email') || 'master';

    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    const STUDENTS = [
      { id: 'student1', name: 'Student 1' },
      { id: 'student2', name: 'Student 2' },
      { id: 'student3', name: 'Student 3' },
      { id: 'student4', name: 'Student 4' }
    ];

    const onlineMap = {};   // clientId => {email, role, ts}
    const boardsState = {}; // per-board state

    // Stockfish URLs - Using the "single" version you provided
    const STOCKFISH_JS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/stockfish/stockfish-17.1-lite-single-03e3232.js';

    // Starting FEN position
    const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

    // ---------- WATCH MODES (DEFINED EARLY) ----------
    const WATCH_MODES = {
      SINGLE: 'single',
      MULTI_WHITE: 'multi_white',
      MULTI_BLACK: 'multi_black'
    };

    // ---------- FIREBASE CONNECTION STATUS FUNCTIONS ----------
    function updateFirebaseConnectionStatus(isConnected, statusText) {
      const dotElement = document.getElementById('firebaseConnectionDot');
      const textElement = document.getElementById('firebaseConnectionText');
      
      if (!dotElement || !textElement) return;
      
      if (isConnected) {
        // Connected - Green
        dotElement.className = 'connection-dot connected';
        textElement.textContent = statusText || 'Connected';
        textElement.style.color = '#10b981';
      } else {
        if (statusText === 'Connecting...') {
          // Connecting - Yellow
          dotElement.className = 'connection-dot connecting';
          textElement.textContent = statusText;
          textElement.style.color = '#f59e0b';
        } else {
          // Disconnected - Red
          dotElement.className = 'connection-dot disconnected';
          textElement.textContent = statusText || 'Disconnected';
          textElement.style.color = '#ef4444';
        }
      }
    }

    // ---------- CONNECTION STATUS LISTENER ----------
    function setupFirebaseConnectionListener() {
      const connectedRef = db.ref('.info/connected');
      
      connectedRef.on('value', function(snap) {
        if (snap.val() === true) {
          console.log('✅ Firebase connected');
          updateFirebaseConnectionStatus(true, 'Connected');
        } else {
          console.log('❌ Firebase disconnected');
          updateFirebaseConnectionStatus(false, 'Disconnected');
        }
      });
    }

    // ---------- ensure chess.js loaded ----------
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    async function ensureChess(){
      if(typeof Chess !== 'undefined') return;
      try{
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        window.Chess = mod.default || mod.Chess || mod;
      }catch(e){}
      if(typeof Chess !== 'undefined') return;
      await new Promise(resolve=>{
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = true;
        s.onload = ()=> setTimeout(resolve, 10);
        s.onerror = ()=> resolve();
        document.head.appendChild(s);
      });
    }

    async function pickPieceTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const r = await fetch(test, { method:'HEAD', cache:'no-store' }); return r.ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // ---------- build UI (DOM only) ----------
    const grid = document.getElementById('boardsGrid');
    const theme = await pickPieceTheme();
    
    // First define createCard function before using it
    function createCard(student, pieceTheme, index){
      const card = document.createElement('div'); 
      card.className = 'board-card'; 
      card.dataset.studentId = student.id;

      // Student label
      const label = document.createElement('div'); 
      label.className = 'student-label';
      label.id = `label-${student.id}`;
      label.innerHTML = `<span class="label-text">${student.name}</span><span class="badge-holder" style="margin-left:10px"></span><span class="game-info" id="game-info-${student.id}"></span>`;
      card.appendChild(label);

      // Control strip at top right of board
      const controlStrip = document.createElement('div');
      controlStrip.className = 'control-strip';
      controlStrip.innerHTML = `
        <label for="player-select-${student.id}">Watch:</label>
        <select id="player-select-${student.id}" name="player-select" class="player-select" data-sid="${student.id}">
          <option value="">Select student or game</option>
        </select>
      `;
      card.appendChild(controlStrip);

      // Original top strip (moved down)
      const top = document.createElement('div'); 
      top.className = 'top-strip';
      top.innerHTML = `
        <div class="controls">
          <span class="label-small" style="margin-right:6px;">Size</span>
          <input id="size-slider-${student.id}" name="size-slider" type="range" min="200" max="800" value="" class="size-slider" data-sid="${student.id}">
          <button class="icon flip-btn" data-sid="${student.id}" title="Flip">Flip</button>
        </div>
        <div class="multi-watch-controls">
          <span class="watch-mode-label">View:</span>
          <button class="watch-mode-btn watch-single" data-sid="${student.id}" title="Watch complete game">Full Game</button>
          <button class="watch-mode-btn watch-white" data-sid="${student.id}" title="Watch White only">White</button>
          <button class="watch-mode-btn watch-black" data-sid="${student.id}" title="Watch Black only">Black</button>
        </div>
      `;
      card.appendChild(top);

      const boardInnerWrap = document.createElement('div'); 
      boardInnerWrap.className = 'board-inner';
      const boardHolder = document.createElement('div'); 
      boardHolder.className = 'board-holder';
      
      // Add arrow overlay
      const arrowOverlay = document.createElement('div');
      arrowOverlay.className = 'arrow-overlay';
      arrowOverlay.id = 'arrows_' + student.id;
      
      const boardDiv = document.createElement('div'); 
      boardDiv.id = 'board_' + student.id;
      
      // Add temporary placeholder while chessboard loads
      const placeholder = document.createElement('div');
      placeholder.className = 'board-placeholder';
      placeholder.textContent = 'Loading chessboard...';
      boardDiv.appendChild(placeholder);
      
      boardHolder.appendChild(boardDiv);
      boardHolder.appendChild(arrowOverlay);
      boardInnerWrap.appendChild(boardHolder); 
      card.appendChild(boardInnerWrap);

      const notifArea = document.createElement('div'); 
      notifArea.className = 'notif-area';
      notifArea.innerHTML = `
        <div class="notifications" id="notif_${student.id}"></div>
        <div class="notation" id="notation_${student.id}">No moves.</div>
      `;
      card.appendChild(notifArea);

      // Engine analysis panel - SIMPLIFIED for on-demand analysis
      const enginePanel = document.createElement('div');
      enginePanel.className = 'engine-panel';
      enginePanel.innerHTML = `
        <button id="engine-toggle-${student.id}" class="engine-btn">Stockfish: OFF</button>
        <button id="analyze-btn-${student.id}" class="engine-btn">Analyse</button>
        <span id="engine-version-${student.id}" class="engine-status" style="background:#f3f4f6; padding:4px 8px; border-radius:4px; font-size:11px;">v17.1 Lite</span>
        <label style="font-size:12px; color:#666;">Depth:</label>
        <select id="depth-select-${student.id}" style="font-size:11px; padding:3px 6px; border-radius:4px; border:1px solid #d1d5db;">
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="15" selected>15</option>
          <option value="18">18</option>
          <option value="20">20</option>
        </select>
        <div style="display:flex; align-items:center; gap:4px; margin-left:8px;">
          <span id="best-move-${student.id}" class="best-move-display">Best: --</span>
          <span id="engine-eval-${student.id}" class="eval-display eval-neutral">+0.0</span>
        </div>
        <span id="engine-status-${student.id}" class="engine-status">Idle</span>
        <button class="analysis-toggle-btn engine-btn" style="margin-left:auto;" id="analysis-toggle-${student.id}">Show Analysis</button>
      `;
      card.appendChild(enginePanel);

      // Real-time analysis grid
      const analysisGrid = document.createElement('div');
      analysisGrid.className = 'analysis-grid';
      analysisGrid.id = `analysis-grid-${student.id}`;
      
      analysisGrid.innerHTML = `
        <div class="white-analysis" style="padding: 8px; background: white; border-radius: 4px;">
          <div style="font-weight: bold; margin-bottom: 6px; color: #374151;">White Analysis</div>
          <div id="white-stats-${student.id}">
            <div>Accuracy: --%</div>
            <div>Avg CPL: --</div>
            <div>Blunders: 0</div>
            <div>Mistakes: 0</div>
            <div>Inaccuracies: 0</div>
          </div>
        </div>
        <div class="black-analysis" style="padding: 8px; background: #1f2937; border-radius: 4px; color: white;">
          <div style="font-weight: bold; margin-bottom: 6px; color: #f3f4f6;">Black Analysis</div>
          <div id="black-stats-${student.id}">
            <div>Accuracy: --%</div>
            <div>Avg CPL: --</div>
            <div>Blunders: 0</div>
            <div>Mistakes: 0</div>
            <div>Inaccuracies: 0</div>
          </div>
        </div>
        <div class="move-history" style="grid-column: span 2; padding: 8px; background: white; border-radius: 4px; border: 1px solid #e5e7eb;">
          <div style="font-weight: bold; margin-bottom: 6px; color: #374151;">Move-by-Move Analysis</div>
          <div id="move-history-${student.id}" style="max-height: 120px; overflow-y: auto; font-family: monospace; font-size: 10px;">
            <div style="display: grid; grid-template-columns: 40px 60px 80px 60px 60px; gap: 8px; padding: 4px 0; border-bottom: 1px solid #f3f4f6;">
              <div>Move</div>
              <div>Player</div>
              <div>Move</div>
              <div>CPL</div>
              <div>Type</div>
            </div>
          </div>
        </div>
      `;
      card.appendChild(analysisGrid);

      const defaultSize = 500;
      boardsState[student.id] = {
        size: defaultSize,
        flip: false,
        watchedClientId: null,
        whitePlayer: null,
        blackPlayer: null,
        watchMode: WATCH_MODES.SINGLE,
        listeners: {},
        boardObj: null,
        game: null,
        pieceTheme,
        // Engine properties - SIMPLIFIED for on-demand
        engineWorker: null,
        engineRunning: false,
        analysisDepth: 15,
        evalScore: 0,
        bestMove: null,
        bestMoveUCI: null,
        multiPV: [],  // Store multiple principal variations
        previousEvalScore: 0,
        previousMateScore: null,  // ADDED: Store previous mate score
        currentMateScore: null,   // ADDED: Store current mate score
        arrowSvg: null,
        moveQualityHistory: [],
        isAnalyzing: false,
        engineVersion: 'Stockfish 17.1 Lite',
        currentAnalysisFen: null // ADDED: Store current FEN being analyzed
      };

      // Event listeners
      const sizeSlider = top.querySelector('.size-slider');
      sizeSlider.value = defaultSize;
      sizeSlider.addEventListener('input', e => {
        const px = Number(e.target.value);
        boardsState[student.id].size = px;
        setBoardSize(student.id, px);
      });
      
      top.querySelector('.flip-btn').addEventListener('click', () => {
        const st = boardsState[student.id];
        st.flip = !st.flip;
        if(st.boardObj && typeof st.boardObj.flip === 'function') st.boardObj.flip();
        if (st.bestMoveUCI) {
          setTimeout(() => drawBestMoveArrow(student.id, st.bestMoveUCI), 100);
        }
      });

      const playerSelect = controlStrip.querySelector('.player-select');
      playerSelect.addEventListener('change', e => {
        const selectedValue = e.target.value;
        if (!selectedValue) {
          stopWatching(student.id);
          return;
        }
        
        // Check if it's a combined game selection (contains |)
        if (selectedValue.includes('|')) {
          const [whiteId, blackId] = selectedValue.split('|');
          startWatchingGame(student.id, whiteId, blackId);
        } else {
          // Single player selection
          startWatching(student.id, selectedValue);
        }
      });

      // Multi-watch mode buttons
      const singleBtn = top.querySelector('.watch-single');
      const whiteBtn = top.querySelector('.watch-white');
      const blackBtn = top.querySelector('.watch-black');
      
      singleBtn.addEventListener('click', () => {
        if (boardsState[student.id].whitePlayer && boardsState[student.id].blackPlayer) {
          setWatchMode(student.id, WATCH_MODES.SINGLE);
        }
      });
      
      whiteBtn.addEventListener('click', () => {
        if (boardsState[student.id].whitePlayer) {
          setWatchMode(student.id, WATCH_MODES.MULTI_WHITE);
        }
      });
      
      blackBtn.addEventListener('click', () => {
        if (boardsState[student.id].blackPlayer) {
          setWatchMode(student.id, WATCH_MODES.MULTI_BLACK);
        }
      });

      // Engine event listeners
      const engineToggleBtn = enginePanel.querySelector(`#engine-toggle-${student.id}`);
      const analyzeBtn = enginePanel.querySelector(`#analyze-btn-${student.id}`);
      const depthSelect = enginePanel.querySelector(`#depth-select-${student.id}`);
      const analysisToggleBtn = enginePanel.querySelector(`#analysis-toggle-${student.id}`);

      engineToggleBtn.addEventListener('click', () => {
        toggleEngine(student.id);
      });

      analyzeBtn.addEventListener('click', () => {
        // FIX 1: Changed from analyzeOnce to analyzeFullGame
        analyzeFullGame(student.id);
      });

      depthSelect.addEventListener('change', (e) => {
        const st = boardsState[student.id];
        if(st) {
          st.analysisDepth = parseInt(e.target.value);
        }
      });

      analysisToggleBtn.addEventListener('click', () => {
        const grid = document.getElementById(`analysis-grid-${student.id}`);
        if (grid.style.display === 'grid') {
          grid.style.display = 'none';
          analysisToggleBtn.textContent = 'Show Analysis';
        } else {
          grid.style.display = 'grid';
          analysisToggleBtn.textContent = 'Hide Analysis';
          updateAnalysisGrid(student.id);
        }
      });

      return card;
    }

    // Now create the cards
    for(let i=0;i<STUDENTS.length;i++){
      const s = STUDENTS[i];
      const card = createCard(s, theme, i);
      grid.appendChild(card);
    }

    // Wait for jQuery and chessboard.js to load
    function waitForChessboard() {
      return new Promise((resolve) => {
        if (window.Chessboard && window.Chessboard !== 'undefined') {
          resolve();
        } else {
          const checkInterval = setInterval(() => {
            if (window.Chessboard && window.Chessboard !== 'undefined') {
              clearInterval(checkInterval);
              resolve();
            }
          }, 100);
          
          // Timeout after 5 seconds
          setTimeout(() => {
            clearInterval(checkInterval);
            console.warn('Chessboard.js failed to load, using fallback');
            resolve();
          }, 5000);
        }
      });
    }

    // wait and then initialize engines & chessboards
    await ensureChess();
    await waitForChessboard();
    
    for(const s of STUDENTS){
      initEngineAndBoard(s.id);
    }

    // ---------- STOCKFISH ENGINE FUNCTIONS ----------
    function createStockfishWorker(boardId) {
      const st = boardsState[boardId];
      if (!st) return null;
      
      try {
        // Create a worker with the Stockfish single version
        const worker = new Worker(STOCKFISH_JS_URL);
        
        let onMessageCallback = null;
        let isReady = false;
        
        worker.onmessage = function(e) {
          const line = e.data;
          
          if (line.includes('uciok')) {
            isReady = true;
            console.log(`✅ Stockfish 17.1 Lite loaded for ${boardId}`);
            
            // Configure Stockfish for better performance
            worker.postMessage('setoption name Use NNUE value true');
            worker.postMessage('setoption name Threads value 2');
            worker.postMessage('setoption name Hash value 128');
            
            // Enable MultiPV for showing top 2 best moves
            worker.postMessage('setoption name MultiPV value 2');
            
            worker.postMessage('isready');
            
            // Update UI
            const statusEl = document.getElementById(`engine-status-${boardId}`);
            if (statusEl) statusEl.textContent = 'Ready';
            
          }
          else if (line.includes('readyok')) {
            // Engine is ready for analysis
            const statusEl = document.getElementById(`engine-status-${boardId}`);
            if (statusEl) statusEl.textContent = 'Ready';
          }
          else if (line.startsWith('info')) {
            // Parse analysis info - ONLY for final depth
            processAnalysisInfo(boardId, line);
          }
          else if (line.startsWith('bestmove')) {
            // Analysis complete
            processBestMove(boardId, line);
          }
          
          if (onMessageCallback) {
            onMessageCallback(line);
          }
        };
        
        worker.onerror = function(e) {
          console.error(`Stockfish worker error for ${boardId}:`, e);
          const statusEl = document.getElementById(`engine-status-${boardId}`);
          if (statusEl) statusEl.textContent = 'Error';
          st.isAnalyzing = false;
          
          // Show error notification
          addNotification(boardId, 'Stockfish engine failed to load');
        };
        
        // Initialize Stockfish
        worker.postMessage('uci');
        
        return {
          worker: worker,
          setOnMessage: function(callback) {
            onMessageCallback = callback;
          },
          stop: function() {
            worker.postMessage('stop');
            st.isAnalyzing = false;
          },
          terminate: function() {
            worker.postMessage('stop');
            setTimeout(() => {
              try { worker.terminate(); } catch(e) {}
            }, 100);
          }
        };
      } catch (error) {
        console.error(`Failed to create Stockfish worker for ${boardId}:`, error);
        addNotification(boardId, 'Failed to initialize Stockfish engine');
        return null;
      }
    }

    // ---------- FIX 1: FULL GAME ANALYSIS FUNCTIONS ----------
    
    async function analyzeFullGame(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.engineWorker || !st.game || !st.engineRunning) {
        addNotification(boardId, 'Engine not ready. Please start Stockfish first.');
        return;
      }

      const history = st.game.history({ verbose: true });
      if (history.length === 0) {
        addNotification(boardId, 'No moves to analyze');
        return;
      }

      st.moveQualityHistory = [];
      st.previousEvalScore = 0;
      st.previousMateScore = null;

      addNotification(boardId, `Analyzing full game (${history.length} moves)...`);

      const tempGame = new Chess();

      for (let i = 0; i < history.length; i++) {
        const mv = history[i];
        tempGame.move(mv);

        await analyzeFenForMove(boardId, tempGame.fen(), i);
      }

      updateAnalysisGrid(boardId);
      
      // FIX 4: Auto-show analysis after full game
      const grid = document.getElementById(`analysis-grid-${boardId}`);
      const toggleBtn = document.getElementById(`analysis-toggle-${boardId}`);
      if (grid && toggleBtn) {
        grid.style.display = 'grid';
        toggleBtn.textContent = 'Hide Analysis';
      }
      
      addNotification(boardId, 'Full game analysis complete');
    }

    // Helper: analyze ONE move (awaitable)
    function analyzeFenForMove(boardId, fen, moveIndex) {
      return new Promise(resolve => {
        const st = boardsState[boardId];

        st.isAnalyzing = true;
        st.multiPV = [];
        st.currentAnalysisFen = fen; // Store the FEN being analyzed

        st.engineWorker.worker.postMessage('stop');
        st.engineWorker.worker.postMessage(`position fen ${fen}`);
        st.engineWorker.worker.postMessage(`go depth ${st.analysisDepth}`);

        const originalProcess = st.engineWorker.worker.onmessage;

        st.engineWorker.worker.onmessage = function(e) {
          const line = e.data;

          if (line.startsWith('info')) {
            processAnalysisInfo(boardId, line);
          }

          if (line.startsWith('bestmove')) {
            st.isAnalyzing = false;

            finalizeSingleMoveAnalysis(boardId, moveIndex, fen);
            st.engineWorker.worker.onmessage = originalProcess;
            resolve();
          }
        };
      });
    }

    // Finalize ONE move
    function finalizeSingleMoveAnalysis(boardId, moveIndex, fen) {
      const st = boardsState[boardId];
      if (!st.multiPV.length) return;

      const best = st.multiPV.sort((a,b)=>b.score-a.score)[0];
      const side = moveIndex % 2 === 0 ? 'white' : 'black';

      const cpl = calculateCPL(st.previousEvalScore, best.score, side);
      const classification = classifyMoveByCPL(cpl);

      st.moveQualityHistory.push({
        moveNumber: Math.floor(moveIndex / 2) + 1,
        player: side,
        move: st.game.history()[moveIndex],
        cpl,
        classification,
        fen: fen // Store FEN for correct SAN conversion
      });

      st.previousEvalScore = best.score;
      st.previousMateScore = st.currentMateScore;
    }

    // ---------- ON-DEMAND ANALYSIS FUNCTIONS ----------
    
    // Step 2: Single-shot analysis function (kept for compatibility)
    function analyzeOnce(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.engineWorker || !st.game || !st.engineRunning) {
        addNotification(boardId, 'Engine not ready. Please start Stockfish first.');
        return;
      }

      const fen = st.game.fen();
      if (fen === START_FEN) {
        addNotification(boardId, 'Starting position - nothing to analyze yet.');
        return;
      }

      st.isAnalyzing = true;
      st.multiPV = [];
      st.currentAnalysisFen = fen;

      // Only clear arrows if not analyzing
      if (!st.isAnalyzing) {
        clearArrow(boardId);
      }

      const statusEl = document.getElementById(`engine-status-${boardId}`);
      if (statusEl) statusEl.textContent = 'Analyzing…';

      // Clear previous analysis
      const bestMoveEl = document.getElementById(`best-move-${boardId}`);
      const evalEl = document.getElementById(`engine-eval-${boardId}`);
      if (bestMoveEl) bestMoveEl.textContent = 'Best: --';
      if (evalEl) {
        evalEl.textContent = '+0.0';
        evalEl.className = 'eval-display eval-neutral';
      }

      // Stop any ongoing analysis and start new one
      st.engineWorker.worker.postMessage('stop');
      st.engineWorker.worker.postMessage(`position fen ${fen}`);
      st.engineWorker.worker.postMessage(`go depth ${st.analysisDepth}`);
      
      addNotification(boardId, `Analyzing position at depth ${st.analysisDepth}...`);
    }

    // Step 3: Collect MultiPV ONLY at final depth
    function processAnalysisInfo(boardId, line) {
      const st = boardsState[boardId];
      // FIX 1: Remove isAnalyzing guard - CRITICAL FIX
      if (!st) return;

      const depthMatch = line.match(/depth (\d+)/);
      const multiPvMatch = line.match(/multipv (\d+)/);
      const pvMatch = line.match(/pv (.+)$/);
      const scoreMatch = line.match(/score cp (-?\d+)/);
      const mateMatch = line.match(/score mate (-?\d+)/);

      if (!depthMatch || !multiPvMatch || !pvMatch) return;

      const depth = Number(depthMatch[1]);
      // IMPORTANT: Only collect data at final depth to avoid flicker
      if (depth !== st.analysisDepth) return;

      const idx = Number(multiPvMatch[1]) - 1;
      const firstMove = pvMatch[1].split(' ')[0];

      let score = 0;
      let isMate = false;
      if (scoreMatch) {
        score = Number(scoreMatch[1]) / 100;
      } else if (mateMatch) {
        const mateIn = Number(mateMatch[1]);
        score = mateIn > 0 ? 100 : -100;
        st.currentMateScore = mateIn;
        isMate = true;
      }

      st.multiPV[idx] = { 
        uci: firstMove, 
        score: score,
        isMate: isMate,
        pv: pvMatch[1].split(' ').slice(0, 3) // Store first 3 moves for variation
      };
    }

    // Step 4: When bestmove arrives → finalize analysis
    function processBestMove(boardId, line) {
      const st = boardsState[boardId];
      if (!st) return;

      st.isAnalyzing = false;

      const statusEl = document.getElementById(`engine-status-${boardId}`);
      if (statusEl) statusEl.textContent = 'Idle';

      // Extract the actual best move
      const match = line.match(/bestmove (\S+)/);
      if (match && match[1] !== '0000') {
        st.bestMoveUCI = match[1];
      }

      // Finalize the analysis with all collected data
      finalizeAnalysis(boardId);
      
      addNotification(boardId, 'Analysis complete');
    }

    // Step 5: Finalize: SAN, arrows, explanations
    function finalizeAnalysis(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.multiPV || st.multiPV.length === 0) return;

      // Filter and sort by score (best first)
      const top = st.multiPV
        .filter(pv => pv && pv.uci && pv.uci.length >= 4)
        .sort((a, b) => b.score - a.score)
        .slice(0, 2); // Get top 2 moves

      if (top.length === 0) return;

      // FIX 3: Use correct FEN for SAN conversion
      let fenForSan = st.currentAnalysisFen;
      if (!fenForSan && st.moveQualityHistory.length > 0) {
        fenForSan = st.moveQualityHistory[st.moveQualityHistory.length - 1].fen;
      }
      if (!fenForSan) {
        fenForSan = st.game.fen();
      }
      
      const tempGame = new Chess(fenForSan);
      const sanMoves = top.map(pv => formatUCIToSan(pv.uci, tempGame));

      // Update evaluation display
      st.evalScore = top[0].score;
      updateEvalDisplay(boardId, top[0].score);

      // Display best moves
      const bestMoveEl = document.getElementById(`best-move-${boardId}`);
      if (bestMoveEl) {
        if (sanMoves.length === 1) {
          bestMoveEl.textContent = `Best: ${sanMoves[0]}`;
        } else {
          bestMoveEl.innerHTML = `Best: <span class="multi-pv-move best">${sanMoves[0]}</span><span class="multi-pv-move second-best">${sanMoves[1]}</span>`;
        }
      }

      // FIX 4: Reinitialize arrow overlay before drawing
      initArrowOverlay(boardId);

      // Draw arrows for top 2 moves with delay (FIX 3)
      if (top[0]) {
        setTimeout(() => {
          drawArrow(boardId, {
            from: top[0].uci.slice(0, 2),
            to: top[0].uci.slice(2, 4),
            color: '#10b981', // Green for best move
            width: 3,
            opacity: 0.8
          });
        }, 80);
      }

      if (top[1]) {
        setTimeout(() => {
          drawArrow(boardId, {
            from: top[1].uci.slice(0, 2),
            to: top[1].uci.slice(2, 4),
            color: '#3b82f6', // Blue for second best
            width: 2,
            opacity: 0.6
          });
        }, 80);
      }

      // Show move explanation
      if (top[0]) {
        explainMove(boardId, top[0].score);
      }

      // Store analysis for the analysis grid
      const history = st.game.history();
      if (history.length > 0) {
        const currentMoveIndex = history.length - 1;
        const side = currentMoveIndex % 2 === 0 ? 'white' : 'black';
        
        if (!st.moveQualityHistory) st.moveQualityHistory = [];
        
        // Calculate CPL for the last move
        const cpl = st.previousEvalScore !== undefined ? 
          calculateCPL(st.previousEvalScore, st.evalScore, side) : 0;
        
        const classification = classifyMoveByCPL(cpl);
        
        st.moveQualityHistory.push({
          moveNumber: Math.ceil((currentMoveIndex + 1) / 2),
          move: history[currentMoveIndex],
          cpl: cpl,
          classification: classification,
          player: side,
          fen: st.game.fen()
        });
        
        // Update previous eval for next analysis
        st.previousEvalScore = st.evalScore;
        
        // Update analysis grid
        updateAnalysisGrid(boardId);
      }
    }

    function updateEvalDisplay(boardId, evaluation) {
      const evalEl = document.getElementById(`engine-eval-${boardId}`);
      if (!evalEl) return;
      
      let evalText = '';
      let isMate = false;
      
      if (Math.abs(evaluation) > 100) {
        // Mate score
        const mateIn = evaluation > 0 ? Math.ceil((100 - evaluation)) : Math.ceil((-100 - evaluation));
        evalText = evaluation > 0 ? `+M${mateIn}` : `-M${mateIn}`;
        isMate = true;
      } else {
        // Normal score
        if (evaluation > 0) {
          evalText = `+${evaluation.toFixed(1)}`;
        } else if (evaluation < 0) {
          evalText = evaluation.toFixed(1);
        } else {
          evalText = '0.0';
        }
      }
      
      evalEl.textContent = evalText;
      
      if (isMate) {
        evalEl.className = 'eval-display eval-positive';
      } else if (evaluation > 1.0) {
        evalEl.className = 'eval-display eval-positive';
      } else if (evaluation < -1.0) {
        evalEl.className = 'eval-display eval-negative';
      } else {
        evalEl.className = 'eval-display eval-neutral';
      }
    }

    // ---------- MOVE QUALITY ANALYSIS ----------
    function calculateCPL(prevEval, newEval, side) {
      // side = 'white' or 'black'
      const sign = side === 'white' ? 1 : -1;
      const loss = Math.max(0, Math.round((prevEval - newEval) * sign * 100));
      return loss;
    }

    function classifyMoveByCPL(cpl) {
      if (cpl >= 300) return 'blunder';
      if (cpl >= 100) return 'mistake';
      if (cpl >= 50) return 'inaccuracy';
      return 'good';
    }

    // ---------- FIX 2: IMPROVED SAN CONVERSION ----------
    function formatUCIToSan(uci, game) {
      if (!uci || uci.length < 4) return uci;

      try {
        const temp = new Chess(game.fen());
        const move = temp.move({
          from: uci.slice(0,2),
          to: uci.slice(2,4),
          promotion: uci.slice(4) || undefined
        });
        return move ? move.san : uci;
      } catch {
        return uci;
      }
    }

    // ---------- ENHANCED MOVE EXPLANATION WITH DETECTORS ----------
    function explainMove(boardId, evalScore) {
      const st = boardsState[boardId];
      if (!st || !st.game) return;

      const history = st.game.history();
      if (history.length === 0) return;

      const currentMoveIndex = history.length - 1;
      const side = currentMoveIndex % 2 === 0 ? 'white' : 'black';
      const prevEval = st.previousEvalScore !== undefined ? st.previousEvalScore : 0;
      
      const cpl = calculateCPL(prevEval, evalScore, side);
      const classification = classifyMoveByCPL(cpl);
      
      let explanation = '';
      
      // Detector 1: Missed mate
      const hadMate = st.previousMateScore !== null && Math.abs(st.previousMateScore) <= 3;
      const lostMate = hadMate && st.currentMateScore === null;
      
      if (hadMate && lostMate) {
        updateMoveQualityDisplay(boardId, {
          classification: 'blunder',
          cpl: 999,
          explanation: 'Missed a forced mate.'
        });
        return;
      }
      
      // Detector 2: Hanging piece
      const sideToMove = st.game.turn() === 'w' ? 'black' : 'white';
      const hanging = detectHangingPieces(st.game, sideToMove);
      
      if (hanging.length > 0 && cpl >= 100) {
        const piece = hanging[0];
        const pieceName = { p:'pawn', n:'knight', b:'bishop', r:'rook', q:'queen', k:'king' }[piece.piece];
        explanation = `Leaves the ${pieceName} on ${piece.square} undefended.`;
      }
      
      // Detector 3: Allowed strong threat
      if (!explanation && cpl >= 200) {
        if (hanging.length > 0) {
          explanation = 'Allows a tactical capture.';
        } else {
          explanation = 'Allows a strong tactical threat.';
        }
      }
      
      // CPL-based classification (fallback)
      if (!explanation) {
        switch (classification) {
          case 'blunder':
            explanation = 'Loses decisive material or allows a winning tactic.';
            break;
          case 'mistake':
            explanation = 'Significantly worsens the position.';
            break;
          case 'inaccuracy':
            explanation = 'Misses a stronger continuation.';
            break;
          case 'good':
            if (Math.abs(evalScore) > 2.0) {
              explanation = 'Very strong move that maintains a significant advantage.';
            } else if (Math.abs(evalScore) > 1.0) {
              explanation = 'Good move that maintains an advantage.';
            } else {
              explanation = 'Solid move with no tactical issues.';
            }
            break;
        }
      }

      updateMoveQualityDisplay(boardId, {
        classification: classification,
        cpl: cpl,
        explanation: explanation
      });
    }

    // Hanging piece detector
    function detectHangingPieces(game, side) {
      const hanging = [];
      const board = game.board();

      for (let rank = 0; rank < 8; rank++) {
        for (let file = 0; file < 8; file++) {
          const piece = board[rank][file];
          if (!piece || piece.color !== side[0]) continue;

          const square = String.fromCharCode(97 + file) + (8 - rank);

          const attackers = game.attackers(square, side === 'white' ? 'b' : 'w');
          const defenders = game.attackers(square, side[0]);

          if (attackers.length > 0 && defenders.length === 0) {
            hanging.push({
              square,
              piece: piece.type
            });
          }
        }
      }
      return hanging;
    }

    function updateMoveQualityDisplay(boardId, quality) {
      let qualityEl = document.getElementById(`move-quality-${boardId}`);
      let explanationEl = document.getElementById(`move-explanation-${boardId}`);
      
      if (!qualityEl) {
        const enginePanel = document.querySelector(`[data-student-id="${boardId}"] .engine-panel`);
        if (enginePanel) {
          // Create quality display
          qualityEl = document.createElement('span');
          qualityEl.id = `move-quality-${boardId}`;
          qualityEl.className = 'move-quality-display';
          qualityEl.style.marginLeft = '8px';
          enginePanel.appendChild(qualityEl);
          
          // Create explanation tooltip
          explanationEl = document.createElement('div');
          explanationEl.id = `move-explanation-${boardId}`;
          explanationEl.className = 'move-explanation';
          enginePanel.appendChild(explanationEl);
        }
      } else {
        explanationEl = document.getElementById(`move-explanation-${boardId}`);
      }
      
      if (qualityEl) {
        let bgColor, textColor, text;
        switch (quality.classification) {
          case 'blunder':
            bgColor = '#fecaca'; textColor = '#991b1b'; text = 'Blunder'; break;
          case 'mistake':
            bgColor = '#fed7aa'; textColor = '#92400e'; text = 'Mistake'; break;
          case 'inaccuracy':
            bgColor = '#fef3c7'; textColor = '#92400e'; text = 'Inaccuracy'; break;
          default:
            bgColor = '#d1fae5'; textColor = '#065f46'; text = 'Good'; break;
        }
        
        qualityEl.textContent = `${text} (${quality.cpl}cp)`;
        qualityEl.style.backgroundColor = bgColor;
        qualityEl.style.color = textColor;
        
        if (explanationEl && quality.explanation) {
          explanationEl.textContent = quality.explanation;
        }
      }
    }

    function updateAnalysisGrid(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const whiteStatsEl = document.getElementById(`white-stats-${boardId}`);
      const blackStatsEl = document.getElementById(`black-stats-${boardId}`);
      const moveHistoryEl = document.getElementById(`move-history-${boardId}`);
      
      if (!whiteStatsEl || !blackStatsEl || !moveHistoryEl) return;
      
      // Show current evaluation if no moves analyzed yet
      if (!st.moveQualityHistory || st.moveQualityHistory.length === 0) {
        const whiteEval = st.evalScore > 0 ? st.evalScore : 0;
        const blackEval = st.evalScore < 0 ? -st.evalScore : 0;
        
        whiteStatsEl.innerHTML = `
          <div>Accuracy: --%</div>
          <div>Avg CPL: --</div>
          <div>Current Eval: <span style="color:#059669">${whiteEval.toFixed(2)}</span></div>
        `;
        blackStatsEl.innerHTML = `
          <div>Accuracy: --%</div>
          <div>Avg CPL: --</div>
          <div>Current Eval: <span style="color:#059669">${blackEval.toFixed(2)}</span></div>
        `;
        return;
      }
      
      // Calculate statistics
      const whiteMoves = st.moveQualityHistory.filter(m => m.player === 'white');
      const blackMoves = st.moveQualityHistory.filter(m => m.player === 'black');
      
      // White stats
      if (whiteMoves.length > 0) {
        const whiteAvgCPL = Math.round(whiteMoves.reduce((sum, m) => sum + m.cpl, 0) / whiteMoves.length);
        const whiteBlunders = whiteMoves.filter(m => m.classification === 'blunder').length;
        const whiteMistakes = whiteMoves.filter(m => m.classification === 'mistake').length;
        const whiteInaccuracies = whiteMoves.filter(m => m.classification === 'inaccuracy').length;
        const whiteAccuracy = whiteMoves.length > 0 ? 
          Math.round((whiteMoves.filter(m => m.classification === 'good').length / whiteMoves.length) * 100) : 0;
        
        whiteStatsEl.innerHTML = `
          <div>Accuracy: ${whiteAccuracy}%</div>
          <div>Avg CPL: ${whiteAvgCPL}</div>
          <div>Blunders: <span style="color:#dc2626">${whiteBlunders}</span></div>
          <div>Mistakes: <span style="color:#ea580c">${whiteMistakes}</span></div>
          <div>Inaccuracies: <span style="color:#ca8a04">${whiteInaccuracies}</span></div>
        `;
      } else {
        whiteStatsEl.innerHTML = `
          <div>Accuracy: --%</div>
          <div>Avg CPL: --</div>
          <div>No moves analyzed</div>
        `;
      }
      
      // Black stats
      if (blackMoves.length > 0) {
        const blackAvgCPL = Math.round(blackMoves.reduce((sum, m) => sum + m.cpl, 0) / blackMoves.length);
        const blackBlunders = blackMoves.filter(m => m.classification === 'blunder').length;
        const blackMistakes = blackMoves.filter(m => m.classification === 'mistake').length;
        const blackInaccuracies = blackMoves.filter(m => m.classification === 'inaccuracy').length;
        const blackAccuracy = blackMoves.length > 0 ? 
          Math.round((blackMoves.filter(m => m.classification === 'good').length / blackMoves.length) * 100) : 0;
        
        blackStatsEl.innerHTML = `
          <div>Accuracy: ${blackAccuracy}%</div>
          <div>Avg CPL: ${blackAvgCPL}</div>
          <div>Blunders: <span style="color:#f87171">${blackBlunders}</span></div>
          <div>Mistakes: <span style="color:#fb923c">${blackMistakes}</span></div>
          <div>Inaccuracies: <span style="color:#fbbf24">${blackInaccuracies}</span></div>
        `;
      } else {
        blackStatsEl.innerHTML = `
          <div>Accuracy: --%</div>
          <div>Avg CPL: --</div>
          <div>No moves analyzed</div>
        `;
      }
      
      // Update move history
      moveHistoryEl.innerHTML = `
        <div style="display: grid; grid-template-columns: 40px 60px 80px 60px 60px; gap: 8px; padding: 4px 0; border-bottom: 1px solid #f3f4f6; font-weight: bold;">
          <div>Move</div>
          <div>Player</div>
          <div>Move</div>
          <div>CPL</div>
          <div>Type</div>
        </div>
      `;
      
      st.moveQualityHistory.forEach((move, index) => {
        const row = document.createElement('div');
        row.style.cssText = 'display: grid; grid-template-columns: 40px 60px 80px 60px 60px; gap: 8px; padding: 4px 0; border-bottom: 1px solid #f3f4f6;';
        
        let typeColor;
        switch (move.classification) {
          case 'blunder': typeColor = '#dc2626'; break;
          case 'mistake': typeColor = '#ea580c'; break;
          case 'inaccuracy': typeColor = '#ca8a04'; break;
          default: typeColor = '#16a34a'; break;
        }
        
        row.innerHTML = `
          <div>${move.moveNumber}${move.player === 'white' ? '. ' : '...'}</div>
          <div>${move.player === 'white' ? 'White' : 'Black'}</div>
          <div>${move.move}</div>
          <div>${move.cpl}</div>
          <div style="color: ${typeColor}">${move.classification}</div>
        `;
        
        moveHistoryEl.appendChild(row);
      });
    }

    // ---------- ARROW FUNCTIONS ----------
    function initArrowOverlay(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const arrowOverlay = document.getElementById(`arrows_${boardId}`);
      if (!arrowOverlay) return;
      
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.className = 'arrow-svg';
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '10';
      
      arrowOverlay.innerHTML = '';
      arrowOverlay.appendChild(svg);
      st.arrowSvg = svg;
    }

    function drawArrow(boardId, arrow) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      
      const boardEl = document.getElementById(`board_${boardId}`);
      if (!boardEl) return;
      
      const boardRect = boardEl.getBoundingClientRect();
      const squareSize = boardRect.width / 8;
      
      const fromSquare = arrow.from.toLowerCase();
      const toSquare = arrow.to.toLowerCase();
      
      if (fromSquare.length !== 2 || toSquare.length !== 2) return;
      
      const fromFile = fromSquare.charCodeAt(0) - 97;
      const fromRank = parseInt(fromSquare.charAt(1)) - 1;
      const toFile = toSquare.charCodeAt(0) - 97;
      const toRank = parseInt(toSquare.charAt(1)) - 1;
      
      let x1, y1, x2, y2;
      if (st.flip) {
        x1 = (7 - fromFile) * squareSize + squareSize / 2;
        y1 = fromRank * squareSize + squareSize / 2;
        x2 = (7 - toFile) * squareSize + squareSize / 2;
        y2 = toRank * squareSize + squareSize / 2;
      } else {
        x1 = fromFile * squareSize + squareSize / 2;
        y1 = (7 - fromRank) * squareSize + squareSize / 2;
        x2 = toFile * squareSize + squareSize / 2;
        y2 = (7 - toRank) * squareSize + squareSize / 2;
      }
      
      // Create a new arrow element
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', arrow.color);
      line.setAttribute('stroke-width', arrow.width || 3);
      line.setAttribute('stroke-opacity', arrow.opacity || 0.8);
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('marker-end', `url(#arrowhead-${boardId}-${arrow.color.replace('#', '')})`);
      
      // Create marker if it doesn't exist
      let markerId = `arrowhead-${boardId}-${arrow.color.replace('#', '')}`;
      if (!st.arrowSvg.querySelector(`#${markerId}`)) {
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        marker.setAttribute('id', markerId);
        marker.setAttribute('markerWidth', '10');
        marker.setAttribute('markerHeight', '7');
        marker.setAttribute('refX', '9');
        marker.setAttribute('refY', '3.5');
        marker.setAttribute('orient', 'auto');
        
        const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
        polygon.setAttribute('fill', arrow.color);
        
        marker.appendChild(polygon);
        defs.appendChild(marker);
        st.arrowSvg.appendChild(defs);
      }
      
      st.arrowSvg.appendChild(line);
    }

    function clearArrow(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      st.arrowSvg.innerHTML = '';
    }

    function initEngineAndBoard(studentId){
      const st = boardsState[studentId];
      if(!st) return;
      try{ 
        st.game = new Chess();
      }catch(e){ 
        console.warn('Chess engine init failed:', e);
        st.game = null;
      }
      try{
        if (window.Chessboard && window.Chessboard !== 'undefined') {
          st.boardObj = Chessboard('board_' + studentId, {
            draggable: false,
            position: 'start',
            pieceTheme: st.pieceTheme
          });
          console.log(`✅ Chessboard initialized for ${studentId}`);
        } else {
          console.error('❌ Chessboard.js not loaded for', studentId);
          const boardDiv = document.getElementById('board_' + studentId);
          if (boardDiv) {
            boardDiv.innerHTML = '<div class="board-placeholder">Chessboard failed to load. Please refresh.</div>';
          }
        }
      }catch(e){ 
        console.error('Chessboard init failed', e);
        const boardDiv = document.getElementById('board_' + studentId);
        if (boardDiv) {
          boardDiv.innerHTML = '<div class="board-placeholder">Chessboard error: ' + e.message + '</div>';
        }
      }
      setBoardSize(studentId, st.size);
      initArrowOverlay(studentId);
      updateWatchModeButtons(studentId);
    }

    function setBoardSize(boardId, px){
      const st = boardsState[boardId];
      if(!st) return;
      const div = document.getElementById('board_' + boardId);
      if(!div) return;
      const holder = div.parentElement;
      if(holder){ 
        holder.style.width = px + 'px'; 
        holder.style.height = px + 'px'; 
      }
      try{ 
        if(st.boardObj && typeof st.boardObj.resize === 'function') 
          st.boardObj.resize(); 
      }catch(e){}
    }

    // ---------- MULTI-WATCH FUNCTIONS ----------
    function updateWatchModeButtons(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const card = document.querySelector(`.board-card[data-student-id="${boardId}"]`);
      if (!card) return;
      
      const singleBtn = card.querySelector('.watch-single');
      const whiteBtn = card.querySelector('.watch-white');
      const blackBtn = card.querySelector('.watch-black');
      
      if (singleBtn) singleBtn.classList.toggle('active', st.watchMode === WATCH_MODES.SINGLE);
      if (whiteBtn) whiteBtn.classList.toggle('active', st.watchMode === WATCH_MODES.MULTI_WHITE);
      if (blackBtn) blackBtn.classList.toggle('active', st.watchMode === WATCH_MODES.MULTI_BLACK);
    }

    function setWatchMode(boardId, mode) {
      const st = boardsState[boardId];
      if (!st) return;
      
      st.watchMode = mode;
      updateWatchModeButtons(boardId);
      
      // Update the player select based on mode
      const playerSelect = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if (playerSelect) {
        const selectedValue = playerSelect.value;
        
        if (mode === WATCH_MODES.SINGLE && st.whitePlayer && st.blackPlayer) {
          // In single mode, show combined option
          const whiteName = onlineMap[st.whitePlayer]?.email || st.whitePlayer;
          const blackName = onlineMap[st.blackPlayer]?.email || st.blackPlayer;
          
          // Create a special option showing both players
          playerSelect.innerHTML = '';
          const option = document.createElement('option');
          option.value = `${st.whitePlayer}|${st.blackPlayer}`;
          option.textContent = `${whiteName} vs ${blackName}`;
          option.selected = true;
          playerSelect.appendChild(option);
          
          // Restart watching with both players
          stopWatching(boardId);
          startWatchingGame(boardId, st.whitePlayer, st.blackPlayer);
        } else if (mode === WATCH_MODES.MULTI_WHITE && st.whitePlayer) {
          // Just watch white player
          playerSelect.value = st.whitePlayer;
          stopWatching(boardId);
          startWatching(boardId, st.whitePlayer);
        } else if (mode === WATCH_MODES.MULTI_BLACK && st.blackPlayer) {
          // Just watch black player
          playerSelect.value = st.blackPlayer;
          stopWatching(boardId);
          startWatching(boardId, st.blackPlayer);
        }
      }
    }

    // ---------- SINGLE AUTHORITATIVE PIPELINE ----------
    const CANDIDATE_PATHS = ['','game','move','moves'];

    function startWatching(boardId, clientId){
      const st = boardsState[boardId];
      if(!st) return;
      stopWatching(boardId); // teardown previous
      st.watchedClientId = clientId;
      st.whitePlayer = clientId; // Default to white
      st.blackPlayer = null;
      st.watchMode = WATCH_MODES.SINGLE;
      
      // Update UI
      updateBoardLabel(boardId);
      addNotification(boardId, `Start watching ${clientId}`);
      
      // Reset game state
      try{ st.game = new Chess(); } catch(e){ st.game = null; }
      if(st.boardObj) st.boardObj.position('start');
      updateNotation(boardId);

      // Attach listeners for each candidate path (SINGLE SOURCE OF TRUTH)
      st.listeners = {};
      CANDIDATE_PATHS.forEach(p => {
        const path = p ? `games/${clientId}/${p}` : `games/${clientId}`;
        const ref = db.ref(path);
        
        // value listener (captures whole node or fen)
        const onValue = snap => {
          const v = snap.val();
          if(!v) return;
          normalizeAndApply(boardId, v);
        };
        ref.on('value', onValue);

        // child_added for move streams
        const onChildAdded = snap => {
          const v = snap.val();
          if(p === 'moves' || typeof v === 'object'){
            const candidate = v && (v.payload || v);
            if(candidate && (candidate.move || candidate.fen || candidate.from)){
              normalizeAndApply(boardId, v);
            } else {
              // Fetch all moves in order
              ref.limitToLast(500).once('value').then(snap2 => {
                const ordered = {};
                snap2.forEach(child => ordered[child.key] = child.val());
                normalizeAndApply(boardId, { moves: ordered });
              }).catch(()=>{});
            }
          } else {
            normalizeAndApply(boardId, v);
          }
        };
        ref.on('child_added', onChildAdded);

        // child_changed - apply updates
        const onChildChanged = snap => {
          normalizeAndApply(boardId, snap.val());
        };
        ref.on('child_changed', onChildChanged);

        // save for teardown
        st.listeners[path] = { ref, handlers: { value: onValue, child_added: onChildAdded, child_changed: onChildChanged } };
      });

      // Also listen to moves/{clientId} for real-time move syncing
      try{
        const movesPath = `moves/${clientId}`;
        const movesRef = db.ref(movesPath);
        const onMoveAdded = snap => {
          const m = snap.val();
          if(!m) return;
          if(m.by === MASTER_ID) return;
          const candidate = m.payload || m;
          if(candidate && (candidate.move || candidate.fen)){
            normalizeAndApply(boardId, candidate);
          }
        };
        movesRef.on('child_added', onMoveAdded);
        st.listeners[movesPath] = { ref: movesRef, handlers: { child_added: onMoveAdded } };
      }catch(e){ console.error('Moves listener failed:', e); }

      // initial one-shot fetch
      try{
        const movesRef = db.ref(`games/${clientId}/moves`);
        movesRef.limitToLast(500).once('value').then(snap => {
          if(!snap.exists()) return;
          const ordered = {};
          snap.forEach(child => ordered[child.key] = child.val());
          normalizeAndApply(boardId, { moves: ordered });
        }).catch(()=>{});
      }catch(e){}

      // Start engine if not running
      if(!st.engineRunning) {
        setTimeout(() => toggleEngine(boardId), 1000);
      }
    }

    // New function to watch a complete game (both players)
    function startWatchingGame(boardId, whitePlayerId, blackPlayerId) {
      const st = boardsState[boardId];
      if(!st) return;
      
      stopWatching(boardId); // teardown previous
      st.whitePlayer = whitePlayerId;
      st.blackPlayer = blackPlayerId;
      st.watchedClientId = `${whitePlayerId}|${blackPlayerId}`;
      st.watchMode = WATCH_MODES.SINGLE;
      
      // Update UI
      updateBoardLabel(boardId);
      addNotification(boardId, `Watching game: ${whitePlayerId} (White) vs ${blackPlayerId} (Black)`);
      
      // Reset game state
      try{ st.game = new Chess(); } catch(e){ st.game = null; }
      if(st.boardObj) st.boardObj.position('start');
      updateNotation(boardId);

      // Listen to both players' moves
      st.listeners = {};
      
      // Function to handle moves from either player
      const handlePlayerMove = (playerId, moveData) => {
        if (!moveData) return;
        
        // Extract the move
        const candidate = moveData.payload || moveData;
        if (candidate && (candidate.move || candidate.fen)) {
          // Apply the move to our local game
          normalizeAndApply(boardId, candidate);
        }
      };

      // Watch white player
      const whiteMovesRef = db.ref(`moves/${whitePlayerId}`);
      const onWhiteMove = snap => {
        const m = snap.val();
        if (!m || m.by === MASTER_ID) return;
        handlePlayerMove(whitePlayerId, m);
      };
      whiteMovesRef.on('child_added', onWhiteMove);
      st.listeners[`white_${whitePlayerId}`] = { ref: whiteMovesRef, handlers: { child_added: onWhiteMove } };

      // Watch black player
      const blackMovesRef = db.ref(`moves/${blackPlayerId}`);
      const onBlackMove = snap => {
        const m = snap.val();
        if (!m || m.by === MASTER_ID) return;
        handlePlayerMove(blackPlayerId, m);
      };
      blackMovesRef.on('child_added', onBlackMove);
      st.listeners[`black_${blackPlayerId}`] = { ref: blackMovesRef, handlers: { child_added: onBlackMove } };

      // Also watch their game states
      [whitePlayerId, blackPlayerId].forEach(playerId => {
        CANDIDATE_PATHS.forEach(p => {
          const path = p ? `games/${playerId}/${p}` : `games/${playerId}`;
          const ref = db.ref(path);
          
          const onValue = snap => {
            const v = snap.val();
            if(!v) return;
            normalizeAndApply(boardId, v);
          };
          ref.on('value', onValue);
          st.listeners[`game_${playerId}_${p}`] = { ref, handlers: { value: onValue } };
        });
      });

      // Load initial moves from both players
      try{
        const loadPlayerMoves = (playerId) => {
          const movesRef = db.ref(`games/${playerId}/moves`);
          movesRef.limitToLast(500).once('value').then(snap => {
            if(!snap.exists()) return;
            const ordered = {};
            snap.forEach(child => ordered[child.key] = child.val());
            normalizeAndApply(boardId, { moves: ordered, player: playerId });
          }).catch(()=>{});
        };
        
        loadPlayerMoves(whitePlayerId);
        setTimeout(() => loadPlayerMoves(blackPlayerId), 500);
      }catch(e){}

      // Start engine if not running
      if(!st.engineRunning) {
        setTimeout(() => toggleEngine(boardId), 1000);
      }
    }

    function stopWatching(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      
      // Stop engine
      if(st.engineRunning) {
        toggleEngine(boardId); // This will stop the engine
      }
      
      // Clean up Firebase listeners
      try{
        Object.keys(st.listeners || {}).forEach(path => {
          const L = st.listeners[path];
          if(L && L.ref && L.handlers){
            if(L.handlers.value) L.ref.off('value', L.handlers.value);
            if(L.handlers.child_added) L.ref.off('child_added', L.handlers.child_added);
            if(L.handlers.child_changed) L.ref.off('child_changed', L.handlers.child_changed);
          }
        });
      }catch(e){}
      
      st.listeners = {};
      st.watchedClientId = null;
      st.whitePlayer = null;
      st.blackPlayer = null;
      updateBoardLabel(boardId);
      addNotification(boardId, 'Stopped watching');
      clearNotation(boardId);
      
      // Reset board
      try{ if(st.game && typeof st.game.load === 'function'){ st.game.load('start'); } 
        if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position('start'); 
      }catch(e){}
      
      // Update UI
      const card = document.querySelector(`.board-card[data-student-id="${boardId}"]`);
      if (card) {
        const playerSelect = card.querySelector(`.player-select[data-sid="${boardId}"]`);
        if (playerSelect) {
          playerSelect.value = '';
        }
      }
    }

    // ---------- NORMALIZE AND APPLY (ORIGINAL ROBUST VERSION) ----------
    function normalizeAndApply(boardId, record){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st) return;
      try{
        if(record === null || typeof record === 'undefined'){ return; }
        if(typeof record === 'string'){ applyFenToBoard(boardId, record); return; }
        if(record.payload && typeof record.payload === 'object') record = record.payload;

        if(record.moves && typeof record.moves === 'object' && Object.keys(record.moves).length > 0){
          applyMovesChildList(boardId, record.moves);
          return;
        }

        const fenCandidates = ['fen','FEN','sfen','currentFen','position','board_fen','board'];
        for(const k of fenCandidates){ 
          if(record[k] && typeof record[k] === 'string'){ 
            applyFenToBoard(boardId, record[k]); 
            return; 
          } 
        }

        if(record.move){ 
          tryApplyMoveShape(boardId, record.move, record.fen || null); 
          return; 
        }

        const directMoveFields = ['lastMove','last_move','last','moveString','move_uci','uci','from','to'];
        for(const k of directMoveFields){ 
          if(record[k]){ 
            tryApplyMoveShape(boardId, record, record.fen || null); 
            return; 
          } 
        }

        const keys = Object.keys(record || {});
        for(let i = keys.length - 1; i >= 0; i--){
          const cand = record[keys[i]];
          if(cand && (cand.payload || cand.fen || cand.move || typeof cand === 'string')){ 
            normalizeAndApply(boardId, cand); 
            return; 
          }
        }
      }catch(e){ 
        addNotification(boardId, 'Normalize error: ' + (e && e.message)); 
      }
    }

    function applyMovesChildList(boardId, movesObj){
      const st = boardsState[boardId];
      if(!st) return;
      try{
        const entries = Object.keys(movesObj).map(k => {
          const rec = movesObj[k] || {};
          const payload = rec.payload || rec;
          const ts = rec.ts || (payload && payload.ts) || 0;
          return { key: k, ts: Number(ts) || 0, payload, raw: rec };
        });
        entries.sort((a,b) => (a.ts - b.ts) || (a.key < b.key ? -1 : (a.key > b.key ? 1 : 0)));
        
        try{ 
          st.game = new Chess(); 
        }catch(e){ 
          st.game = null; 
          return; 
        }
        
        for(const e of entries){
          const mv = (e.payload && e.payload.move) || e.payload;
          if(!mv) continue;
          
          if(typeof mv === 'string'){
            const s = mv.replace(/[^a-h1-8qnbrk]/ig,'');
            if(s.length >= 4){
              const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : undefined;
              if(st.game && typeof st.game.move === 'function') {
                try {
                  st.game.move({ from, to, promotion: prom || undefined });
                } catch(e) {}
                updateNotation(boardId);
              }
            }
          } else if(typeof mv === 'object' && mv.from && mv.to){
            if(st.game && typeof st.game.move === 'function') {
              try {
                st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
                updateNotation(boardId);
              } catch(e) {}
            }
          }
        }
        
        const pos = st.game && typeof st.game.fen === 'function' ? st.game.fen() : null;
        if(pos && st.boardObj && typeof st.boardObj.position === 'function'){
          st.boardObj.position(pos);
        }
        
        // FIX 2: Only clear arrows if not analyzing
        if (!st.isAnalyzing) {
          clearArrow(boardId);
          const bestMoveEl = document.getElementById(`best-move-${boardId}`);
          const evalEl = document.getElementById(`engine-eval-${boardId}`);
          if (bestMoveEl) bestMoveEl.textContent = 'Best: --';
          if (evalEl) {
            evalEl.textContent = '+0.0';
            evalEl.className = 'eval-display eval-neutral';
          }
        }
        
      }catch(e){ 
        addNotification(boardId, 'Apply moves error: ' + (e && e.message)); 
      }
    }

    function tryApplyMoveShape(boardId, m, fallbackFen){
      const st = boardsState[boardId];
      if(!st) return false;
      try{
        if(!m) return false;
        if(typeof m === 'string'){
          const s = m.replace(/[^a-h1-8qnbrk]/ig,'');
          if(s.length >= 4){ 
            const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : null; 
            applyMoveToBoard(boardId, { from, to, promotion: prom }, fallbackFen); 
            return true; 
          }
          const m2 = m.match(/([a-h][1-8]).*?([a-h][1-8])/i);
          if(m2){ 
            applyMoveToBoard(boardId, { from: m2[1], to: m2[2] }, fallbackFen); 
            return true; 
          }
          return false;
        }
        if(typeof m === 'object'){
          const from = m.from || m.f || (m.u && m.u.slice(0,2));
          const to = m.to || m.t || (m.u && m.u.slice(2,4));
          const promotion = m.promotion || m.prom || null;
          if(from && to){ 
            applyMoveToBoard(boardId, { from, to, promotion }, fallbackFen); 
            return true; 
          }
          if(m.payload) return tryApplyMoveShape(boardId, m.payload, fallbackFen);
        }
        return false;
      }catch(e){ 
        addNotification(boardId, 'Apply move shape error: ' + (e && e.message)); 
        return false; 
      }
    }

    function applyFenToBoard(boardId, fen){
      const st = boardsState[boardId];
      if(!st || !fen) return;
      try{
        if(st.game && typeof st.game.load === 'function'){ 
          st.game.load(fen); 
          if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen()); 
          updateNotation(boardId);
        }
        else if(st.boardObj && typeof st.boardObj.position === 'function'){ 
          st.boardObj.position(fen); 
        }
      }catch(e){ 
        addNotification(boardId, 'Apply FEN error: ' + (e && e.message)); 
      }
    }

    function applyMoveToBoard(boardId, mv, fallbackFen){
      const st = boardsState[boardId];
      if(!st || !mv || !mv.from || !mv.to) return;
      try{
        if(st.game && typeof st.game.move === 'function'){
          const applied = st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
          if(applied === null){
            if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
            return;
          } else {
            if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen());
            updateNotation(boardId);
          }
        } else {
          if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
        }
      }catch(e){ 
        addNotification(boardId, 'Apply move error: ' + (e && e.message)); 
      }
    }

    // ---------- ENGINE TOGGLE FUNCTION ----------
    function toggleEngine(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const toggleBtn = document.getElementById(`engine-toggle-${boardId}`);
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      
      if (!st.engineRunning) {
        // Start engine
        addNotification(boardId, 'Starting Stockfish 17.1 Lite...');
        
        st.engineWorker = createStockfishWorker(boardId);
        if (st.engineWorker) {
          st.engineRunning = true;
          
          if (toggleBtn) {
            toggleBtn.textContent = 'Stockfish: ON';
            toggleBtn.className = 'engine-btn engine-btn-stop';
          }
          if (statusEl) {
            statusEl.textContent = 'Loading...';
            statusEl.style.color = '#f59e0b';
          }
          
        } else {
          addNotification(boardId, 'Failed to start Stockfish');
          if (toggleBtn) toggleBtn.textContent = 'Stockfish: OFF';
          if (statusEl) statusEl.textContent = 'Load failed';
        }
        
      } else {
        // Stop engine
        st.engineRunning = false;
        st.isAnalyzing = false;
        
        if (st.engineWorker) {
          st.engineWorker.terminate();
          st.engineWorker = null;
        }
        
        if (toggleBtn) {
          toggleBtn.textContent = 'Stockfish: OFF';
          toggleBtn.className = 'engine-btn';
        }
        if (statusEl) {
          statusEl.textContent = 'Idle';
          statusEl.style.color = '#666';
        }
        
        // Clear analysis display
        const bestMoveEl = document.getElementById(`best-move-${boardId}`);
        const evalEl = document.getElementById(`engine-eval-${boardId}`);
        if (bestMoveEl) bestMoveEl.textContent = 'Best: --';
        if (evalEl) {
          evalEl.textContent = '+0.0';
          evalEl.className = 'eval-display eval-neutral';
        }
        
        clearArrow(boardId);
        
        addNotification(boardId, 'Stockfish stopped');
      }
    }

    // ---------- PRESENCE & ONLINE UPDATES ----------
    onlineRef.on('value', snap => {
      const val = snap.val() || {};
      for(const k in onlineMap) delete onlineMap[k];
      for(const id in val){ 
        if(!val.hasOwnProperty(id)) continue; 
        onlineMap[id] = { email: val[id].email || id, role: val[id].role || null, ts: val[id].ts || Date.now() }; 
      }
      STUDENTS.forEach(s => populateSelectForBoard(s.id));
      STUDENTS.forEach(s => refreshBadge(s.id));
    });

    // Publish master presence
    try{
      const n = onlineRef.child(MASTER_ID);
      n.set({ email: MASTER_NAME, role: 'master', ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
      n.onDisconnect().remove();
      setInterval(()=> n.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
    }catch(e){}

    // ---------- UI UPDATE FUNCTIONS ----------
    function populateSelectForBoard(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(!sel) return;
      const prev = sel.value;
      sel.innerHTML = '';
      const title = document.createElement('option'); title.value=''; title.textContent='Select student or game'; sel.appendChild(title);

      const onlineIds = Object.keys(onlineMap).filter(id => id !== MASTER_ID);
      if(onlineIds.length === 0){
        const none = document.createElement('option'); none.value=''; none.disabled=true; none.textContent='No online students'; sel.appendChild(none); sel.value=''; return;
      }
      
      // First, add individual students
      onlineIds.forEach(id => { 
        const opt = document.createElement('option'); 
        opt.value = id; 
        opt.textContent = `${onlineMap[id].email} (${id.slice(0,6)})`; 
        sel.appendChild(opt); 
      });
      
      // Add separator
      const separator = document.createElement('option');
      separator.disabled = true;
      separator.textContent = '───────── GAMES ─────────';
      sel.appendChild(separator);
      
      // Create game pairs (all possible combinations of online students)
      for(let i = 0; i < onlineIds.length; i++) {
        for(let j = i + 1; j < onlineIds.length; j++) {
          const whiteId = onlineIds[i];
          const blackId = onlineIds[j];
          const whiteName = onlineMap[whiteId]?.email || whiteId;
          const blackName = onlineMap[blackId]?.email || blackId;
          
          const gameOpt = document.createElement('option');
          gameOpt.value = `${whiteId}|${blackId}`;
          gameOpt.textContent = `🎲 ${whiteName} (W) vs ${blackName} (B)`;
          sel.appendChild(gameOpt);
        }
      }

      // Try to preserve selection
      if(prev && Array.from(sel.options).some(o => o.value === prev)) {
        sel.value = prev;
      } else {
        sel.value = '';
      }
    }

    function updateBoardLabel(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      
      const label = document.getElementById(`label-${boardId}`);
      const badgeHolder = label.querySelector('.badge-holder');
      const gameInfo = document.getElementById(`game-info-${boardId}`);
      
      badgeHolder.innerHTML = '';
      gameInfo.textContent = '';
      
      if(!st.watchedClientId) return;
      
      // Create online/offline badge
      const span = document.createElement('span');
      span.className = st.whitePlayer && onlineMap[st.whitePlayer] && st.blackPlayer && onlineMap[st.blackPlayer] 
        ? 'online-badge' 
        : 'offline-badge';
      span.textContent = st.whitePlayer && onlineMap[st.whitePlayer] && st.blackPlayer && onlineMap[st.blackPlayer] 
        ? 'online' 
        : 'offline';
      badgeHolder.appendChild(span);
      
      // Update game info
      if(st.whitePlayer && st.blackPlayer) {
        const whiteName = onlineMap[st.whitePlayer]?.email || st.whitePlayer;
        const blackName = onlineMap[st.blackPlayer]?.email || st.blackPlayer;
        gameInfo.innerHTML = `
          <span class="player-badge white">${whiteName}</span> 
          vs 
          <span class="player-badge black">${blackName}</span>
        `;
      } else if(st.whitePlayer) {
        const playerName = onlineMap[st.whitePlayer]?.email || st.whitePlayer;
        gameInfo.innerHTML = `<span class="player-badge white">${playerName} (White)</span>`;
      } else if(st.blackPlayer) {
        const playerName = onlineMap[st.blackPlayer]?.email || st.blackPlayer;
        gameInfo.innerHTML = `<span class="player-badge black">${playerName} (Black)</span>`;
      }
    }

    function refreshBadge(boardId){
      updateBoardLabel(boardId);
    }

    function addNotification(boardId, msg){
      const el = document.getElementById('notif_' + boardId);
      if(!el) return;
      const st = boardsState[boardId];
      if(st && st.lastNotif === msg) return;
      st.lastNotif = msg;
      const item = document.createElement('div');
      item.className = 'notif-item';
      item.textContent = `${new Date().toLocaleTimeString()} — ${msg}`;
      el.insertBefore(item, el.firstChild);
      while(el.children.length > 5) el.removeChild(el.lastChild);
    }

    function updateNotation(boardId){
      const st = boardsState[boardId];
      const notEl = document.getElementById('notation_' + boardId);
      if(!st || !notEl) return;
      try{
        if(!st.game || typeof st.game.history !== 'function'){ notEl.innerHTML = 'No moves.'; return; }
        const hist = st.game.history() || [];
        if(hist.length === 0){ notEl.innerHTML = 'No moves.'; return; }
        notEl.innerHTML = '';
        for(let i=0;i<hist.length;i+=2){
          const no = Math.floor(i/2)+1;
          const w = hist[i]||'';
          const b = hist[i+1]||'';
          const div = document.createElement('div');
          div.className = 'move';
          div.innerHTML = `<strong>${no}.</strong>&nbsp;${w}${ b ? ('\u00A0' + b) : '' }`;
          notEl.appendChild(div);
        }
      }catch(e){ console.warn('updateNotation error', e); }
    }
    
    function clearNotation(boardId){ 
      const notEl = document.getElementById('notation_' + boardId); 
      if(notEl) notEl.innerHTML = 'No moves.'; 
    }

    function getDebugElem(boardId){ 
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId); 
      if(!card) return null; 
      return card.querySelector('.debug'); 
    }

    // ---------- SETUP FIREBASE CONNECTION LISTENER ----------
    // Call this after Firebase is initialized
    setupFirebaseConnectionListener();

    // ---------- FIX 5: HARD LOGOUT ----------
    document.getElementById('globalLogout').addEventListener('click', async () => {
      try {
        await onlineRef.child(MASTER_ID).remove();
      } catch(e) {}

      try {
        firebase.database().goOffline();
      } catch(e) {}

      localStorage.clear();
      sessionStorage.clear();

      window.location.replace('index.html');
    });

    window.addEventListener('beforeunload', () => {
      try{ 
        onlineRef.child(MASTER_ID).remove().catch(()=>{}); 
      }catch(e){}
      STUDENTS.forEach(s => stopWatching(s.id));
      
      // Terminate all Stockfish workers
      for (const boardId in boardsState) {
        const st = boardsState[boardId];
        if (st && st.engineWorker) {
          try { st.engineWorker.terminate(); } catch(e) {}
        }
      }
    });

  })();
  </script>
</body>
</html>
