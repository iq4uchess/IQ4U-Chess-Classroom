<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Master — 4 Boards (List view)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    :root{ --card-gap:12px; --card-bg:#fff; --card-border:#ddd; --control-height:44px; font-family:Arial,Helvetica,sans-serif; color:#222;}
    html,body{ height:100%; margin:0; background:#f5f7fb; }
    .container{ margin:16px auto; max-width:1200px; padding-bottom:28px; }
    h1{ margin:0 0 12px 0; font-size:20px; }
    .boards-grid{ display:grid; grid-template-columns:1fr 1fr; gap:var(--card-gap); }
    .board-card{ background:var(--card-bg); border:1px solid var(--card-border); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:10px; min-height:140px; box-shadow:0 1px 3px rgba(20,30,40,0.05); }
    .top-strip{ display:flex; align-items:center; justify-content:center; gap:8px; height:var(--control-height); }
    .student-label{ font-weight:600; text-align:center; display:flex; align-items:center; gap:8px; justify-content:center; }
    .controls{ display:flex; gap:8px; align-items:center; }
    .controls select, .controls button, .controls input[type=range]{ height:32px; padding:4px 8px; border-radius:6px; border:1px solid #ccc; background:#fff; }
    .board-inner{ width:100%; display:flex; justify-content:center; }
    .board-holder{ box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff; }
    .debug{ font-family:monospace; font-size:12px; background:#fbfcfd; border:1px solid #eef2f6; padding:6px; border-radius:6px; max-height:80px; overflow:auto; }
    .footer-actions{ display:flex; justify-content:flex-end; margin-top:18px; gap:8px; }
    .btn-logout{ background:#ef4444; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    @media(max-width:900px){ .boards-grid{ grid-template-columns:1fr; padding:0 12px; } }
  </style>
</head>
<body>
  <div class="container">
    <h1>Master Dashboard — 4 Boards (List view)</h1>

    <div class="boards-grid" id="boardsGrid"></div>

    <div class="footer-actions">
      <button id="globalLogout" class="btn-logout">Logout</button>
    </div>
  </div>

  <!-- jQuery (required by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- chessboard.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
  (async function(){
    // ---------- CONFIG ----------
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasedestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb693d0736fe0da4bb"
    };
    try{ firebase.initializeApp(FIREBASE_CONFIG); }catch(e){}
    const db = firebase.database();
    const onlineRef = db.ref('online');

    const MASTER_ID = sessionStorage.getItem('iq4u_clientId') || ('m_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', MASTER_ID);
    const MASTER_NAME = localStorage.getItem('username') || localStorage.getItem('email') || 'master';

    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    const STUDENTS = [
      { id: 'student1', name: 'Student 1' },
      { id: 'student2', name: 'Student 2' },
      { id: 'student3', name: 'Student 3' },
      { id: 'student4', name: 'Student 4' }
    ];

    const onlineMap = {};   // clientId => {email, role, ts}
    const boardsState = {}; // per-board state

    // ---------- ensure chess.js loaded ----------
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    async function ensureChess(){
      if(typeof Chess !== 'undefined') return;
      try{
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        window.Chess = mod.default || mod.Chess || mod;
      }catch(e){}
      if(typeof Chess !== 'undefined') return;
      await new Promise(resolve=>{
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = true;
        s.onload = ()=> setTimeout(resolve, 10);
        s.onerror = ()=> resolve();
        document.head.appendChild(s);
      });
    }

    async function pickPieceTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const r = await fetch(test, { method:'HEAD', cache:'no-store' }); return r.ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // ---------- build UI (DOM only) ----------
    const grid = document.getElementById('boardsGrid');
    const theme = await pickPieceTheme();
    for(const s of STUDENTS){
      const card = createCard(s, theme);
      grid.appendChild(card);
    }

    // wait and then initialize engines & chessboards
    await ensureChess();
    for(const s of STUDENTS){
      initEngineAndBoard(s.id);
    }

    // presence -> populate selects + badges
    onlineRef.on('value', snap => {
      const val = snap.val() || {};
      for(const k in onlineMap) delete onlineMap[k];
      for(const id in val){ if(!val.hasOwnProperty(id)) continue; onlineMap[id] = { email: val[id].email || id, role: val[id].role || 'student', ts: val[id].ts || Date.now() }; }
      STUDENTS.forEach(s => populateSelectForBoard(s.id));
      STUDENTS.forEach(s => refreshBadge(s.id));
    });

    // publish master presence
    try{
      const n = onlineRef.child(MASTER_ID);
      n.set({ email: MASTER_NAME, role: 'master', ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
      n.onDisconnect().remove();
      setInterval(()=> n.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
    }catch(e){}

    // ---------- helpers: UI build ----------
    function createCard(student, pieceTheme){
      const card = document.createElement('div'); card.className = 'board-card'; card.dataset.studentId = student.id;

      const label = document.createElement('div'); label.className = 'student-label';
      label.innerHTML = `<span class="label-text">${student.name}</span><span class="badge-holder"></span><span class="path-holder" style="margin-left:8px;font-size:11px;color:#666"></span>`;
      card.appendChild(label);

      const top = document.createElement('div'); top.className = 'top-strip';
      top.innerHTML = `<div class="controls"><span class="label-small">Size</span>
        <input type="range" min="200" max="800" value="360" class="size-slider" data-sid="${student.id}">
        <button class="icon flip-btn" data-sid="${student.id}" title="Flip">Flip</button>
        <select class="player-select" data-sid="${student.id}"><option value="">View students</option></select>
      </div>`;
      card.appendChild(top);

      const boardInnerWrap = document.createElement('div'); boardInnerWrap.className = 'board-inner';
      const boardHolder = document.createElement('div'); boardHolder.className = 'board-holder';
      const boardDiv = document.createElement('div'); boardDiv.id = 'board_' + student.id;
      boardHolder.appendChild(boardDiv); boardInnerWrap.appendChild(boardHolder); card.appendChild(boardInnerWrap);

      const debug = document.createElement('div'); debug.className = 'debug'; debug.textContent = 'ready';
      card.appendChild(debug);

      // initialize state placeholder
      boardsState[student.id] = {
        size: 360,
        flip: false,
        watchedClientId: null,
        listeners: {}, // path -> { ref, handlers }
        boardObj: null,
        game: null,
        pieceTheme
      };

      // controls wiring
      const sizeSlider = top.querySelector('.size-slider');
      const flipBtn = top.querySelector('.flip-btn');
      const playerSelect = top.querySelector('.player-select');

      sizeSlider.addEventListener('input', e => {
        const px = Number(e.target.value);
        boardsState[student.id].size = px;
        setBoardSize(student.id, px);
      });
      flipBtn.addEventListener('click', () => {
        const st = boardsState[student.id];
        st.flip = !st.flip;
        if(st.boardObj && typeof st.boardObj.flip === 'function') st.boardObj.flip();
      });
      playerSelect.addEventListener('change', e => {
        const client = e.target.value || null;
        if(!client) stopWatching(student.id);
        else startWatching(student.id, client);
      });

      return card;
    }

    function initEngineAndBoard(studentId){
      const st = boardsState[studentId];
      if(!st) return;
      try{ st.game = (typeof Chess !== 'undefined') ? new Chess() : null; }catch(e){ st.game = null; console.warn('Chess engine init failed', e); }
      try{
        // create board with safe start state and piece theme
        st.boardObj = Chessboard('board_' + studentId, {
          draggable: true,
          position: st.game && typeof st.game.fen === 'function' ? st.game.fen() : 'start',
          pieceTheme: st.pieceTheme,
          onDrop: (source, target) => onMasterDrop(studentId, source, target)
        });
      }catch(e){ console.error('Chessboard init failed', e); }
      setBoardSize(studentId, st.size);
    }

    function setBoardSize(boardId, px){
      const st = boardsState[boardId];
      if(!st) return;
      const div = document.getElementById('board_' + boardId);
      if(!div) return;
      const holder = div.parentElement;
      if(holder){ holder.style.width = px + 'px'; holder.style.height = px + 'px'; }
      try{ if(st.boardObj && typeof st.boardObj.resize === 'function') st.boardObj.resize(); }catch(e){}
    }

    // ---------- populate select & badge ----------
    function populateSelectForBoard(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(!sel) return;
      const prev = sel.value;
      sel.innerHTML = '';
      const title = document.createElement('option'); title.value=''; title.textContent='View students'; sel.appendChild(title);
      const onlineIds = Object.keys(onlineMap).filter(id => onlineMap[id].role && onlineMap[id].role.indexOf('student') !== -1);
      if(onlineIds.length === 0){
        const none = document.createElement('option'); none.value=''; none.disabled=true; none.textContent='No online'; sel.appendChild(none); sel.value=''; return;
      }
      onlineIds.forEach(id => { const opt = document.createElement('option'); opt.value = id; opt.textContent = `${onlineMap[id].email} (${id.slice(0,6)})`; sel.appendChild(opt); });
      const prefer = st.watchedClientId || prev;
      if(prefer && Array.from(sel.options).some(o => o.value === prefer)) sel.value = prefer; else sel.value = '';
    }

    function refreshBadge(boardId){
      const st = boardsState[boardId];
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId);
      if(!card) return;
      const badgeHolder = card.querySelector('.badge-holder');
      const pathHolder = card.querySelector('.path-holder');
      badgeHolder.innerHTML = '';
      pathHolder.textContent = st.watchedClientId ? `games/${st.watchedClientId}` : '';
      if(!st.watchedClientId) return;
      const span = document.createElement('span');
      span.className = onlineMap[st.watchedClientId] ? 'online-badge' : 'offline-badge';
      span.textContent = onlineMap[st.watchedClientId] ? 'online' : 'offline';
      badgeHolder.appendChild(span);
    }

    // ---------- robust watching: attach to multiple candidate paths ----------
    const CANDIDATE_PATHS = ['','game','move','moves']; // will map to games/<id>/{path}

    function startWatching(boardId, clientId){
      const st = boardsState[boardId];
      if(!st) return;
      stopWatching(boardId); // teardown previous
      st.watchedClientId = clientId;
      // reflect selection immediately
      try{ const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`); if(sel) sel.value = clientId; }catch(e){}
      refreshBadge(boardId);
      const debug = getDebugElem(boardId); debugText(debug, `startWatching -> ${clientId}`);

      // Attach listeners for each candidate path
      st.listeners = {}; // reset
      CANDIDATE_PATHS.forEach(p => {
        const path = p ? `games/${clientId}/${p}` : `games/${clientId}`;
        const ref = db.ref(path);
        // value listener (captures whole node or fen)
        const onValue = snap => {
          debugText(debug, `value @ ${path}`);
          const v = snap.val();
          if(!v) return;
          // normalize and apply
          normalizeAndApply(boardId, v);
        };
        ref.on('value', onValue, err => debugText(debug, `value error @ ${path}: ${err && err.message}`));

        // child_added for move streams (only meaningful for /moves)
        const onChildAdded = snap => {
          debugText(debug, `child_added @ ${path}/${snap.key}`);
          const v = snap.val();
          // If path is moves or looks like a child-list, build small ordered object for safety
          if(p === 'moves' || typeof v === 'object'){
            // If child looks like a move record, apply it; otherwise fetch full moves snapshot
            // Try fast-apply first:
            const candidate = v && (v.payload || v);
            if(candidate && (candidate.move || candidate.fen || candidate.from)){
              normalizeAndApply(boardId, v);
            } else {
              // fallback: re-fetch entire moves list
              try{ ref.limitToLast(500).once('value').then(snap2 => { const ordered = {}; snap2.forEach(child => ordered[child.key] = child.val()); normalizeAndApply(boardId, { moves: ordered }); }).catch(()=>{}); }catch(e){}
            }
          } else {
            // non-moves child -> treat as a nested update
            normalizeAndApply(boardId, v);
          }
        };
        // attach child_added only for list-like paths (moves) and non-root children; safe to attach everywhere
        ref.on('child_added', onChildAdded, err => debugText(debug, `child_added error @ ${path}: ${err && err.message}`));

        // child_changed - apply updates
        const onChildChanged = snap => {
          debugText(debug, `child_changed @ ${path}/${snap.key}`);
          normalizeAndApply(boardId, snap.val());
        };
        ref.on('child_changed', onChildChanged, err => debugText(debug, `child_changed error @ ${path}: ${err && err.message}`));

        // save for teardown
        st.listeners[path] = { ref, handlers: { value: onValue, child_added: onChildAdded, child_changed: onChildChanged } };
      });

      // initial one-shot fetch for moves if present
      try{
        const movesRef = db.ref(`games/${clientId}/moves`);
        movesRef.limitToLast(500).once('value').then(snap => {
          if(!snap.exists()) return;
          const ordered = {};
          snap.forEach(child => ordered[child.key] = child.val());
          normalizeAndApply(boardId, { moves: ordered });
        }).catch(()=>{});
      }catch(e){}
    }

    function stopWatching(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      const debug = getDebugElem(boardId);
      debugText(debug, `stopWatching (was ${st.watchedClientId || '-'})`);
      try{
        Object.keys(st.listeners || {}).forEach(path => {
          const L = st.listeners[path];
          if(L && L.ref && L.handlers){
            if(L.handlers.value) L.ref.off('value', L.handlers.value);
            if(L.handlers.child_added) L.ref.off('child_added', L.handlers.child_added);
            if(L.handlers.child_changed) L.ref.off('child_changed', L.handlers.child_changed);
          }
        });
      }catch(e){ console.warn('teardown error', e); }
      st.listeners = {};
      st.watchedClientId = null;
      refreshBadge(boardId);
      try{ if(st.game && typeof st.game.load === 'function'){ st.game.load('start'); } if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position('start'); }catch(e){}
    }

    // ---------- normalization & apply (robust) ----------
    function normalizeAndApply(boardId, record){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st) return;
      try{
        if(record === null || typeof record === 'undefined'){ debugText(debug, 'normalize: empty'); return; }
        // If record is a string -> try fen
        if(typeof record === 'string'){ debugText(debug, 'normalize: string -> fen?'); applyFenToBoard(boardId, record); return; }
        // If record has payload wrapper
        if(record.payload && typeof record.payload === 'object') record = record.payload;

        // moves child-list shape
        if(record.moves && typeof record.moves === 'object' && Object.keys(record.moves).length > 0){
          debugText(debug, 'normalize: moves child-list detected');
          // ensure ordered object by sorting keys by ts when possible
          applyMovesChildList(boardId, record.moves);
          return;
        }

        // fen candidates
        const fenCandidates = ['fen','FEN','sfen','currentFen','position','board_fen','board'];
        for(const k of fenCandidates){ if(record[k] && typeof record[k] === 'string'){ debugText(debug, `normalize: found fen '${k}'`); applyFenToBoard(boardId, record[k]); return; } }

        // single move shapes
        if(record.move){ debugText(debug, 'normalize: record.move'); tryApplyMoveShape(boardId, record.move, record.fen || null); return; }

        const directMoveFields = ['lastMove','last_move','last','moveString','move_uci','uci','from','to'];
        for(const k of directMoveFields){ if(record[k]){ debugText(debug, `normalize: found move field ${k}`); tryApplyMoveShape(boardId, record, record.fen || null); return; } }

        // probe nested children (most-recent)
        const keys = Object.keys(record || {});
        for(let i = keys.length - 1; i >= 0; i--){
          const cand = record[keys[i]];
          if(cand && (cand.payload || cand.fen || cand.move || typeof cand === 'string')){ debugText(debug, 'normalize: probing nested ' + keys[i]); normalizeAndApply(boardId, cand); return; }
        }

        // unknown shape - dump
        debugText(debug, 'normalize: unrecognized shape - dumped to debug');
      }catch(e){ debugText(debug, 'normalize error: ' + (e && e.message)); }
    }

    // replay moves child-list object to reconstruct FEN (ordered by ts or key)
    function applyMovesChildList(boardId, movesObj){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st) return;
      try{
        const entries = Object.keys(movesObj).map(k => {
          const rec = movesObj[k] || {};
          const payload = rec.payload || rec;
          const ts = rec.ts || (payload && payload.ts) || 0;
          return { key: k, ts: Number(ts) || 0, payload, raw: rec };
        });
        entries.sort((a,b) => (a.ts - b.ts) || (a.key < b.key ? -1 : (a.key > b.key ? 1 : 0)));
        debugText(debug, `replaying ${entries.length} moves`);
        // reset engine and replay
        try{ st.game = (typeof Chess !== 'undefined') ? new Chess() : st.game; }catch(e){ debugText(debug, 'engine reset failed'); }
        for(const e of entries){
          const mv = (e.payload && e.payload.move) || e.payload;
          if(!mv) continue;
          if(typeof mv === 'string'){
            const s = mv.replace(/[^a-h1-8qnbrk]/ig,'');
            if(s.length >= 4){
              const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : undefined;
              if(st.game && typeof st.game.move === 'function') st.game.move({ from, to, promotion: prom || undefined });
            }
          } else if(typeof mv === 'object' && mv.from && mv.to){
            if(st.game && typeof st.game.move === 'function') st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
          }
        }
        const pos = st.game && typeof st.game.fen === 'function' ? st.game.fen() : null;
        if(pos && st.boardObj && typeof st.boardObj.position === 'function'){ st.boardObj.position(pos); debugText(debug, 'replay->position set'); } else debugText(debug, 'replay complete but position unavailable');
      }catch(e){ debugText(debug, 'applyMovesChildList error: ' + (e && e.message)); }
    }

    // try to apply move shape strings / objects
    function tryApplyMoveShape(boardId, m, fallbackFen){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st) return false;
      try{
        if(!m) return false;
        if(typeof m === 'string'){
          const s = m.replace(/[^a-h1-8qnbrk]/ig,'');
          if(s.length >= 4){ const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : null; applyMoveToBoard(boardId, { from, to, promotion: prom }, fallbackFen); return true; }
          const m2 = m.match(/([a-h][1-8]).*?([a-h][1-8])/i);
          if(m2){ applyMoveToBoard(boardId, { from: m2[1], to: m2[2] }, fallbackFen); return true; }
          return false;
        }
        if(typeof m === 'object'){
          const from = m.from || m.f || (m.u && m.u.slice(0,2));
          const to = m.to || m.t || (m.u && m.u.slice(2,4));
          const promotion = m.promotion || m.prom || null;
          if(from && to){ applyMoveToBoard(boardId, { from, to, promotion }, fallbackFen); return true; }
          if(m.payload) return tryApplyMoveShape(boardId, m.payload, fallbackFen);
        }
        return false;
      }catch(e){ debugText(debug, 'tryApplyMoveShape error: ' + (e && e.message)); return false; }
    }

    function applyFenToBoard(boardId, fen){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st || !fen) return;
      try{
        if(st.game && typeof st.game.load === 'function'){ st.game.load(fen); if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen()); debugText(debug, 'fen applied'); }
        else if(st.boardObj && typeof st.boardObj.position === 'function'){ st.boardObj.position(fen); debugText(debug,'fen applied via board.position'); }
      }catch(e){ debugText(debug, 'applyFenToBoard error: ' + (e && e.message)); }
    }

    function applyMoveToBoard(boardId, mv, fallbackFen){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st || !mv || !mv.from || !mv.to){ debugText(debug, 'applyMoveToBoard: invalid move'); return; }
      try{
        if(st.game && typeof st.game.move === 'function'){
          const applied = st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
          if(applied === null){
            debugText(debug, `engine rejected ${mv.from}->${mv.to}`);
            if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
            return;
          } else {
            if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen());
            debugText(debug, `applied ${mv.from}->${mv.to}`);
          }
        } else {
          if(st.boardObj && typeof st.boardObj.move === 'function'){
            try{ st.boardObj.move(mv.from + '-' + mv.to); }catch(e){ debugText(debug,'board.move failed'); }
          }
          if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
        }
      }catch(e){ debugText(debug, 'applyMoveToBoard error: ' + (e && e.message)); }
    }

    // ---------- master move -> push into student's moves (same shape as student.html) ----------
    function onMasterDrop(boardId, source, target){
      const st = boardsState[boardId];
      if(!st) return 'snapback';
      if(!st.watchedClientId){ alert('Select a student in the "View students" select before making moves on this board.'); return 'snapback'; }
      if(!st.game) return 'snapback';
      const attempted = st.game.move({ from: source, to: target, promotion: 'q' });
      if(attempted === null) return 'snapback';
      if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen());
      const node = db.ref('games/' + st.watchedClientId + '/moves').push();
      const payload = { payload: { fen: st.game.fen(), move: { from: attempted.from, to: attempted.to, san: attempted.san, promotion: attempted.promotion || null } }, by: MASTER_ID, ts: Date.now() };
      node.set(payload).catch(err => console.error('emit move failed', err));
      return;
    }

    // ---------- debug helpers ----------
    function getDebugElem(boardId){ const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId); if(!card) return null; return card.querySelector('.debug'); }
    function debugText(el, msg){ if(!el) return console.debug('[master debug]', msg); el.textContent = (new Date()).toISOString() + ' - ' + msg + '\n' + el.textContent; console.debug('[master debug]', msg); }

    // ---------- small utilities ----------
    document.getElementById('globalLogout').addEventListener('click', () => {
      try{ localStorage.removeItem('role'); localStorage.removeItem('username'); localStorage.removeItem('email'); sessionStorage.removeItem('iq4u_clientId'); }catch(e){}
      try{ onlineRef.child(MASTER_ID).remove().catch(()=>{}); }catch(e){}
      window.location.href = 'index.html';
    });
    window.addEventListener('beforeunload', () => {
      try{ onlineRef.child(MASTER_ID).remove().catch(()=>{}); }catch(e){}
      STUDENTS.forEach(s => stopWatching(s.id));
    });

  })();
  </script>
</body>
</html>


