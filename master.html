<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Master Dashboard - IQ 4U Academy</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    :root{ --card-gap:12px; --card-bg:#fff; --card-border:#ddd; --control-height:44px; font-family:Arial,Helvetica,sans-serif; color:#222;}
    html,body{ height:100%; margin:0; background:#f5f7fb; }
    .container{ margin:16px auto; max-width:1200px; padding-bottom:28px; }
    h1{ margin:0 0 12px 0; font-size:20px; }
    .boards-grid{ display:grid; grid-template-columns:1fr 1fr; gap:var(--card-gap); }
    .board-card{ background:var(--card-bg); border:1px solid var(--card-border); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:10px; min-height:260px; box-shadow:0 1px 3px rgba(20,30,40,0.05); }
    .top-strip{ display:flex; align-items:center; justify-content:flex-start; gap:8px; height:var(--control-height); }
    .student-label{ font-weight:600; text-align:center; display:flex; align-items:center; gap:8px; justify-content:center; }
    .controls{ display:flex; gap:8px; align-items:center; width:100%; }
    .controls select, .controls button, .controls input[type=range]{ height:32px; padding:4px 8px; border-radius:6px; border:1px solid #ccc; background:#fff; }
    .board-inner{ width:100%; display:flex; justify-content:center; }
    .board-holder{ box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff; position: relative; }
    .debug{ font-family:monospace; font-size:12px; background:#fbfcfd; border:1px solid #eef2f6; padding:6px; border-radius:6px; max-height:80px; overflow:auto; display:none; }
    
    /* Arrow overlay */
    .arrow-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    
    .notif-area{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; width:100%; }
    .notifications { flex: 1 1 260px; min-width:160px; max-width:460px; background:#fff; border:1px solid #eef2f6; padding:8px; border-radius:6px; font-size:13px; color:#333; box-sizing:border-box; max-height:88px; overflow:auto; }
    .notation { flex:1 1 200px; min-width:160px; max-width:999px; background:#fbfdff; border:1px solid #eef2ff; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; white-space:normal; display:flex; flex-wrap:wrap; gap:8px; align-items:center; box-sizing:border-box; min-height:44px; }
    .notation .move { padding:4px 8px; border-radius:6px; background:transparent; }
    .footer-actions{ display:flex; justify-content:flex-end; margin-top:18px; gap:8px; }
    .btn-logout{ background:#ef4444; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    
    /* Engine controls styling */
    .engine-panel { margin-top: 10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-start; padding:8px; background:#f8f9fa; border-radius:6px; border:1px solid #eef2f6; }
    .engine-btn { padding:6px 12px; border-radius:6px; background:#3b82f6; color:#fff; border:none; cursor:pointer; font-size:12px; }
    .engine-btn-stop { background:#ef4444; }
    .engine-btn-next { background:#10b981; }
    .engine-status { font-size:12px; color:#666; padding:4px 8px; background:#fff; border-radius:4px; border:1px solid #eef2f6; min-width:120px; }
    .eval-display { font-size:12px; font-weight:bold; padding:4px 8px; border-radius:4px; }
    .eval-positive { background: #d1fae5; color: #065f46; }
    .eval-negative { background: #fee2e2; color: #991b1b; }
    .eval-neutral { background: #e5e7eb; color: #4b5563; }
    
    /* Best move display */
    .best-move-display { font-size:13px; padding:4px 8px; background:#f0f9ff; border-radius:4px; border:1px solid #e0f2fe; margin-left:8px; }
    .variation-moves { font-size:11px; color:#666; margin-left:8px; }
    .move-san { display:inline-block; padding:2px 6px; margin:0 2px; background:#f3f4f6; border-radius:3px; }
    
    /* Online players display */
    .online-players-summary { 
      position: absolute; 
      top: 10px; 
      right: 10px; 
      background: rgba(255,255,255,0.9); 
      border: 1px solid #e5e7eb; 
      border-radius: 6px; 
      padding: 6px 10px; 
      font-size: 12px; 
      z-index: 100; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
    }
    
    .multiplayer-panel { margin-top: 10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-start; }
    .status-small { font-size:12px; color:#666; min-width:150px; }
    .notif-item { font-size:12px; padding:4px 6px; border-radius:4px; background:#f7f9fc; margin-bottom:6px; }
    
    /* Stockfish version display */
    .version-display { font-size:10px; color:#666; padding:2px 6px; background:#f3f4f6; border-radius:3px; margin-left:4px; }
    
    /* Connection status */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1000;
      background: #fef3c7;
      border: 1px solid #fbbf24;
      color: #92400e;
    }
    .connection-status.connected {
      background: #d1fae5;
      border-color: #10b981;
      color: #065f46;
    }
    .connection-status.disconnected {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }
    
    @media(max-width:900px){ .boards-grid{ grid-template-columns:1fr; padding:0 12px; } .notif-area{ flex-direction:column; } }
  </style>
</head>
<body>
  <!-- Connection Status Indicator -->
  <div id="connectionStatus" class="connection-status">Connecting to Firebase...</div>

  <div class="container">
    <h1>Master Dashboard - IQ 4U Academy</h1>

    <div class="boards-grid" id="boardsGrid"></div>

    <div class="footer-actions">
      <button id="globalLogout" class="btn-logout">Logout</button>
    </div>
  </div>

  <!-- jQuery (required by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- chessboard.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
  (async function(){
    // ---------- CONFIG ----------
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasedestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb6936fe0da4bb"
    };
    
    try{ 
      firebase.initializeApp(FIREBASE_CONFIG); 
      console.log('✅ Firebase initialized');
    } catch(e){ 
      console.error('❌ Firebase init failed:', e);
    }
    
    const db = firebase.database();
    const onlineRef = db.ref('online');

    const MASTER_ID = sessionStorage.getItem('iq4u_clientId') || ('m_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', MASTER_ID);
    const MASTER_NAME = localStorage.getItem('username') || localStorage.getItem('email') || 'master';

    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    const STUDENTS = [
      { id: 'student1', name: 'Student 1' },
      { id: 'student2', name: 'Student 2' },
      { id: 'student3', name: 'Student 3' },
      { id: 'student4', name: 'Student 4' }
    ];

    const onlineMap = {};   // clientId => {email, role, ts}
    const boardsState = {}; // per-board state

    // ---------- ensure chess.js loaded ----------
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    async function ensureChess(){
      if(typeof Chess !== 'undefined') return;
      try{
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        window.Chess = mod.default || mod.Chess || mod;
      }catch(e){}
      if(typeof Chess !== 'undefined') return;
      await new Promise(resolve=>{
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = true;
        s.onload = ()=> setTimeout(resolve, 10);
        s.onerror = ()=> resolve();
        document.head.appendChild(s);
      });
    }

    async function pickPieceTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const r = await fetch(test, { method:'HEAD', cache:'no-store' }); return r.ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // ---------- build UI (DOM only) ----------
    const grid = document.getElementById('boardsGrid');
    const theme = await pickPieceTheme();
    for(let i=0;i<STUDENTS.length;i++){
      const s = STUDENTS[i];
      const card = createCard(s, theme, i);
      grid.appendChild(card);
    }

    // wait and then initialize engines & chessboards
    await ensureChess();
    for(const s of STUDENTS){
      initEngineAndBoard(s.id);
    }

    // ---------- SINGLE AUTHORITATIVE PIPELINE ----------
    // This is the KEY: One path for all Firebase data → Chess.js → Chessboard.js
    const CANDIDATE_PATHS = ['','game','move','moves'];

    function startWatching(boardId, clientId){
      const st = boardsState[boardId];
      if(!st) return;
      stopWatching(boardId); // teardown previous
      st.watchedClientId = clientId;
      
      // Update UI
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(sel) sel.value = clientId;
      refreshBadge(boardId);
      addNotification(boardId, `Start watching ${clientId}`);
      
      // Reset game state
      try{ st.game = new Chess(); } catch(e){ st.game = null; }
      if(st.boardObj) st.boardObj.position('start');
      updateNotation(boardId);

      // Attach listeners for each candidate path (SINGLE SOURCE OF TRUTH)
      st.listeners = {};
      CANDIDATE_PATHS.forEach(p => {
        const path = p ? `games/${clientId}/${p}` : `games/${clientId}`;
        const ref = db.ref(path);
        
        // value listener (captures whole node or fen)
        const onValue = snap => {
          const v = snap.val();
          if(!v) return;
          normalizeAndApply(boardId, v);
        };
        ref.on('value', onValue);

        // child_added for move streams
        const onChildAdded = snap => {
          const v = snap.val();
          if(p === 'moves' || typeof v === 'object'){
            const candidate = v && (v.payload || v);
            if(candidate && (candidate.move || candidate.fen || candidate.from)){
              normalizeAndApply(boardId, v);
            } else {
              // Fetch all moves in order
              ref.limitToLast(500).once('value').then(snap2 => {
                const ordered = {};
                snap2.forEach(child => ordered[child.key] = child.val());
                normalizeAndApply(boardId, { moves: ordered });
              }).catch(()=>{});
            }
          } else {
            normalizeAndApply(boardId, v);
          }
        };
        ref.on('child_added', onChildAdded);

        // child_changed - apply updates
        const onChildChanged = snap => {
          normalizeAndApply(boardId, snap.val());
        };
        ref.on('child_changed', onChildChanged);

        // save for teardown
        st.listeners[path] = { ref, handlers: { value: onValue, child_added: onChildAdded, child_changed: onChildChanged } };
      });

      // Also listen to moves/{clientId} for real-time move syncing
      try{
        const movesPath = `moves/${clientId}`;
        const movesRef = db.ref(movesPath);
        const onMoveAdded = snap => {
          const m = snap.val();
          if(!m) return;
          if(m.by === MASTER_ID) return;
          const candidate = m.payload || m;
          if(candidate && (candidate.move || candidate.fen)){
            normalizeAndApply(boardId, candidate);
          }
        };
        movesRef.on('child_added', onMoveAdded);
        st.listeners[movesPath] = { ref: movesRef, handlers: { child_added: onMoveAdded } };
      }catch(e){ console.error('Moves listener failed:', e); }

      // initial one-shot fetch
      try{
        const movesRef = db.ref(`games/${clientId}/moves`);
        movesRef.limitToLast(500).once('value').then(snap => {
          if(!snap.exists()) return;
          const ordered = {};
          snap.forEach(child => ordered[child.key] = child.val());
          normalizeAndApply(boardId, { moves: ordered });
        }).catch(()=>{});
      }catch(e){}

      // Start engine if not running
      if(!st.engineRunning) {
        setTimeout(() => toggleEngine(boardId), 1000);
      }
    }

    function stopWatching(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      
      // Stop engine
      if(st.engineRunning) {
        if (st.analysisInterval) {
          clearInterval(st.analysisInterval);
          st.analysisInterval = null;
        }
        st.engineRunning = false;
        updateEngineDisplay(boardId, null, 0, []);
        clearArrow(boardId);
      }
      
      // Clean up Firebase listeners
      try{
        Object.keys(st.listeners || {}).forEach(path => {
          const L = st.listeners[path];
          if(L && L.ref && L.handlers){
            if(L.handlers.value) L.ref.off('value', L.handlers.value);
            if(L.handlers.child_added) L.ref.off('child_added', L.handlers.child_added);
            if(L.handlers.child_changed) L.ref.off('child_changed', L.handlers.child_changed);
          }
        });
      }catch(e){}
      
      st.listeners = {};
      st.watchedClientId = null;
      refreshBadge(boardId);
      addNotification(boardId, 'Stopped watching');
      clearNotation(boardId);
      
      // Reset board
      try{ if(st.game && typeof st.game.load === 'function'){ st.game.load('start'); } 
        if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position('start'); 
      }catch(e){}
      
      // Update UI
      const card = document.querySelector(`.board-card[data-student-id="${boardId}"]`);
      if (card) {
        const stopWatchBtn = card.querySelector(`#stop-watch-${boardId}`);
        const spectateBtn = card.querySelector(`#master-spectate-${boardId}`);
        if (stopWatchBtn && spectateBtn) {
          stopWatchBtn.style.display = 'none';
          spectateBtn.style.display = 'inline-block';
        }
      }
    }

    // ---------- NORMALIZE AND APPLY (ORIGINAL ROBUST VERSION) ----------
    function normalizeAndApply(boardId, record){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st) return;
      try{
        if(record === null || typeof record === 'undefined'){ return; }
        if(typeof record === 'string'){ applyFenToBoard(boardId, record); return; }
        if(record.payload && typeof record.payload === 'object') record = record.payload;

        if(record.moves && typeof record.moves === 'object' && Object.keys(record.moves).length > 0){
          applyMovesChildList(boardId, record.moves);
          return;
        }

        const fenCandidates = ['fen','FEN','sfen','currentFen','position','board_fen','board'];
        for(const k of fenCandidates){ 
          if(record[k] && typeof record[k] === 'string'){ 
            applyFenToBoard(boardId, record[k]); 
            return; 
          } 
        }

        if(record.move){ 
          tryApplyMoveShape(boardId, record.move, record.fen || null); 
          return; 
        }

        const directMoveFields = ['lastMove','last_move','last','moveString','move_uci','uci','from','to'];
        for(const k of directMoveFields){ 
          if(record[k]){ 
            tryApplyMoveShape(boardId, record, record.fen || null); 
            return; 
          } 
        }

        const keys = Object.keys(record || {});
        for(let i = keys.length - 1; i >= 0; i--){
          const cand = record[keys[i]];
          if(cand && (cand.payload || cand.fen || cand.move || typeof cand === 'string')){ 
            normalizeAndApply(boardId, cand); 
            return; 
          }
        }
      }catch(e){ 
        addNotification(boardId, 'Normalize error: ' + (e && e.message)); 
      }
    }

    function applyMovesChildList(boardId, movesObj){
      const st = boardsState[boardId];
      if(!st) return;
      try{
        const entries = Object.keys(movesObj).map(k => {
          const rec = movesObj[k] || {};
          const payload = rec.payload || rec;
          const ts = rec.ts || (payload && payload.ts) || 0;
          return { key: k, ts: Number(ts) || 0, payload, raw: rec };
        });
        entries.sort((a,b) => (a.ts - b.ts) || (a.key < b.key ? -1 : (a.key > b.key ? 1 : 0)));
        
        try{ 
          st.game = new Chess(); 
        }catch(e){ 
          st.game = null; 
          return; 
        }
        
        for(const e of entries){
          const mv = (e.payload && e.payload.move) || e.payload;
          if(!mv) continue;
          
          if(typeof mv === 'string'){
            const s = mv.replace(/[^a-h1-8qnbrk]/ig,'');
            if(s.length >= 4){
              const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : undefined;
              if(st.game && typeof st.game.move === 'function') {
                try {
                  st.game.move({ from, to, promotion: prom || undefined });
                } catch(e) {}
              }
            }
          } else if(typeof mv === 'object' && mv.from && mv.to){
            if(st.game && typeof st.game.move === 'function') {
              try {
                st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
              } catch(e) {}
            }
          }
        }
        
        const pos = st.game && typeof st.game.fen === 'function' ? st.game.fen() : null;
        if(pos && st.boardObj && typeof st.boardObj.position === 'function'){
          st.boardObj.position(pos);
        }
        
        updateNotation(boardId);
        
        // Trigger engine analysis if running
        if(st.engineRunning) {
          setTimeout(() => analyzePosition(boardId), 300);
        }
      }catch(e){ 
        addNotification(boardId, 'Apply moves error: ' + (e && e.message)); 
      }
    }

    function tryApplyMoveShape(boardId, m, fallbackFen){
      const st = boardsState[boardId];
      if(!st) return false;
      try{
        if(!m) return false;
        if(typeof m === 'string'){
          const s = m.replace(/[^a-h1-8qnbrk]/ig,'');
          if(s.length >= 4){ 
            const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : null; 
            applyMoveToBoard(boardId, { from, to, promotion: prom }, fallbackFen); 
            return true; 
          }
          const m2 = m.match(/([a-h][1-8]).*?([a-h][1-8])/i);
          if(m2){ 
            applyMoveToBoard(boardId, { from: m2[1], to: m2[2] }, fallbackFen); 
            return true; 
          }
          return false;
        }
        if(typeof m === 'object'){
          const from = m.from || m.f || (m.u && m.u.slice(0,2));
          const to = m.to || m.t || (m.u && m.u.slice(2,4));
          const promotion = m.promotion || m.prom || null;
          if(from && to){ 
            applyMoveToBoard(boardId, { from, to, promotion }, fallbackFen); 
            return true; 
          }
          if(m.payload) return tryApplyMoveShape(boardId, m.payload, fallbackFen);
        }
        return false;
      }catch(e){ 
        addNotification(boardId, 'Apply move shape error: ' + (e && e.message)); 
        return false; 
      }
    }

    function applyFenToBoard(boardId, fen){
      const st = boardsState[boardId];
      if(!st || !fen) return;
      try{
        if(st.game && typeof st.game.load === 'function'){ 
          st.game.load(fen); 
          if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen()); 
          updateNotation(boardId);
          
          // Trigger engine analysis if running
          if(st.engineRunning) {
            setTimeout(() => analyzePosition(boardId), 300);
          }
        }
        else if(st.boardObj && typeof st.boardObj.position === 'function'){ 
          st.boardObj.position(fen); 
        }
      }catch(e){ 
        addNotification(boardId, 'Apply FEN error: ' + (e && e.message)); 
      }
    }

    function applyMoveToBoard(boardId, mv, fallbackFen){
      const st = boardsState[boardId];
      if(!st || !mv || !mv.from || !mv.to) return;
      try{
        if(st.game && typeof st.game.move === 'function'){
          const applied = st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
          if(applied === null){
            if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
            return;
          } else {
            if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen());
            updateNotation(boardId);
            
            // Trigger engine analysis if running
            if(st.engineRunning) {
              setTimeout(() => analyzePosition(boardId), 300);
            }
          }
        } else {
          if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
        }
      }catch(e){ 
        addNotification(boardId, 'Apply move error: ' + (e && e.message)); 
      }
    }

    // ---------- STOCKFISH ENGINE ----------
    // Simple inline engine that doesn't break CSP
    function createInlineStockfishWorker() {
      const stockfishCode = `
// Simple chess analysis engine
self.onmessage = function(e) {
  const data = e.data;
  
  if (data === 'uci') {
    self.postMessage('id name Simple Chess Engine 1.0');
    self.postMessage('id author IQ4U Academy');
    self.postMessage('uciok');
    return;
  }
  
  if (data.startsWith('position')) {
    // Store position
    return;
  }
  
  if (data.startsWith('go')) {
    const parts = data.split(' ');
    let depth = 15;
    for (let i = 0; i < parts.length; i++) {
      if (parts[i] === 'depth' && i + 1 < parts.length) {
        depth = parseInt(parts[i + 1]);
      }
    }
    
    // Simulate analysis
    setTimeout(() => {
      // Random evaluation between -2.0 and +2.0
      const evalScore = (Math.random() - 0.5) * 4;
      const moves = ['e2e4', 'd2d4', 'g1f3', 'c2c4', 'e7e5', 'd7d5'];
      const bestMove = moves[Math.floor(Math.random() * moves.length)];
      
      self.postMessage(\`info depth \${depth} score cp \${Math.round(evalScore * 100)}\`);
      self.postMessage(\`bestmove \${bestMove}\`);
    }, 500);
    
    return;
  }
  
  if (data.startsWith('setoption')) {
    return;
  }
  
  if (data === 'isready') {
    self.postMessage('readyok');
    return;
  }
  
  self.postMessage('readyok');
};
`;

      const blob = new Blob([stockfishCode], { type: 'application/javascript' });
      return URL.createObjectURL(blob);
    }

    // Global engine state
    let engineWorker = null;
    let engineLoaded = false;
    let currentEngineVersion = 'Simple Engine';

    async function loadEngine() {
      // Clean up existing worker
      if (engineWorker) {
        try { engineWorker.terminate(); } catch(e) {}
        engineWorker = null;
        engineLoaded = false;
      }
      
      try {
        const workerUrl = createInlineStockfishWorker();
        engineWorker = new Worker(workerUrl);
        
        return new Promise((resolve) => {
          const timeout = setTimeout(() => {
            resolve(false);
          }, 3000);
          
          const messageHandler = (e) => {
            if (e.data && (e.data.includes('uciok') || e.data.includes('id name'))) {
              clearTimeout(timeout);
              engineWorker.removeEventListener('message', messageHandler);
              engineLoaded = true;
              console.log('✅ Engine loaded');
              
              // Update all boards
              STUDENTS.forEach(s => {
                const versionEl = document.getElementById(`engine-version-${s.id}`);
                if (versionEl) versionEl.textContent = currentEngineVersion;
              });
              
              resolve(true);
            }
          };
          
          engineWorker.addEventListener('message', messageHandler);
          engineWorker.postMessage('uci');
          engineWorker.postMessage('isready');
        });
      } catch (error) {
        console.error('Engine load failed:', error);
        return false;
      }
    }

    function analyzePosition(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.engineRunning || !st.game || !engineWorker || !engineLoaded) return;
      
      try {
        const fen = st.game.fen ? st.game.fen() : 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
        if (fen === 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1') {
          return; // Don't analyze starting position
        }
        
        let bestMove = null;
        let evaluation = 0;
        let analysisComplete = false;
        
        const messageHandler = (e) => {
          const data = e.data;
          
          if (data.startsWith('info depth')) {
            const parts = data.split(' ');
            for (let i = 0; i < parts.length; i++) {
              if (parts[i] === 'score' && i + 1 < parts.length) {
                const scoreType = parts[i + 1];
                const scoreValue = parts[i + 2];
                if (scoreType === 'cp') {
                  evaluation = parseInt(scoreValue) / 100;
                }
              }
            }
            
            updateEngineDisplay(boardId, bestMove, evaluation, []);
          }
          
          if (data.startsWith('bestmove')) {
            analysisComplete = true;
            const match = data.match(/bestmove\s+(\S+)/);
            if (match) {
              bestMove = match[1];
              engineWorker.removeEventListener('message', messageHandler);
              
              // Store results
              st.bestMove = bestMove;
              st.bestMoveUCI = bestMove;
              st.evalScore = evaluation;
              
              // Update display
              updateEngineDisplay(boardId, bestMove, evaluation, []);
              
              // Draw arrow
              if (bestMove && bestMove.length >= 4) {
                drawBestMoveArrow(boardId, bestMove);
              }
            }
          }
        };
        
        engineWorker.addEventListener('message', messageHandler);
        engineWorker.postMessage(`position fen ${fen}`);
        engineWorker.postMessage(`go depth ${Math.min(st.analysisDepth, 20)}`);
        
        // Timeout
        setTimeout(() => {
          if (!analysisComplete) {
            engineWorker.removeEventListener('message', messageHandler);
          }
        }, 5000);
      } catch (e) {
        console.error('Analysis error:', e);
      }
    }

    function toggleEngine(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const toggleBtn = document.getElementById(`engine-toggle-${boardId}`);
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      
      if (!st.engineRunning) {
        // Try to load engine if not loaded
        if (!engineLoaded) {
          loadEngine().then(success => {
            if (success) {
              startEngineForBoard(boardId);
            } else {
              addNotification(boardId, 'Failed to load engine');
            }
          });
        } else {
          startEngineForBoard(boardId);
        }
      } else {
        // Stop engine
        st.engineRunning = false;
        
        if (st.analysisInterval) {
          clearInterval(st.analysisInterval);
          st.analysisInterval = null;
        }
        
        if (toggleBtn) {
          toggleBtn.textContent = 'Engine: OFF';
          toggleBtn.className = 'engine-btn';
        }
        if (statusEl) statusEl.textContent = 'Engine off';
        
        updateEngineDisplay(boardId, null, 0, []);
        clearArrow(boardId);
        
        addNotification(boardId, 'Engine stopped');
      }
    }

    function startEngineForBoard(boardId) {
      const st = boardsState[boardId];
      const toggleBtn = document.getElementById(`engine-toggle-${boardId}`);
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      
      st.engineRunning = true;
      
      if (toggleBtn) {
        toggleBtn.textContent = 'Engine: ON';
        toggleBtn.className = 'engine-btn engine-btn-stop';
      }
      if (statusEl) statusEl.textContent = 'Analyzing...';
      
      addNotification(boardId, `Engine started (depth ${st.analysisDepth})`);
      
      // Start immediate analysis
      setTimeout(() => analyzePosition(boardId), 300);
      
      // Set up periodic analysis
      st.analysisInterval = setInterval(() => {
        if (st.engineRunning && st.game && st.watchedClientId) {
          analyzePosition(boardId);
        }
      }, 8000);
    }

    function updateEngineDisplay(boardId, bestMove, evaluation, variation) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const bestMoveEl = document.getElementById(`best-move-${boardId}`);
      const evalEl = document.getElementById(`engine-eval-${boardId}`);
      const variationEl = document.getElementById(`variation-${boardId}`);
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      
      if (bestMoveEl) {
        bestMoveEl.textContent = bestMove ? `Best: ${bestMove}` : 'Best: --';
      }
      
      if (evalEl) {
        const evalText = (evaluation > 0 ? '+' : '') + evaluation.toFixed(1);
        evalEl.textContent = evalText;
        
        if (evaluation > 1.0) {
          evalEl.className = 'eval-display eval-positive';
        } else if (evaluation < -1.0) {
          evalEl.className = 'eval-display eval-negative';
        } else {
          evalEl.className = 'eval-display eval-neutral';
        }
      }
      
      if (variationEl && variation && variation.length > 0) {
        let variationHTML = '';
        for (let i = 0; i < Math.min(variation.length, 3); i++) {
          if (i > 0) variationHTML += ' ';
          variationHTML += `<span class="move-san">${variation[i]}</span>`;
        }
        variationEl.innerHTML = variationHTML;
      }
      
      if (statusEl && st.engineRunning) {
        statusEl.textContent = 'Analyzing...';
      }
    }

    // ---------- ARROW FUNCTIONS ----------
    function initArrowOverlay(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const arrowOverlay = document.getElementById(`arrows_${boardId}`);
      if (!arrowOverlay) return;
      
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.className = 'arrow-svg';
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '10';
      
      arrowOverlay.innerHTML = '';
      arrowOverlay.appendChild(svg);
      st.arrowSvg = svg;
    }

    function drawBestMoveArrow(boardId, uciMove) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg || !uciMove || uciMove.length < 4) return;
      
      clearArrow(boardId);
      
      const from = uciMove.substring(0, 2);
      const to = uciMove.substring(2, 4);
      
      const arrow = {
        from: from,
        to: to,
        color: '#10b981',
        width: 3,
        opacity: 0.7
      };
      
      drawArrow(boardId, arrow);
    }

    function drawArrow(boardId, arrow) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      
      st.arrowSvg.innerHTML = '';
      
      const boardEl = document.getElementById(`board_${boardId}`);
      if (!boardEl) return;
      
      const boardRect = boardEl.getBoundingClientRect();
      const squareSize = boardRect.width / 8;
      
      const fromSquare = arrow.from.toLowerCase();
      const toSquare = arrow.to.toLowerCase();
      
      if (fromSquare.length !== 2 || toSquare.length !== 2) return;
      
      const fromFile = fromSquare.charCodeAt(0) - 97;
      const fromRank = parseInt(fromSquare.charAt(1)) - 1;
      const toFile = toSquare.charCodeAt(0) - 97;
      const toRank = parseInt(toSquare.charAt(1)) - 1;
      
      let x1, y1, x2, y2;
      if (st.flip) {
        x1 = (7 - fromFile) * squareSize + squareSize / 2;
        y1 = fromRank * squareSize + squareSize / 2;
        x2 = (7 - toFile) * squareSize + squareSize / 2;
        y2 = toRank * squareSize + squareSize / 2;
      } else {
        x1 = fromFile * squareSize + squareSize / 2;
        y1 = (7 - fromRank) * squareSize + squareSize / 2;
        x2 = toFile * squareSize + squareSize / 2;
        y2 = (7 - toRank) * squareSize + squareSize / 2;
      }
      
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute('id', `arrowhead-${boardId}`);
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '7');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3.5');
      marker.setAttribute('orient', 'auto');
      
      const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
      polygon.setAttribute('fill', arrow.color);
      
      marker.appendChild(polygon);
      defs.appendChild(marker);
      st.arrowSvg.appendChild(defs);
      
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', arrow.color);
      line.setAttribute('stroke-width', arrow.width);
      line.setAttribute('stroke-opacity', arrow.opacity);
      line.setAttribute('marker-end', `url(#arrowhead-${boardId})`);
      st.arrowSvg.appendChild(line);
    }

    function clearArrow(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      st.arrowSvg.innerHTML = '';
    }

    // ---------- UI HELPER FUNCTIONS ----------
    function createCard(student, pieceTheme, index){
      const card = document.createElement('div'); 
      card.className = 'board-card'; 
      card.dataset.studentId = student.id;

      const label = document.createElement('div'); 
      label.className = 'student-label';
      label.innerHTML = `<span class="label-text">${student.name}</span><span class="badge-holder" style="margin-left:10px"></span><span class="path-holder" style="margin-left:8px;font-size:11px;color:#666"></span>`;
      card.appendChild(label);

      const top = document.createElement('div'); 
      top.className = 'top-strip';
      top.innerHTML = `<div class="controls">
        <span class="label-small" style="margin-right:6px;">Size</span>
        <input id="size-slider-${student.id}" name="size-slider" type="range" min="200" max="800" value="" class="size-slider" data-sid="${student.id}">
        <button class="icon flip-btn" data-sid="${student.id}" title="Flip">Flip</button>
        <select id="player-select-${student.id}" name="player-select" class="player-select" data-sid="${student.id}" style="min-width:180px;">
          <option value="">View students</option>
        </select>
      </div>`;
      card.appendChild(top);

      const boardInnerWrap = document.createElement('div'); 
      boardInnerWrap.className = 'board-inner';
      const boardHolder = document.createElement('div'); 
      boardHolder.className = 'board-holder';
      
      // Add arrow overlay
      const arrowOverlay = document.createElement('div');
      arrowOverlay.className = 'arrow-overlay';
      arrowOverlay.id = 'arrows_' + student.id;
      
      const boardDiv = document.createElement('div'); 
      boardDiv.id = 'board_' + student.id;
      
      boardHolder.appendChild(boardDiv);
      boardHolder.appendChild(arrowOverlay);
      boardInnerWrap.appendChild(boardHolder); 
      card.appendChild(boardInnerWrap);

      const notifArea = document.createElement('div'); 
      notifArea.className = 'notif-area';
      notifArea.innerHTML = `
        <div class="notifications" id="notif_${student.id}"></div>
        <div class="notation" id="notation_${student.id}">No moves.</div>
      `;
      card.appendChild(notifArea);

      // Engine analysis panel
      const enginePanel = document.createElement('div');
      enginePanel.className = 'engine-panel';
      enginePanel.innerHTML = `
        <button id="engine-toggle-${student.id}" class="engine-btn">Engine: OFF</button>
        <span id="engine-version-${student.id}" class="version-display">None</span>
        <span style="font-size:12px;">Depth:</span>
        <select id="depth-select-${student.id}" style="font-size:12px; padding:4px; border-radius:4px; border:1px solid #ccc;">
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="15" selected>15</option>
          <option value="18">18</option>
          <option value="20">20</option>
        </select>
        <span id="best-move-${student.id}" class="best-move-display">Best: --</span>
        <span id="engine-eval-${student.id}" class="eval-display eval-neutral">+0.0</span>
        <span id="variation-${student.id}" class="variation-moves"></span>
        <span id="engine-status-${student.id}" class="engine-status">Engine off</span>
      `;
      card.appendChild(enginePanel);

      const defaultSize = (index < 2) ? 570 : 360;
      boardsState[student.id] = {
        size: defaultSize,
        flip: false,
        watchedClientId: null,
        listeners: {},
        boardObj: null,
        game: null,
        pieceTheme,
        // Engine properties
        engineRunning: false,
        analysisDepth: 15,
        evalScore: 0,
        bestMove: null,
        bestMoveUCI: null,
        variation: [],
        analysisInterval: null,
        arrowSvg: null
      };

      // Event listeners
      const sizeSlider = top.querySelector('.size-slider');
      sizeSlider.value = defaultSize;
      sizeSlider.addEventListener('input', e => {
        const px = Number(e.target.value);
        boardsState[student.id].size = px;
        setBoardSize(student.id, px);
      });
      
      top.querySelector('.flip-btn').addEventListener('click', () => {
        const st = boardsState[student.id];
        st.flip = !st.flip;
        if(st.boardObj && typeof st.boardObj.flip === 'function') st.boardObj.flip();
        if (st.bestMoveUCI) {
          setTimeout(() => drawBestMoveArrow(student.id, st.bestMoveUCI), 100);
        }
      });

      const playerSelect = top.querySelector('.player-select');
      playerSelect.addEventListener('change', e => {
        const client = e.target.value || null;
        if(!client) {
          stopWatching(student.id);
        } else {
          startWatching(student.id, client);
        }
      });

      // Engine event listeners
      const engineToggleBtn = enginePanel.querySelector(`#engine-toggle-${student.id}`);
      const depthSelect = enginePanel.querySelector(`#depth-select-${student.id}`);

      engineToggleBtn.addEventListener('click', () => {
        toggleEngine(student.id);
      });

      depthSelect.addEventListener('change', (e) => {
        const st = boardsState[student.id];
        if(st) {
          st.analysisDepth = parseInt(e.target.value);
          if (st.engineRunning) {
            setTimeout(() => analyzePosition(student.id), 200);
          }
        }
      });

      return card;
    }

    function initEngineAndBoard(studentId){
      const st = boardsState[studentId];
      if(!st) return;
      try{ 
        st.game = new Chess();
      }catch(e){ 
        console.warn('Chess engine init failed:', e);
        st.game = null;
      }
      try{
        st.boardObj = Chessboard('board_' + studentId, {
          draggable: false,
          position: 'start',
          pieceTheme: st.pieceTheme
        });
      }catch(e){ 
        console.error('Chessboard init failed', e);
      }
      setBoardSize(studentId, st.size);
      initArrowOverlay(studentId);
    }

    function setBoardSize(boardId, px){
      const st = boardsState[boardId];
      if(!st) return;
      const div = document.getElementById('board_' + boardId);
      if(!div) return;
      const holder = div.parentElement;
      if(holder){ 
        holder.style.width = px + 'px'; 
        holder.style.height = px + 'px'; 
      }
      try{ 
        if(st.boardObj && typeof st.boardObj.resize === 'function') 
          st.boardObj.resize(); 
      }catch(e){}
    }

    // ---------- PRESENCE & ONLINE UPDATES ----------
    onlineRef.on('value', snap => {
      const val = snap.val() || {};
      for(const k in onlineMap) delete onlineMap[k];
      for(const id in val){ 
        if(!val.hasOwnProperty(id)) continue; 
        onlineMap[id] = { email: val[id].email || id, role: val[id].role || null, ts: val[id].ts || Date.now() }; 
      }
      STUDENTS.forEach(s => populateSelectForBoard(s.id));
      STUDENTS.forEach(s => refreshBadge(s.id));
    });

    // Publish master presence
    try{
      const n = onlineRef.child(MASTER_ID);
      n.set({ email: MASTER_NAME, role: 'master', ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
      n.onDisconnect().remove();
      setInterval(()=> n.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
    }catch(e){}

    // ---------- UI UPDATE FUNCTIONS ----------
    function populateSelectForBoard(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(!sel) return;
      const prev = sel.value;
      sel.innerHTML = '';
      const title = document.createElement('option'); title.value=''; title.textContent='View students'; sel.appendChild(title);

      const onlineIds = Object.keys(onlineMap).filter(id => id !== MASTER_ID);
      if(onlineIds.length === 0){
        const none = document.createElement('option'); none.value=''; none.disabled=true; none.textContent='No online'; sel.appendChild(none); sel.value=''; return;
      }
      
      onlineIds.forEach(id => { 
        const opt = document.createElement('option'); 
        opt.value = id; 
        opt.textContent = `${onlineMap[id].email} (${id.slice(0,6)})`; 
        sel.appendChild(opt); 
      });

      const prefer = st.watchedClientId || prev;
      if(prefer && Array.from(sel.options).some(o => o.value === prefer)) sel.value = prefer; else sel.value = '';
    }

    function refreshBadge(boardId){
      const st = boardsState[boardId];
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId);
      if(!card) return;
      const badgeHolder = card.querySelector('.badge-holder');
      const pathHolder = card.querySelector('.path-holder');
      badgeHolder.innerHTML = '';
      pathHolder.textContent = st.watchedClientId ? `moves/${st.watchedClientId}` : '';
      if(!st.watchedClientId) return;
      const span = document.createElement('span');
      span.className = onlineMap[st.watchedClientId] ? 'online-badge' : 'offline-badge';
      span.textContent = onlineMap[st.watchedClientId] ? 'online' : 'offline';
      badgeHolder.appendChild(span);
    }

    function addNotification(boardId, msg){
      const el = document.getElementById('notif_' + boardId);
      if(!el) return;
      const st = boardsState[boardId];
      if(st && st.lastNotif === msg) return;
      st.lastNotif = msg;
      const item = document.createElement('div');
      item.className = 'notif-item';
      item.textContent = `${new Date().toLocaleTimeString()} — ${msg}`;
      el.insertBefore(item, el.firstChild);
      while(el.children.length > 5) el.removeChild(el.lastChild);
    }

    function updateNotation(boardId){
      const st = boardsState[boardId];
      const notEl = document.getElementById('notation_' + boardId);
      if(!st || !notEl) return;
      try{
        if(!st.game || typeof st.game.history !== 'function'){ notEl.innerHTML = 'No moves.'; return; }
        const hist = st.game.history() || [];
        if(hist.length === 0){ notEl.innerHTML = 'No moves.'; return; }
        notEl.innerHTML = '';
        for(let i=0;i<hist.length;i+=2){
          const no = Math.floor(i/2)+1;
          const w = hist[i]||'';
          const b = hist[i+1]||'';
          const div = document.createElement('div');
          div.className = 'move';
          div.innerHTML = `<strong>${no}.</strong>&nbsp;${w}${ b ? ('\u00A0' + b) : '' }`;
          notEl.appendChild(div);
        }
      }catch(e){ console.warn('updateNotation error', e); }
    }
    
    function clearNotation(boardId){ 
      const notEl = document.getElementById('notation_' + boardId); 
      if(notEl) notEl.innerHTML = 'No moves.'; 
    }

    function getDebugElem(boardId){ 
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId); 
      if(!card) return null; 
      return card.querySelector('.debug'); 
    }

    // ---------- CONNECTION STATUS ----------
    const connectedRef = db.ref('.info/connected');
    connectedRef.on('value', function(snap) {
      const statusElement = document.getElementById('connectionStatus');
      if (snap.val() === true) {
        console.log('✅ Firebase connected');
        if (statusElement) {
          statusElement.textContent = 'Connected to Firebase';
          statusElement.className = 'connection-status connected';
        }
      } else {
        console.log('❌ Firebase disconnected');
        if (statusElement) {
          statusElement.textContent = 'Disconnected from Firebase';
          statusElement.className = 'connection-status disconnected';
        }
      }
    });

    // ---------- UTILITIES ----------
    document.getElementById('globalLogout').addEventListener('click', () => {
      try{ 
        localStorage.removeItem('role'); 
        localStorage.removeItem('username'); 
        localStorage.removeItem('email'); 
        sessionStorage.removeItem('iq4u_clientId'); 
      }catch(e){}
      try{ 
        onlineRef.child(MASTER_ID).remove().catch(()=>{}); 
      }catch(e){}
      window.location.href = 'index.html';
    });

    window.addEventListener('beforeunload', () => {
      try{ 
        onlineRef.child(MASTER_ID).remove().catch(()=>{}); 
      }catch(e){}
      STUDENTS.forEach(s => stopWatching(s.id));
      
      if (engineWorker) {
        try { engineWorker.terminate(); } catch(e) {}
      }
    });

    // Load engine on startup
    setTimeout(() => {
      loadEngine().then(success => {
        if (success) {
          STUDENTS.forEach(s => {
            addNotification(s.id, `Chess engine ready: ${currentEngineVersion}`);
          });
        } else {
          STUDENTS.forEach(s => {
            addNotification(s.id, 'Chess engine failed to load');
          });
        }
      });
    }, 2000);

  })();
  </script>
</body>
</html>
