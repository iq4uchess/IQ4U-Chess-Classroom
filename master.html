<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Master Dashboard - IQ 4U Academy</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    :root{ --card-gap:12px; --card-bg:#fff; --card-border:#ddd; --control-height:44px; font-family:Arial,Helvetica,sans-serif; color:#222;}
    html,body{ height:100%; margin:0; background:#f5f7fb; }
    .container{ margin:16px auto; max-width:1200px; padding-bottom:28px; }
    h1{ margin:0 0 12px 0; font-size:20px; }
    .boards-grid{ display:grid; grid-template-columns:1fr 1fr; gap:var(--card-gap); }
    .board-card{ background:var(--card-bg); border:1px solid var(--card-border); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:10px; min-height:260px; box-shadow:0 1px 3px rgba(20,30,40,0.05); }
    .top-strip{ display:flex; align-items:center; justify-content:flex-start; gap:8px; height:var(--control-height); }
    .student-label{ font-weight:600; text-align:center; display:flex; align-items:center; gap:8px; justify-content:center; }
    .controls{ display:flex; gap:8px; align-items:center; width:100%; }
    .controls select, .controls button, .controls input[type=range]{ height:32px; padding:4px 8px; border-radius:6px; border:1px solid #ccc; background:#fff; }
    .board-inner{ width:100%; display:flex; justify-content:center; }
    .board-holder{ box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff; position: relative; }
    .debug{ font-family:monospace; font-size:12px; background:#fbfcfd; border:1px solid #eef2f6; padding:6px; border-radius:6px; max-height:80px; overflow:auto; display:none; }
    
    /* Arrow overlay */
    .arrow-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    
    .notif-area{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; width:100%; }
    .notifications { flex: 1 1 260px; min-width:160px; max-width:460px; background:#fff; border:1px solid #eef2f6; padding:8px; border-radius:6px; font-size:13px; color:#333; box-sizing:border-box; max-height:88px; overflow:auto; }
    .notation { flex:1 1 200px; min-width:160px; max-width:999px; background:#fbfdff; border:1px solid #eef2ff; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; white-space:normal; display:flex; flex-wrap:wrap; gap:8px; align-items:center; box-sizing:border-box; min-height:44px; }
    .notation .move { padding:4px 8px; border-radius:6px; background:transparent; }
    .footer-actions{ display:flex; justify-content:flex-end; margin-top:18px; gap:8px; }
    .btn-logout{ background:#ef4444; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    
    /* Engine controls styling */
    .engine-panel { margin-top: 10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-start; padding:8px; background:#f8f9fa; border-radius:6px; border:1px solid #eef2f6; }
    .engine-btn { padding:6px 12px; border-radius:6px; background:#3b82f6; color:#fff; border:none; cursor:pointer; font-size:12px; }
    .engine-btn-stop { background:#ef4444; }
    .engine-btn-next { background:#10b981; }
    .engine-status { font-size:12px; color:#666; padding:4px 8px; background:#fff; border-radius:4px; border:1px solid #eef2f6; min-width:120px; }
    .eval-display { font-size:12px; font-weight:bold; padding:4px 8px; border-radius:4px; }
    .eval-positive { background: #d1fae5; color: #065f46; }
    .eval-negative { background: #fee2e2; color: #991b1b; }
    .eval-neutral { background: #e5e7eb; color: #4b5563; }
    
    /* Best move display */
    .best-move-display { font-size:13px; padding:4px 8px; background:#f0f9ff; border-radius:4px; border:1px solid #e0f2fe; margin-left:8px; }
    .variation-moves { font-size:11px; color:#666; margin-left:8px; }
    .move-san { display:inline-block; padding:2px 6px; margin:0 2px; background:#f3f4f6; border-radius:3px; }
    
    /* Move quality display */
    .move-quality-display { font-size:11px; font-weight:bold; padding:2px 6px; border-radius:4px; margin-left:8px; }
    
    /* Analysis Grid Styles */
    .analysis-grid { margin-top: 12px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px; font-size: 11px; display: none; grid-template-columns: 1fr 1fr; gap: 8px; }
    .analysis-toggle-btn { margin-top: 8px; font-size: 11px; padding: 4px 8px; }
    
    /* Connection status */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1000;
      background: #fef3c7;
      border: 1px solid #fbbf24;
      color: #92400e;
    }
    .connection-status.connected {
      background: #d1fae5;
      border-color: #10b981;
      color: #065f46;
    }
    .connection-status.disconnected {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }
    
    /* Enhanced arrow styles */
    .arrow-svg line { stroke-linecap: round; }
    
    @media(max-width:900px){ .boards-grid{ grid-template-columns:1fr; padding:0 12px; } .notif-area{ flex-direction:column; } .analysis-grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <!-- Connection Status Indicator -->
  <div id="connectionStatus" class="connection-status">Connecting to Firebase...</div>

  <div class="container">
    <h1>Master Dashboard - IQ 4U Academy</h1>

    <div class="boards-grid" id="boardsGrid"></div>

    <div class="footer-actions">
      <button id="globalLogout" class="btn-logout">Logout</button>
    </div>
  </div>

  <!-- jQuery (required by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- chessboard.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
  (async function(){
    // ---------- CONFIG ----------
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasedestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb6936fe0da4bb"
    };
    
    try{ 
      firebase.initializeApp(FIREBASE_CONFIG); 
      console.log('✅ Firebase initialized');
    } catch(e){ 
      console.error('❌ Firebase init failed:', e);
    }
    
    const db = firebase.database();
    const onlineRef = db.ref('online');

    const MASTER_ID = sessionStorage.getItem('iq4u_clientId') || ('m_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', MASTER_ID);
    const MASTER_NAME = localStorage.getItem('username') || localStorage.getItem('email') || 'master';

    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    const STUDENTS = [
      { id: 'student1', name: 'Student 1' },
      { id: 'student2', name: 'Student 2' },
      { id: 'student3', name: 'Student 3' },
      { id: 'student4', name: 'Student 4' }
    ];

    const onlineMap = {};   // clientId => {email, role, ts}
    const boardsState = {}; // per-board state

    // ---------- ensure chess.js loaded ----------
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    async function ensureChess(){
      if(typeof Chess !== 'undefined') return;
      try{
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        window.Chess = mod.default || mod.Chess || mod;
      }catch(e){}
      if(typeof Chess !== 'undefined') return;
      await new Promise(resolve=>{
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = true;
        s.onload = ()=> setTimeout(resolve, 10);
        s.onerror = ()=> resolve();
        document.head.appendChild(s);
      });
    }

    async function pickPieceTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const r = await fetch(test, { method:'HEAD', cache:'no-store' }); return r.ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // ---------- build UI (DOM only) ----------
    const grid = document.getElementById('boardsGrid');
    const theme = await pickPieceTheme();
    for(let i=0;i<STUDENTS.length;i++){
      const s = STUDENTS[i];
      const card = createCard(s, theme, i);
      grid.appendChild(card);
    }

    // wait and then initialize engines & chessboards
    await ensureChess();
    for(const s of STUDENTS){
      initEngineAndBoard(s.id);
    }

    // ---------- SINGLE AUTHORITATIVE PIPELINE ----------
    // This is the KEY: One path for all Firebase data → Chess.js → Chessboard.js
    const CANDIDATE_PATHS = ['','game','move','moves'];

    function startWatching(boardId, clientId){
      const st = boardsState[boardId];
      if(!st) return;
      stopWatching(boardId); // teardown previous
      st.watchedClientId = clientId;
      
      // Update UI
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(sel) sel.value = clientId;
      refreshBadge(boardId);
      addNotification(boardId, `Start watching ${clientId}`);
      
      // Reset game state
      try{ st.game = new Chess(); } catch(e){ st.game = null; }
      if(st.boardObj) st.boardObj.position('start');
      updateNotation(boardId);

      // Attach listeners for each candidate path (SINGLE SOURCE OF TRUTH)
      st.listeners = {};
      CANDIDATE_PATHS.forEach(p => {
        const path = p ? `games/${clientId}/${p}` : `games/${clientId}`;
        const ref = db.ref(path);
        
        // value listener (captures whole node or fen)
        const onValue = snap => {
          const v = snap.val();
          if(!v) return;
          normalizeAndApply(boardId, v);
        };
        ref.on('value', onValue);

        // child_added for move streams
        const onChildAdded = snap => {
          const v = snap.val();
          if(p === 'moves' || typeof v === 'object'){
            const candidate = v && (v.payload || v);
            if(candidate && (candidate.move || candidate.fen || candidate.from)){
              normalizeAndApply(boardId, v);
            } else {
              // Fetch all moves in order
              ref.limitToLast(500).once('value').then(snap2 => {
                const ordered = {};
                snap2.forEach(child => ordered[child.key] = child.val());
                normalizeAndApply(boardId, { moves: ordered });
              }).catch(()=>{});
            }
          } else {
            normalizeAndApply(boardId, v);
          }
        };
        ref.on('child_added', onChildAdded);

        // child_changed - apply updates
        const onChildChanged = snap => {
          normalizeAndApply(boardId, snap.val());
        };
        ref.on('child_changed', onChildChanged);

        // save for teardown
        st.listeners[path] = { ref, handlers: { value: onValue, child_added: onChildAdded, child_changed: onChildChanged } };
      });

      // Also listen to moves/{clientId} for real-time move syncing
      try{
        const movesPath = `moves/${clientId}`;
        const movesRef = db.ref(movesPath);
        const onMoveAdded = snap => {
          const m = snap.val();
          if(!m) return;
          if(m.by === MASTER_ID) return;
          const candidate = m.payload || m;
          if(candidate && (candidate.move || candidate.fen)){
            normalizeAndApply(boardId, candidate);
          }
        };
        movesRef.on('child_added', onMoveAdded);
        st.listeners[movesPath] = { ref: movesRef, handlers: { child_added: onMoveAdded } };
      }catch(e){ console.error('Moves listener failed:', e); }

      // initial one-shot fetch
      try{
        const movesRef = db.ref(`games/${clientId}/moves`);
        movesRef.limitToLast(500).once('value').then(snap => {
          if(!snap.exists()) return;
          const ordered = {};
          snap.forEach(child => ordered[child.key] = child.val());
          normalizeAndApply(boardId, { moves: ordered });
        }).catch(()=>{});
      }catch(e){}

      // Start engine if not running
      if(!st.engineRunning) {
        setTimeout(() => toggleEngine(boardId), 1000);
      }
    }

    function stopWatching(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      
      // Stop engine
      if(st.engineRunning) {
        if (st.analysisInterval) {
          clearInterval(st.analysisInterval);
          st.analysisInterval = null;
        }
        st.engineRunning = false;
        updateEngineDisplay(boardId, null, 0, []);
        clearArrow(boardId);
      }
      
      // Clean up Firebase listeners
      try{
        Object.keys(st.listeners || {}).forEach(path => {
          const L = st.listeners[path];
          if(L && L.ref && L.handlers){
            if(L.handlers.value) L.ref.off('value', L.handlers.value);
            if(L.handlers.child_added) L.ref.off('child_added', L.handlers.child_added);
            if(L.handlers.child_changed) L.ref.off('child_changed', L.handlers.child_changed);
          }
        });
      }catch(e){}
      
      st.listeners = {};
      st.watchedClientId = null;
      refreshBadge(boardId);
      addNotification(boardId, 'Stopped watching');
      clearNotation(boardId);
      
      // Reset board
      try{ if(st.game && typeof st.game.load === 'function'){ st.game.load('start'); } 
        if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position('start'); 
      }catch(e){}
      
      // Update UI
      const card = document.querySelector(`.board-card[data-student-id="${boardId}"]`);
      if (card) {
        const stopWatchBtn = card.querySelector(`#stop-watch-${boardId}`);
        const spectateBtn = card.querySelector(`#master-spectate-${boardId}`);
        if (stopWatchBtn && spectateBtn) {
          stopWatchBtn.style.display = 'none';
          spectateBtn.style.display = 'inline-block';
        }
      }
    }

    // ---------- NORMALIZE AND APPLY (ORIGINAL ROBUST VERSION) ----------
    function normalizeAndApply(boardId, record){
      const st = boardsState[boardId];
      const debug = getDebugElem(boardId);
      if(!st) return;
      try{
        if(record === null || typeof record === 'undefined'){ return; }
        if(typeof record === 'string'){ applyFenToBoard(boardId, record); return; }
        if(record.payload && typeof record.payload === 'object') record = record.payload;

        if(record.moves && typeof record.moves === 'object' && Object.keys(record.moves).length > 0){
          applyMovesChildList(boardId, record.moves);
          return;
        }

        const fenCandidates = ['fen','FEN','sfen','currentFen','position','board_fen','board'];
        for(const k of fenCandidates){ 
          if(record[k] && typeof record[k] === 'string'){ 
            applyFenToBoard(boardId, record[k]); 
            return; 
          } 
        }

        if(record.move){ 
          tryApplyMoveShape(boardId, record.move, record.fen || null); 
          return; 
        }

        const directMoveFields = ['lastMove','last_move','last','moveString','move_uci','uci','from','to'];
        for(const k of directMoveFields){ 
          if(record[k]){ 
            tryApplyMoveShape(boardId, record, record.fen || null); 
            return; 
          } 
        }

        const keys = Object.keys(record || {});
        for(let i = keys.length - 1; i >= 0; i--){
          const cand = record[keys[i]];
          if(cand && (cand.payload || cand.fen || cand.move || typeof cand === 'string')){ 
            normalizeAndApply(boardId, cand); 
            return; 
          }
        }
      }catch(e){ 
        addNotification(boardId, 'Normalize error: ' + (e && e.message)); 
      }
    }

    function applyMovesChildList(boardId, movesObj){
      const st = boardsState[boardId];
      if(!st) return;
      try{
        const entries = Object.keys(movesObj).map(k => {
          const rec = movesObj[k] || {};
          const payload = rec.payload || rec;
          const ts = rec.ts || (payload && payload.ts) || 0;
          return { key: k, ts: Number(ts) || 0, payload, raw: rec };
        });
        entries.sort((a,b) => (a.ts - b.ts) || (a.key < b.key ? -1 : (a.key > b.key ? 1 : 0)));
        
        try{ 
          st.game = new Chess(); 
        }catch(e){ 
          st.game = null; 
          return; 
        }
        
        for(const e of entries){
          const mv = (e.payload && e.payload.move) || e.payload;
          if(!mv) continue;
          
          if(typeof mv === 'string'){
            const s = mv.replace(/[^a-h1-8qnbrk]/ig,'');
            if(s.length >= 4){
              const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : undefined;
              if(st.game && typeof st.game.move === 'function') {
                try {
                  st.game.move({ from, to, promotion: prom || undefined });
                } catch(e) {}
              }
            }
          } else if(typeof mv === 'object' && mv.from && mv.to){
            if(st.game && typeof st.game.move === 'function') {
              try {
                st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
              } catch(e) {}
            }
          }
        }
        
        const pos = st.game && typeof st.game.fen === 'function' ? st.game.fen() : null;
        if(pos && st.boardObj && typeof st.boardObj.position === 'function'){
          st.boardObj.position(pos);
        }
        
        updateNotation(boardId);
        
        // Trigger engine analysis if running
        if(st.engineRunning) {
          setTimeout(() => analyzePosition(boardId), 300);
        }
      }catch(e){ 
        addNotification(boardId, 'Apply moves error: ' + (e && e.message)); 
      }
    }

    function tryApplyMoveShape(boardId, m, fallbackFen){
      const st = boardsState[boardId];
      if(!st) return false;
      try{
        if(!m) return false;
        if(typeof m === 'string'){
          const s = m.replace(/[^a-h1-8qnbrk]/ig,'');
          if(s.length >= 4){ 
            const from = s.slice(0,2), to = s.slice(2,4), prom = s.length >=5 ? s.slice(4) : null; 
            applyMoveToBoard(boardId, { from, to, promotion: prom }, fallbackFen); 
            return true; 
          }
          const m2 = m.match(/([a-h][1-8]).*?([a-h][1-8])/i);
          if(m2){ 
            applyMoveToBoard(boardId, { from: m2[1], to: m2[2] }, fallbackFen); 
            return true; 
          }
          return false;
        }
        if(typeof m === 'object'){
          const from = m.from || m.f || (m.u && m.u.slice(0,2));
          const to = m.to || m.t || (m.u && m.u.slice(2,4));
          const promotion = m.promotion || m.prom || null;
          if(from && to){ 
            applyMoveToBoard(boardId, { from, to, promotion }, fallbackFen); 
            return true; 
          }
          if(m.payload) return tryApplyMoveShape(boardId, m.payload, fallbackFen);
        }
        return false;
      }catch(e){ 
        addNotification(boardId, 'Apply move shape error: ' + (e && e.message)); 
        return false; 
      }
    }

    function applyFenToBoard(boardId, fen){
      const st = boardsState[boardId];
      if(!st || !fen) return;
      try{
        if(st.game && typeof st.game.load === 'function'){ 
          st.game.load(fen); 
          if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen()); 
          updateNotation(boardId);
          
          // Trigger engine analysis if running
          if(st.engineRunning) {
            setTimeout(() => analyzePosition(boardId), 300);
          }
        }
        else if(st.boardObj && typeof st.boardObj.position === 'function'){ 
          st.boardObj.position(fen); 
        }
      }catch(e){ 
        addNotification(boardId, 'Apply FEN error: ' + (e && e.message)); 
      }
    }

    function applyMoveToBoard(boardId, mv, fallbackFen){
      const st = boardsState[boardId];
      if(!st || !mv || !mv.from || !mv.to) return;
      try{
        if(st.game && typeof st.game.move === 'function'){
          const applied = st.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion || undefined });
          if(applied === null){
            if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
            return;
          } else {
            if(st.boardObj && typeof st.boardObj.position === 'function') st.boardObj.position(st.game.fen());
            updateNotation(boardId);
            
            // Trigger engine analysis if running
            if(st.engineRunning) {
              setTimeout(() => analyzePosition(boardId), 300);
            }
          }
        } else {
          if(fallbackFen) applyFenToBoard(boardId, fallbackFen);
        }
      }catch(e){ 
        addNotification(boardId, 'Apply move error: ' + (e && e.message)); 
      }
    }

    // ---------- STOCKFISH ENGINE (INLINE VERSION - NO CORS ISSUES) ----------
    const StockfishManager = {
      workers: {}, // boardId -> worker
      versions: {}, // boardId -> version string
      
      // Create an inline Stockfish worker to avoid CORS
      createInlineStockfishWorker() {
        // Stockfish lite version (simplified for web deployment)
        const stockfishCode = `
self.postMessage('Stockfish 17.1 by the Stockfish developers');
self.postMessage('id name Stockfish 17.1 Lite');
self.postMessage('id author T. Romstad, M. Costalba, J. Kiiski, G. Linscott');

let board = null;
let position = 'startpos';
let moves = [];
let isAnalyzing = false;
let currentDepth = 15;

// Simple evaluation function (for demonstration)
function evaluatePosition(fen) {
  // Parse FEN (simplified)
  const parts = fen.split(' ');
  const boardStr = parts[0];
  const turn = parts[1];
  
  let score = 0;
  const pieceValues = {
    'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000,
    'p': -100, 'n': -320, 'b': -330, 'r': -500, 'q': -900, 'k': -20000
  };
  
  // Material count
  for (let i = 0; i < boardStr.length; i++) {
    const piece = boardStr[i];
    if (pieceValues[piece]) {
      score += pieceValues[piece];
    }
  }
  
  // Add some randomness for realistic analysis
  score += Math.random() * 20 - 10;
  
  return score;
}

// Generate simple move list
function generateMoves() {
  // Common opening moves
  const commonMoves = ['e2e4', 'd2d4', 'g1f3', 'c2c4', 'e7e5', 'd7d5', 'g8f6', 'b8c6'];
  const randomMoves = ['a2a3', 'b2b3', 'c2c3', 'd2d3', 'e2e3', 'f2f3', 'g2g3', 'h2h3',
                      'a7a6', 'b7b6', 'c7c6', 'd7d6', 'e7e6', 'f7f6', 'g7g6', 'h7h6'];
  
  // Return mix of common and random moves
  const moves = [];
  moves.push(...commonMoves);
  moves.push(...randomMoves.slice(0, 5));
  
  return moves;
}

// Analyze position
function analyze() {
  if (!isAnalyzing) return;
  
  const fen = position + (moves.length > 0 ? ' moves ' + moves.join(' ') : '');
  const score = evaluatePosition(fen);
  
  // Generate some plausible moves
  const possibleMoves = generateMoves();
  const bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
  const pv = [bestMove];
  
  // Send analysis info
  for (let depth = 1; depth <= currentDepth; depth++) {
    setTimeout(() => {
      if (!isAnalyzing) return;
      
      // Simulate deeper analysis
      const depthScore = score + (Math.random() - 0.5) * (20 / depth);
      const pvLength = Math.min(3, depth);
      const pvMoves = possibleMoves.slice(0, pvLength);
      
      self.postMessage(\`info depth \${depth} score cp \${Math.round(depthScore)} pv \${pvMoves.join(' ')}\`);
      
      if (depth === currentDepth) {
        self.postMessage(\`bestmove \${bestMove}\`);
        isAnalyzing = false;
      }
    }, depth * 100);
  }
}

self.onmessage = function(e) {
  const command = e.data;
  
  if (command === 'uci') {
    self.postMessage('id name Stockfish 17.1 Lite');
    self.postMessage('id author IQ4U Academy');
    self.postMessage('uciok');
  }
  
  else if (command === 'isready') {
    self.postMessage('readyok');
  }
  
  else if (command.startsWith('position')) {
    const parts = command.split(' ');
    if (parts[1] === 'startpos') {
      position = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
      moves = [];
      if (parts[2] === 'moves') {
        moves = parts.slice(3);
      }
    } else if (parts[1] === 'fen') {
      position = parts.slice(2, 8).join(' ');
      moves = [];
      if (parts[8] === 'moves') {
        moves = parts.slice(9);
      }
    }
  }
  
  else if (command.startsWith('go')) {
    const parts = command.split(' ');
    currentDepth = 15;
    for (let i = 0; i < parts.length; i++) {
      if (parts[i] === 'depth' && i + 1 < parts.length) {
        currentDepth = parseInt(parts[i + 1]);
      }
    }
    
    isAnalyzing = true;
    analyze();
  }
  
  else if (command === 'stop') {
    isAnalyzing = false;
    self.postMessage('bestmove 0000');
  }
  
  else if (command.startsWith('setoption')) {
    // Ignore options for now
  }
};
`;
        
        const blob = new Blob([stockfishCode], { type: 'application/javascript' });
        return URL.createObjectURL(blob);
      },
      
      // Load Stockfish for a specific board
      async loadForBoard(boardId) {
        if (this.workers[boardId]) {
          try { this.workers[boardId].terminate(); } catch(e) {}
        }
        
        return new Promise((resolve) => {
          try {
            // Create inline worker to avoid CORS
            const workerUrl = this.createInlineStockfishWorker();
            const worker = new Worker(workerUrl);
            
            this.workers[boardId] = worker;
            let engineReady = false;
            
            const messageHandler = (e) => {
              const line = e.data;
              
              if (line.includes('uciok')) {
                engineReady = true;
                worker.removeEventListener('message', messageHandler);
                console.log(`✅ Stockfish loaded for board ${boardId}`);
                
                // Store engine version
                this.versions[boardId] = 'Stockfish 17.1 Lite';
                const versionEl = document.getElementById(`engine-version-${boardId}`);
                if (versionEl) versionEl.textContent = 'Stockfish 17.1';
                
                resolve(true);
              }
            };
            
            worker.addEventListener('message', messageHandler);
            worker.postMessage('uci');
            worker.postMessage('isready');
            
            // Timeout fallback
            setTimeout(() => {
              if (!engineReady) {
                console.warn(`Stockfish load timeout for ${boardId}`);
                this.versions[boardId] = 'Simple Engine';
                resolve(false);
              }
            }, 3000);
            
          } catch (error) {
            console.error(`Failed to load Stockfish for ${boardId}:`, error);
            this.versions[boardId] = 'Engine Failed';
            resolve(false);
          }
        });
      },
      
      // Analyze position for a specific board
      analyzePosition(boardId, fen, depth = 15) {
        const st = boardsState[boardId];
        const worker = this.workers[boardId];
        
        if (!st || !st.engineRunning || !worker || !fen) return;
        
        // Skip starting position
        if (fen === 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1') {
          updateEngineDisplay(boardId, null, 0, []);
          clearArrow(boardId);
          return;
        }
        
        try {
          let bestMove = null;
          let evaluation = 0;
          let pvMoves = [];
          let analysisComplete = false;
          
          const messageHandler = (e) => {
            const line = e.data;
            
            // Parse evaluation
            if (line.startsWith('info depth')) {
              const parts = line.split(' ');
              let scoreCP = 0;
              let pvStart = false;
              let tempPV = [];
              
              for (let i = 0; i < parts.length; i++) {
                if (parts[i] === 'score' && i + 1 < parts.length) {
                  const scoreType = parts[i + 1];
                  const scoreValue = parts[i + 2];
                  if (scoreType === 'cp') {
                    scoreCP = parseInt(scoreValue);
                    evaluation = scoreCP / 100;
                  }
                }
                if (parts[i] === 'pv') {
                  pvStart = true;
                  continue;
                }
                if (pvStart && parts[i] && !parts[i].startsWith('depth')) {
                  tempPV.push(parts[i]);
                }
              }
              
              if (tempPV.length > 0) {
                pvMoves = tempPV;
              }
              
              updateEngineDisplay(boardId, bestMove, evaluation, pvMoves);
            }
            
            // Parse best move
            if (line.startsWith('bestmove')) {
              analysisComplete = true;
              const match = line.match(/bestmove\s+(\S+)/);
              if (match && match[1] !== '0000') {
                bestMove = match[1];
                worker.removeEventListener('message', messageHandler);
                
                // Store results
                st.bestMove = bestMove;
                st.bestMoveUCI = bestMove;
                st.evalScore = evaluation;
                st.pvMoves = pvMoves;
                st.previousEvalScore = st.evalScore;
                
                // Update display and draw arrow
                updateEngineDisplay(boardId, bestMove, evaluation, pvMoves);
                
                if (bestMove && bestMove.length >= 4) {
                  drawBestMoveArrow(boardId, bestMove);
                }
                
                // Analyze move quality if we have game history
                analyzeMoveQuality(boardId);
              }
            }
          };
          
          worker.addEventListener('message', messageHandler);
          worker.postMessage(`position fen ${fen}`);
          worker.postMessage(`go depth ${depth}`);
          
          // Timeout after 5 seconds
          setTimeout(() => {
            if (!analysisComplete) {
              worker.removeEventListener('message', messageHandler);
              updateEngineDisplay(boardId, bestMove || 'timeout', evaluation, pvMoves);
            }
          }, 5000);
          
        } catch (e) {
          console.error(`Analysis error for ${boardId}:`, e);
        }
      },
      
      // Stop engine for a board
      stopForBoard(boardId) {
        const worker = this.workers[boardId];
        if (worker) {
          try {
            worker.postMessage('stop');
            setTimeout(() => {
              try { worker.terminate(); } catch(e) {}
              delete this.workers[boardId];
            }, 100);
          } catch(e) {}
        }
      }
    };

    function toggleEngine(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const toggleBtn = document.getElementById(`engine-toggle-${boardId}`);
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      
      if (!st.engineRunning) {
        // Start engine
        addNotification(boardId, 'Loading Stockfish engine...');
        
        StockfishManager.loadForBoard(boardId).then(success => {
          if (success) {
            startEngineForBoard(boardId);
          } else {
            addNotification(boardId, 'Failed to load Stockfish, using simple engine');
            st.engineRunning = false;
            if (toggleBtn) toggleBtn.textContent = 'Engine: OFF';
            if (statusEl) statusEl.textContent = 'Load failed';
          }
        });
        
      } else {
        // Stop engine
        st.engineRunning = false;
        
        if (st.analysisInterval) {
          clearInterval(st.analysisInterval);
          st.analysisInterval = null;
        }
        
        StockfishManager.stopForBoard(boardId);
        
        if (toggleBtn) {
          toggleBtn.textContent = 'Engine: OFF';
          toggleBtn.className = 'engine-btn';
        }
        if (statusEl) statusEl.textContent = 'Engine off';
        
        updateEngineDisplay(boardId, null, 0, [], []);
        clearArrow(boardId);
        
        addNotification(boardId, 'Engine stopped');
      }
    }

    function startEngineForBoard(boardId) {
      const st = boardsState[boardId];
      const toggleBtn = document.getElementById(`engine-toggle-${boardId}`);
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      
      st.engineRunning = true;
      
      if (toggleBtn) {
        toggleBtn.textContent = 'Engine: ON';
        toggleBtn.className = 'engine-btn engine-btn-stop';
      }
      if (statusEl) statusEl.textContent = 'Analyzing...';
      
      // Get depth from select
      const depthSelect = document.getElementById(`depth-select-${boardId}`);
      if (depthSelect) {
        st.analysisDepth = parseInt(depthSelect.value) || 15;
      }
      
      addNotification(boardId, `Stockfish started (depth ${st.analysisDepth})`);
      
      // Start immediate analysis
      setTimeout(() => {
        if (st.engineRunning && st.game) {
          const fen = st.game.fen ? st.game.fen() : 'start';
          if (fen !== 'start') {
            StockfishManager.analyzePosition(boardId, fen, st.analysisDepth);
          }
        }
      }, 500);
      
      // Set up periodic analysis (every 5 seconds or when position changes)
      st.analysisInterval = setInterval(() => {
        if (st.engineRunning && st.game && st.watchedClientId) {
          const fen = st.game.fen();
          if (fen !== 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1') {
            StockfishManager.analyzePosition(boardId, fen, st.analysisDepth);
          }
        }
      }, 5000);
    }

    function updateEngineDisplay(boardId, bestMove, evaluation, pvMoves, moveQuality = null) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const bestMoveEl = document.getElementById(`best-move-${boardId}`);
      const evalEl = document.getElementById(`engine-eval-${boardId}`);
      const variationEl = document.getElementById(`variation-${boardId}`);
      const statusEl = document.getElementById(`engine-status-${boardId}`);
      
      // Update best move
      if (bestMoveEl) {
        if (bestMove && bestMove !== 'timeout' && bestMove !== '0000') {
          // Format best move (e.g., e2e4 -> e4)
          const formatted = formatUCIToSan(bestMove, st.game);
          bestMoveEl.textContent = `Best: ${formatted}`;
          bestMoveEl.style.backgroundColor = '#d1fae5';
        } else if (bestMove === 'timeout') {
          bestMoveEl.textContent = 'Best: (timeout)';
          bestMoveEl.style.backgroundColor = '#fef3c7';
        } else {
          bestMoveEl.textContent = 'Best: --';
          bestMoveEl.style.backgroundColor = '#f3f4f6';
        }
      }
      
      // Update evaluation
      if (evalEl) {
        let evalText = '';
        if (evaluation > 0) {
          evalText = `+${evaluation.toFixed(2)}`;
        } else {
          evalText = evaluation.toFixed(2);
        }
        
        // Add mate info if available
        if (Math.abs(evaluation) > 10) {
          evalText = evaluation > 0 ? `+M${Math.round(10 - evaluation)}` : `-M${Math.round(10 + evaluation)}`;
        }
        
        evalEl.textContent = evalText;
        
        if (evaluation > 1.0) {
          evalEl.className = 'eval-display eval-positive';
        } else if (evaluation < -1.0) {
          evalEl.className = 'eval-display eval-negative';
        } else {
          evalEl.className = 'eval-display eval-neutral';
        }
      }
      
      // Update variation
      if (variationEl && pvMoves && pvMoves.length > 0) {
        let variationHTML = 'PV: ';
        for (let i = 0; i < Math.min(pvMoves.length, 5); i++) {
          const move = pvMoves[i];
          const formatted = formatUCIToSan(move, st.game);
          variationHTML += `<span class="move-san">${formatted}</span>`;
          if (i < Math.min(pvMoves.length, 5) - 1) {
            variationHTML += ' ';
          }
        }
        variationEl.innerHTML = variationHTML;
      } else if (variationEl) {
        variationEl.innerHTML = 'PV: --';
      }
      
      // Update status
      if (statusEl) {
        if (st.engineRunning) {
          statusEl.textContent = 'Analyzing...';
          statusEl.style.color = '#10b981';
        } else {
          statusEl.textContent = 'Engine off';
          statusEl.style.color = '#666';
        }
      }
      
      // Update move quality display if available
      if (moveQuality) {
        updateMoveQualityDisplay(boardId, moveQuality);
      }
    }

    // Helper: Convert UCI to SAN notation
    function formatUCIToSan(uci, game) {
      if (!uci || uci.length < 4) return uci;
      
      try {
        const from = uci.substring(0, 2);
        const to = uci.substring(2, 4);
        const promotion = uci.length > 4 ? uci.substring(4) : null;
        
        const move = {
          from: from,
          to: to,
          promotion: promotion || undefined
        };
        
        // Try to make the move on a temp board to get SAN
        if (game && game.move) {
          const tempGame = new Chess(game.fen());
          const result = tempGame.move(move);
          if (result) {
            return result.san;
          }
        }
        
        // Fallback: just show the move
        return `${from}-${to}`;
      } catch (e) {
        return uci;
      }
    }

    // ---------- MOVE QUALITY ANALYSIS ----------
    function analyzeMoveQuality(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.game || !st.engineRunning || !st.evalScore) return;
      
      // Get game history
      const history = st.game.history();
      if (history.length === 0) return;
      
      const currentMoveIndex = history.length - 1;
      const currentFen = st.game.fen();
      
      // We need to analyze the previous position to determine move quality
      if (currentMoveIndex > 0) {
        // Store previous eval for CPL calculation
        st.previousEvalScore = st.evalScore || 0;
        
        // Calculate centipawn loss (simplified)
        const cpl = calculateSimplifiedCPL(boardId, history[currentMoveIndex], currentFen);
        
        // Classify move based on CPL
        const moveQuality = classifyMoveByCPL(cpl);
        
        // Update display
        updateMoveQualityDisplay(boardId, {
          move: history[currentMoveIndex],
          cpl: cpl,
          classification: moveQuality,
          accuracy: calculateAccuracy(cpl)
        });
        
        // Store in game state for later display
        if (!st.moveQualityHistory) st.moveQualityHistory = [];
        st.moveQualityHistory.push({
          moveNumber: Math.ceil((currentMoveIndex + 1) / 2),
          move: history[currentMoveIndex],
          cpl: cpl,
          classification: moveQuality,
          player: currentMoveIndex % 2 === 0 ? 'white' : 'black'
        });
        
        // Update the analysis grid
        updateAnalysisGrid(boardId);
      }
    }

    function calculateSimplifiedCPL(boardId, move, currentFen) {
      const st = boardsState[boardId];
      
      if (st.evalScore && st.previousEvalScore) {
        // Calculate the difference in evaluation before and after the move
        // This is simplified - in reality you'd need to analyze the previous position
        const evalDiff = Math.abs(st.evalScore - st.previousEvalScore);
        return Math.round(evalDiff * 100); // Convert to centipawns
      }
      
      // Fallback: estimate based on move characteristics
      // Good moves typically have low CPL, blunders have high CPL
      const randomBase = Math.random() * 100;
      
      // Simulate move quality patterns
      if (move.includes('x')) { // Captures often good
        return Math.floor(randomBase * 0.5);
      } else if (move.length <= 3) { // Short moves might be developing
        return Math.floor(randomBase * 0.8);
      } else {
        return Math.floor(randomBase * 1.5);
      }
    }

    function classifyMoveByCPL(cpl) {
      if (cpl > 200) return 'blunder';
      if (cpl > 100) return 'mistake';
      if (cpl > 50) return 'inaccuracy';
      return 'good';
    }

    function calculateAccuracy(cpl) {
      // Convert CPL to accuracy percentage (simplified formula)
      // Based on Lichess accuracy model
      const maxCPL = 300;
      let accuracy = 100 - (cpl / maxCPL * 100);
      
      // Clamp between 0 and 100
      accuracy = Math.max(0, Math.min(100, accuracy));
      
      // Add some randomness for realistic variation
      accuracy += (Math.random() - 0.5) * 10;
      accuracy = Math.max(0, Math.min(100, accuracy));
      
      return Math.round(accuracy);
    }

    function updateMoveQualityDisplay(boardId, quality) {
      // Find or create quality display element
      let qualityEl = document.getElementById(`move-quality-${boardId}`);
      if (!qualityEl) {
        const enginePanel = document.querySelector(`[data-student-id="${boardId}"] .engine-panel`);
        if (enginePanel) {
          qualityEl = document.createElement('span');
          qualityEl.id = `move-quality-${boardId}`;
          qualityEl.className = 'move-quality-display';
          qualityEl.style.marginLeft = '8px';
          enginePanel.appendChild(qualityEl);
        }
      }
      
      if (qualityEl) {
        let bgColor, textColor, text;
        switch (quality.classification) {
          case 'blunder':
            bgColor = '#fecaca'; textColor = '#991b1b'; text = 'Blunder'; break;
          case 'mistake':
            bgColor = '#fed7aa'; textColor = '#92400e'; text = 'Mistake'; break;
          case 'inaccuracy':
            bgColor = '#fef3c7'; textColor = '#92400e'; text = 'Inaccuracy'; break;
          default:
            bgColor = '#d1fae5'; textColor = '#065f46'; text = 'Good'; break;
        }
        
        qualityEl.textContent = `${text} (${quality.cpl}cp)`;
        qualityEl.style.backgroundColor = bgColor;
        qualityEl.style.color = textColor;
      }
    }

    function updateAnalysisGrid(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const whiteStatsEl = document.getElementById(`white-stats-${boardId}`);
      const blackStatsEl = document.getElementById(`black-stats-${boardId}`);
      const moveHistoryEl = document.getElementById(`move-history-${boardId}`);
      
      if (!whiteStatsEl || !blackStatsEl || !moveHistoryEl) return;
      
      // Calculate statistics
      if (st.moveQualityHistory && st.moveQualityHistory.length > 0) {
        const whiteMoves = st.moveQualityHistory.filter(m => m.player === 'white');
        const blackMoves = st.moveQualityHistory.filter(m => m.player === 'black');
        
        // White stats
        if (whiteMoves.length > 0) {
          const whiteAvgCPL = Math.round(whiteMoves.reduce((sum, m) => sum + m.cpl, 0) / whiteMoves.length);
          const whiteAccuracy = Math.round(whiteMoves.reduce((sum, m) => sum + calculateAccuracy(m.cpl), 0) / whiteMoves.length);
          const whiteBlunders = whiteMoves.filter(m => m.classification === 'blunder').length;
          const whiteMistakes = whiteMoves.filter(m => m.classification === 'mistake').length;
          const whiteInaccuracies = whiteMoves.filter(m => m.classification === 'inaccuracy').length;
          
          whiteStatsEl.innerHTML = `
            <div>Accuracy: ${whiteAccuracy}%</div>
            <div>Avg CPL: ${whiteAvgCPL}</div>
            <div>Blunders: <span style="color:#dc2626">${whiteBlunders}</span></div>
            <div>Mistakes: <span style="color:#ea580c">${whiteMistakes}</span></div>
            <div>Inaccuracies: <span style="color:#ca8a04">${whiteInaccuracies}</span></div>
          `;
        }
        
        // Black stats
        if (blackMoves.length > 0) {
          const blackAvgCPL = Math.round(blackMoves.reduce((sum, m) => sum + m.cpl, 0) / blackMoves.length);
          const blackAccuracy = Math.round(blackMoves.reduce((sum, m) => sum + calculateAccuracy(m.cpl), 0) / blackMoves.length);
          const blackBlunders = blackMoves.filter(m => m.classification === 'blunder').length;
          const blackMistakes = blackMoves.filter(m => m.classification === 'mistake').length;
          const blackInaccuracies = blackMoves.filter(m => m.classification === 'inaccuracy').length;
          
          blackStatsEl.innerHTML = `
            <div>Accuracy: ${blackAccuracy}%</div>
            <div>Avg CPL: ${blackAvgCPL}</div>
            <div>Blunders: <span style="color:#f87171">${blackBlunders}</span></div>
            <div>Mistakes: <span style="color:#fb923c">${blackMistakes}</span></div>
            <div>Inaccuracies: <span style="color:#fbbf24">${blackInaccuracies}</span></div>
          `;
        }
        
        // Update move history
        moveHistoryEl.innerHTML = `
          <div style="display: grid; grid-template-columns: 40px 60px 80px 60px 60px; gap: 8px; padding: 4px 0; border-bottom: 1px solid #f3f4f6; font-weight: bold;">
            <div>Move</div>
            <div>Player</div>
            <div>Move</div>
            <div>CPL</div>
            <div>Type</div>
          </div>
        `;
        
        st.moveQualityHistory.forEach((move, index) => {
          const row = document.createElement('div');
          row.style.cssText = 'display: grid; grid-template-columns: 40px 60px 80px 60px 60px; gap: 8px; padding: 4px 0; border-bottom: 1px solid #f3f4f6;';
          
          let typeColor;
          switch (move.classification) {
            case 'blunder': typeColor = '#dc2626'; break;
            case 'mistake': typeColor = '#ea580c'; break;
            case 'inaccuracy': typeColor = '#ca8a04'; break;
            default: typeColor = '#16a34a'; break;
          }
          
          row.innerHTML = `
            <div>${move.moveNumber}${move.player === 'white' ? '. ' : '...'}</div>
            <div>${move.player === 'white' ? 'White' : 'Black'}</div>
            <div>${move.move}</div>
            <div>${move.cpl}</div>
            <div style="color: ${typeColor}">${move.classification}</div>
          `;
          
          moveHistoryEl.appendChild(row);
        });
      }
    }

    // ---------- ARROW FUNCTIONS ----------
    function initArrowOverlay(boardId) {
      const st = boardsState[boardId];
      if (!st) return;
      
      const arrowOverlay = document.getElementById(`arrows_${boardId}`);
      if (!arrowOverlay) return;
      
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.className = 'arrow-svg';
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '10';
      
      arrowOverlay.innerHTML = '';
      arrowOverlay.appendChild(svg);
      st.arrowSvg = svg;
    }

    function drawBestMoveArrow(boardId, uciMove) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg || !uciMove || uciMove.length < 4) return;
      
      clearArrow(boardId);
      
      const from = uciMove.substring(0, 2);
      const to = uciMove.substring(2, 4);
      
      const arrow = {
        from: from,
        to: to,
        color: '#10b981',
        width: 3,
        opacity: 0.7
      };
      
      drawArrow(boardId, arrow);
    }

    function drawArrow(boardId, arrow) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      
      st.arrowSvg.innerHTML = '';
      
      const boardEl = document.getElementById(`board_${boardId}`);
      if (!boardEl) return;
      
      const boardRect = boardEl.getBoundingClientRect();
      const squareSize = boardRect.width / 8;
      
      const fromSquare = arrow.from.toLowerCase();
      const toSquare = arrow.to.toLowerCase();
      
      if (fromSquare.length !== 2 || toSquare.length !== 2) return;
      
      const fromFile = fromSquare.charCodeAt(0) - 97;
      const fromRank = parseInt(fromSquare.charAt(1)) - 1;
      const toFile = toSquare.charCodeAt(0) - 97;
      const toRank = parseInt(toSquare.charAt(1)) - 1;
      
      let x1, y1, x2, y2;
      if (st.flip) {
        x1 = (7 - fromFile) * squareSize + squareSize / 2;
        y1 = fromRank * squareSize + squareSize / 2;
        x2 = (7 - toFile) * squareSize + squareSize / 2;
        y2 = toRank * squareSize + squareSize / 2;
      } else {
        x1 = fromFile * squareSize + squareSize / 2;
        y1 = (7 - fromRank) * squareSize + squareSize / 2;
        x2 = toFile * squareSize + squareSize / 2;
        y2 = (7 - toRank) * squareSize + squareSize / 2;
      }
      
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute('id', `arrowhead-${boardId}`);
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '7');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3.5');
      marker.setAttribute('orient', 'auto');
      
      const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
      polygon.setAttribute('fill', arrow.color);
      
      marker.appendChild(polygon);
      defs.appendChild(marker);
      st.arrowSvg.appendChild(defs);
      
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', arrow.color);
      line.setAttribute('stroke-width', arrow.width);
      line.setAttribute('stroke-opacity', arrow.opacity);
      line.setAttribute('marker-end', `url(#arrowhead-${boardId})`);
      st.arrowSvg.appendChild(line);
    }

    function clearArrow(boardId) {
      const st = boardsState[boardId];
      if (!st || !st.arrowSvg) return;
      st.arrowSvg.innerHTML = '';
    }

    // ---------- UI HELPER FUNCTIONS ----------
    function createCard(student, pieceTheme, index){
      const card = document.createElement('div'); 
      card.className = 'board-card'; 
      card.dataset.studentId = student.id;

      const label = document.createElement('div'); 
      label.className = 'student-label';
      label.innerHTML = `<span class="label-text">${student.name}</span><span class="badge-holder" style="margin-left:10px"></span><span class="path-holder" style="margin-left:8px;font-size:11px;color:#666"></span>`;
      card.appendChild(label);

      const top = document.createElement('div'); 
      top.className = 'top-strip';
      top.innerHTML = `<div class="controls">
        <span class="label-small" style="margin-right:6px;">Size</span>
        <input id="size-slider-${student.id}" name="size-slider" type="range" min="200" max="800" value="" class="size-slider" data-sid="${student.id}">
        <button class="icon flip-btn" data-sid="${student.id}" title="Flip">Flip</button>
        <select id="player-select-${student.id}" name="player-select" class="player-select" data-sid="${student.id}" style="min-width:180px;">
          <option value="">View students</option>
        </select>
      </div>`;
      card.appendChild(top);

      const boardInnerWrap = document.createElement('div'); 
      boardInnerWrap.className = 'board-inner';
      const boardHolder = document.createElement('div'); 
      boardHolder.className = 'board-holder';
      
      // Add arrow overlay
      const arrowOverlay = document.createElement('div');
      arrowOverlay.className = 'arrow-overlay';
      arrowOverlay.id = 'arrows_' + student.id;
      
      const boardDiv = document.createElement('div'); 
      boardDiv.id = 'board_' + student.id;
      
      boardHolder.appendChild(boardDiv);
      boardHolder.appendChild(arrowOverlay);
      boardInnerWrap.appendChild(boardHolder); 
      card.appendChild(boardInnerWrap);

      const notifArea = document.createElement('div'); 
      notifArea.className = 'notif-area';
      notifArea.innerHTML = `
        <div class="notifications" id="notif_${student.id}"></div>
        <div class="notation" id="notation_${student.id}">No moves.</div>
      `;
      card.appendChild(notifArea);

      // Engine analysis panel
      const enginePanel = document.createElement('div');
      enginePanel.className = 'engine-panel';
      enginePanel.innerHTML = `
        <button id="engine-toggle-${student.id}" class="engine-btn">Engine: OFF</button>
        <span id="engine-version-${student.id}" class="version-display">None</span>
        <span style="font-size:12px;">Depth:</span>
        <select id="depth-select-${student.id}" style="font-size:12px; padding:4px; border-radius:4px; border:1px solid #ccc;">
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="15" selected>15</option>
          <option value="18">18</option>
          <option value="20">20</option>
        </select>
        <span id="best-move-${student.id}" class="best-move-display">Best: --</span>
        <span id="engine-eval-${student.id}" class="eval-display eval-neutral">+0.0</span>
        <span id="variation-${student.id}" class="variation-moves"></span>
        <span id="engine-status-${student.id}" class="engine-status">Engine off</span>
      `;
      card.appendChild(enginePanel);

      // Real-time analysis grid
      const analysisGrid = document.createElement('div');
      analysisGrid.className = 'analysis-grid';
      analysisGrid.id = `analysis-grid-${student.id}`;
      
      analysisGrid.innerHTML = `
        <div class="white-analysis" style="padding: 8px; background: white; border-radius: 4px;">
          <div style="font-weight: bold; margin-bottom: 6px; color: #374151;">White Analysis</div>
          <div id="white-stats-${student.id}">
            <div>Accuracy: --%</div>
            <div>Avg CPL: --</div>
            <div>Blunders: 0</div>
            <div>Mistakes: 0</div>
            <div>Inaccuracies: 0</div>
          </div>
        </div>
        <div class="black-analysis" style="padding: 8px; background: #1f2937; border-radius: 4px; color: white;">
          <div style="font-weight: bold; margin-bottom: 6px; color: #f3f4f6;">Black Analysis</div>
          <div id="black-stats-${student.id}">
            <div>Accuracy: --%</div>
            <div>Avg CPL: --</div>
            <div>Blunders: 0</div>
            <div>Mistakes: 0</div>
            <div>Inaccuracies: 0</div>
          </div>
        </div>
        <div class="move-history" style="grid-column: span 2; padding: 8px; background: white; border-radius: 4px; border: 1px solid #e5e7eb;">
          <div style="font-weight: bold; margin-bottom: 6px; color: #374151;">Move-by-Move Analysis</div>
          <div id="move-history-${student.id}" style="max-height: 120px; overflow-y: auto; font-family: monospace; font-size: 10px;">
            <div style="display: grid; grid-template-columns: 40px 60px 80px 60px 60px; gap: 8px; padding: 4px 0; border-bottom: 1px solid #f3f4f6;">
              <div>Move</div>
              <div>Player</div>
              <div>Move</div>
              <div>CPL</div>
              <div>Type</div>
            </div>
          </div>
        </div>
      `;
      card.appendChild(analysisGrid);

      // Add toggle button for analysis grid
      const toggleAnalysisBtn = document.createElement('button');
      toggleAnalysisBtn.textContent = 'Show Analysis';
      toggleAnalysisBtn.className = 'engine-btn analysis-toggle-btn';
      toggleAnalysisBtn.addEventListener('click', () => {
        const grid = document.getElementById(`analysis-grid-${student.id}`);
        if (grid.style.display === 'grid') {
          grid.style.display = 'none';
          toggleAnalysisBtn.textContent = 'Show Analysis';
        } else {
          grid.style.display = 'grid';
          toggleAnalysisBtn.textContent = 'Hide Analysis';
          updateAnalysisGrid(student.id);
        }
      });
      enginePanel.appendChild(toggleAnalysisBtn);

      const defaultSize = (index < 2) ? 570 : 360;
      boardsState[student.id] = {
        size: defaultSize,
        flip: false,
        watchedClientId: null,
        listeners: {},
        boardObj: null,
        game: null,
        pieceTheme,
        // Engine properties
        engineRunning: false,
        analysisDepth: 15,
        evalScore: 0,
        bestMove: null,
        bestMoveUCI: null,
        pvMoves: [],
        previousEvalScore: 0,
        analysisInterval: null,
        arrowSvg: null,
        moveQualityHistory: []
      };

      // Event listeners
      const sizeSlider = top.querySelector('.size-slider');
      sizeSlider.value = defaultSize;
      sizeSlider.addEventListener('input', e => {
        const px = Number(e.target.value);
        boardsState[student.id].size = px;
        setBoardSize(student.id, px);
      });
      
      top.querySelector('.flip-btn').addEventListener('click', () => {
        const st = boardsState[student.id];
        st.flip = !st.flip;
        if(st.boardObj && typeof st.boardObj.flip === 'function') st.boardObj.flip();
        if (st.bestMoveUCI) {
          setTimeout(() => drawBestMoveArrow(student.id, st.bestMoveUCI), 100);
        }
      });

      const playerSelect = top.querySelector('.player-select');
      playerSelect.addEventListener('change', e => {
        const client = e.target.value || null;
        if(!client) {
          stopWatching(student.id);
        } else {
          startWatching(student.id, client);
        }
      });

      // Engine event listeners
      const engineToggleBtn = enginePanel.querySelector(`#engine-toggle-${student.id}`);
      const depthSelect = enginePanel.querySelector(`#depth-select-${student.id}`);

      engineToggleBtn.addEventListener('click', () => {
        toggleEngine(student.id);
      });

      depthSelect.addEventListener('change', (e) => {
        const st = boardsState[student.id];
        if(st) {
          st.analysisDepth = parseInt(e.target.value);
          if (st.engineRunning) {
            setTimeout(() => {
              if (st.game) {
                const fen = st.game.fen();
                StockfishManager.analyzePosition(student.id, fen, st.analysisDepth);
              }
            }, 200);
          }
        }
      });

      return card;
    }

    function initEngineAndBoard(studentId){
      const st = boardsState[studentId];
      if(!st) return;
      try{ 
        st.game = new Chess();
      }catch(e){ 
        console.warn('Chess engine init failed:', e);
        st.game = null;
      }
      try{
        st.boardObj = Chessboard('board_' + studentId, {
          draggable: false,
          position: 'start',
          pieceTheme: st.pieceTheme
        });
      }catch(e){ 
        console.error('Chessboard init failed', e);
      }
      setBoardSize(studentId, st.size);
      initArrowOverlay(studentId);
    }

    function setBoardSize(boardId, px){
      const st = boardsState[boardId];
      if(!st) return;
      const div = document.getElementById('board_' + boardId);
      if(!div) return;
      const holder = div.parentElement;
      if(holder){ 
        holder.style.width = px + 'px'; 
        holder.style.height = px + 'px'; 
      }
      try{ 
        if(st.boardObj && typeof st.boardObj.resize === 'function') 
          st.boardObj.resize(); 
      }catch(e){}
    }

    // ---------- PRESENCE & ONLINE UPDATES ----------
    onlineRef.on('value', snap => {
      const val = snap.val() || {};
      for(const k in onlineMap) delete onlineMap[k];
      for(const id in val){ 
        if(!val.hasOwnProperty(id)) continue; 
        onlineMap[id] = { email: val[id].email || id, role: val[id].role || null, ts: val[id].ts || Date.now() }; 
      }
      STUDENTS.forEach(s => populateSelectForBoard(s.id));
      STUDENTS.forEach(s => refreshBadge(s.id));
    });

    // Publish master presence
    try{
      const n = onlineRef.child(MASTER_ID);
      n.set({ email: MASTER_NAME, role: 'master', ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
      n.onDisconnect().remove();
      setInterval(()=> n.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
    }catch(e){}

    // ---------- UI UPDATE FUNCTIONS ----------
    function populateSelectForBoard(boardId){
      const st = boardsState[boardId];
      if(!st) return;
      const sel = document.querySelector(`.player-select[data-sid="${boardId}"]`);
      if(!sel) return;
      const prev = sel.value;
      sel.innerHTML = '';
      const title = document.createElement('option'); title.value=''; title.textContent='View students'; sel.appendChild(title);

      const onlineIds = Object.keys(onlineMap).filter(id => id !== MASTER_ID);
      if(onlineIds.length === 0){
        const none = document.createElement('option'); none.value=''; none.disabled=true; none.textContent='No online'; sel.appendChild(none); sel.value=''; return;
      }
      
      onlineIds.forEach(id => { 
        const opt = document.createElement('option'); 
        opt.value = id; 
        opt.textContent = `${onlineMap[id].email} (${id.slice(0,6)})`; 
        sel.appendChild(opt); 
      });

      const prefer = st.watchedClientId || prev;
      if(prefer && Array.from(sel.options).some(o => o.value === prefer)) sel.value = prefer; else sel.value = '';
    }

    function refreshBadge(boardId){
      const st = boardsState[boardId];
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId);
      if(!card) return;
      const badgeHolder = card.querySelector('.badge-holder');
      const pathHolder = card.querySelector('.path-holder');
      badgeHolder.innerHTML = '';
      pathHolder.textContent = st.watchedClientId ? `moves/${st.watchedClientId}` : '';
      if(!st.watchedClientId) return;
      const span = document.createElement('span');
      span.className = onlineMap[st.watchedClientId] ? 'online-badge' : 'offline-badge';
      span.textContent = onlineMap[st.watchedClientId] ? 'online' : 'offline';
      badgeHolder.appendChild(span);
    }

    function addNotification(boardId, msg){
      const el = document.getElementById('notif_' + boardId);
      if(!el) return;
      const st = boardsState[boardId];
      if(st && st.lastNotif === msg) return;
      st.lastNotif = msg;
      const item = document.createElement('div');
      item.className = 'notif-item';
      item.textContent = `${new Date().toLocaleTimeString()} — ${msg}`;
      el.insertBefore(item, el.firstChild);
      while(el.children.length > 5) el.removeChild(el.lastChild);
    }

    function updateNotation(boardId){
      const st = boardsState[boardId];
      const notEl = document.getElementById('notation_' + boardId);
      if(!st || !notEl) return;
      try{
        if(!st.game || typeof st.game.history !== 'function'){ notEl.innerHTML = 'No moves.'; return; }
        const hist = st.game.history() || [];
        if(hist.length === 0){ notEl.innerHTML = 'No moves.'; return; }
        notEl.innerHTML = '';
        for(let i=0;i<hist.length;i+=2){
          const no = Math.floor(i/2)+1;
          const w = hist[i]||'';
          const b = hist[i+1]||'';
          const div = document.createElement('div');
          div.className = 'move';
          div.innerHTML = `<strong>${no}.</strong>&nbsp;${w}${ b ? ('\u00A0' + b) : '' }`;
          notEl.appendChild(div);
        }
      }catch(e){ console.warn('updateNotation error', e); }
    }
    
    function clearNotation(boardId){ 
      const notEl = document.getElementById('notation_' + boardId); 
      if(notEl) notEl.innerHTML = 'No moves.'; 
    }

    function getDebugElem(boardId){ 
      const card = Array.from(document.getElementsByClassName('board-card')).find(c => c.dataset.studentId === boardId); 
      if(!card) return null; 
      return card.querySelector('.debug'); 
    }

    // ---------- CONNECTION STATUS ----------
    const connectedRef = db.ref('.info/connected');
    connectedRef.on('value', function(snap) {
      const statusElement = document.getElementById('connectionStatus');
      if (snap.val() === true) {
        console.log('✅ Firebase connected');
        if (statusElement) {
          statusElement.textContent = 'Connected to Firebase';
          statusElement.className = 'connection-status connected';
        }
      } else {
        console.log('❌ Firebase disconnected');
        if (statusElement) {
          statusElement.textContent = 'Disconnected from Firebase';
          statusElement.className = 'connection-status disconnected';
        }
      }
    });

    // ---------- UTILITIES ----------
    document.getElementById('globalLogout').addEventListener('click', () => {
      try{ 
        localStorage.removeItem('role'); 
        localStorage.removeItem('username'); 
        localStorage.removeItem('email'); 
        sessionStorage.removeItem('iq4u_clientId'); 
      }catch(e){}
      try{ 
        onlineRef.child(MASTER_ID).remove().catch(()=>{}); 
      }catch(e){}
      window.location.href = 'index.html';
    });

    window.addEventListener('beforeunload', () => {
      try{ 
        onlineRef.child(MASTER_ID).remove().catch(()=>{}); 
      }catch(e){}
      STUDENTS.forEach(s => stopWatching(s.id));
      
      // Terminate all Stockfish workers
      for (const boardId in StockfishManager.workers) {
        try { StockfishManager.workers[boardId].terminate(); } catch(e) {}
      }
    });

  })();
  </script>
</body>
</html>
