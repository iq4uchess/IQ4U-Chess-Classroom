<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U Student — PGN Loader (pgn-parser)</title>

  <!-- Chessground CSS -->
  <link rel="stylesheet" href="https://unpkg.com/chessground@8.2.0/dist/chessground.min.css">

  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f6f7fb; color:#222; margin:16px; }
    .wrap { display:flex; gap:20px; align-items:flex-start; }
    .left { width:480px; }
    .right { flex:1; min-width:360px; }
    .board-box { background:white; padding:14px; border-radius:12px; box-shadow:0 6px 18px rgba(20,20,40,0.06); }
    .controls { margin-top:12px; display:flex; gap:8px; }
    button { border:0; background:#0b2545; color:white; padding:8px 12px; border-radius:8px; cursor:pointer; }
    button.secondary { background:#2d4a6d; }
    textarea { width:100%; min-height:150px; font-family: monospace; font-size:13px; padding:10px; border-radius:8px; border:1px solid #e3e7ef; box-sizing:border-box; }
    .moves-box { background:white; padding:12px; border-radius:12px; box-shadow:0 6px 18px rgba(20,20,40,0.04); min-height:220px; }
    .move-list { max-height:360px; overflow:auto; padding:6px; font-family:inherit; }
    .move-item { padding:6px 8px; border-radius:6px; display:inline-block; margin:4px; background:#f1f5f9; cursor:pointer; }
    .move-item.current { background:#cfe6ff; }
    small.meta { display:block; margin-top:8px; color:#555; }
    .finfo { margin-top:8px; color:#333; font-size:13px; }
    .top-buttons { display:flex; gap:8px; justify-content:flex-end; margin-bottom:10px; }
  </style>
</head>
<body>

  <div class="top-buttons">
    <button id="undoBtn" class="secondary">Undo</button>
    <button id="prevBtn" class="secondary">Previous</button>
    <button id="nextBtn" class="secondary">Next</button>
    <button id="flipBtn">Flip</button>
  </div>

  <div class="wrap">
    <div class="left board-box">
      <div id="board" style="width:100%;"></div>

      <div class="controls" style="margin-top:12px;">
        <label for="orientationSelect">Orientation:</label>
        <select id="orientationSelect" style="margin-left:6px;">
          <option value="white">White</option>
          <option value="black">Black</option>
        </select>
        <div style="flex:1"></div>
        <button id="loadFenBtn" class="secondary">Load FEN</button>
      </div>

      <div class="finfo">
        <div><strong>FEN:</strong> <span id="fenText">loading...</span></div>
        <div><strong>Turn:</strong> <span id="turnText">-</span></div>
      </div>
    </div>

    <div class="right">
      <div class="board-box" style="margin-bottom:12px;">
        <div style="display:flex; gap:8px; align-items:flex-start;">
          <div style="flex:1">
            <label><strong>PGN / FEN Input</strong></label>
            <textarea id="pgnTextarea" placeholder="Paste Lichess-style PGN or FEN here..."></textarea>
          </div>
          <div style="width:120px; display:flex; flex-direction:column; gap:8px;">
            <button id="loadPgnBtn">Load PGN</button>
            <button id="clearBtn" class="secondary">Clear</button>
            <button id="resetBtn" class="secondary">Reset</button>
          </div>
        </div>
      </div>

      <div class="moves-box">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>Moves</strong>
          <small id="movesCount" style="color:#666">No moves yet.</small>
        </div>
        <div id="moveList" class="move-list"></div>
      </div>

    </div>
  </div>

  <!-- Libraries -->
  <!-- pgn-parser (mliebelt) -->
  <script src="https://cdn.jsdelivr.net/npm/@mliebelt/pgn-parser@1.5.2/lib/pgn-parser.js"></script>

  <!-- chess.js (game state) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>

  <!-- Chessground -->
  <script src="https://unpkg.com/chessground@8.2.0/dist/chessground.min.js"></script>

  <script>
    // Safety checks
    if (typeof pgnParser === 'undefined') console.warn('pgnParser not loaded!');
    if (typeof Chess === 'undefined') console.warn('chess.js not loaded!');
    if (typeof Chessground === 'undefined') console.warn('Chessground not loaded!');

    // Create chess.js game & Chessground board
    const game = new Chess();
    const cg = Chessground(document.getElementById('board'), {
      fen: game.fen(),
      movable: { free: false, color: 'both' },
      viewOnly: true,
      orientation: 'white',
      coordinates: true
    });

    // UI references
    const pgnTextarea = document.getElementById('pgnTextarea');
    const loadPgnBtn = document.getElementById('loadPgnBtn');
    const clearBtn = document.getElementById('clearBtn');
    const resetBtn = document.getElementById('resetBtn');
    const moveListEl = document.getElementById('moveList');
    const movesCountEl = document.getElementById('movesCount');
    const fenText = document.getElementById('fenText');
    const turnText = document.getElementById('turnText');
    const loadFenBtn = document.getElementById('loadFenBtn');
    const orientationSelect = document.getElementById('orientationSelect');
    const undoBtn = document.getElementById('undoBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const flipBtn = document.getElementById('flipBtn');

    // State for navigation
    let mainlineMoves = []; // array of SAN strings (mainline)
    let mainlineComments = []; // comments associated (for display)
    let currentIndex = 0; // 0 = start position, index N = after N moves

    // Helper: update displayed FEN and turn
    function refreshInfo() {
      fenText.textContent = game.fen();
      turnText.textContent = game.turn() === 'w' ? 'White' : 'Black';
    }

    // Helper: render board from game
    function renderBoard() {
      cg.set({ fen: game.fen() });
      refreshInfo();
    }

    // Flatten mainline: best-effort from pgn-parser output
    function extractMainline(parsed) {
      // parsed is an array of games; we take first
      if (!parsed || !parsed.length) return [];
      const g = parsed[0];

      // Moves can be nested; we walk sequentially picking the 'move' at top level
      const moves = [];
      const comments = [];

      const topMoves = g.moves || [];
      for (const m of topMoves) {
        // If entry has a 'move' property, we treat it as mainline move.
        // pgn-parser sometimes stores SAN in m.move or m.san. Check both.
        if (m.move || m.san) {
          const san = m.move || m.san;
          moves.push(san);
          // comments: combine m.after and m.comment if present
          let c = '';
          if (m.comment) c += m.comment + ' ';
          if (m.after && m.after.comment) c += m.after.comment;
          comments.push(c.trim());
        } else {
          // if no move, skip
        }
      }

      return { moves, comments, tags: g.headers || {} };
    }

    // Build move list UI
    function buildMoveList() {
      moveListEl.innerHTML = '';
      if (!mainlineMoves.length) {
        movesCountEl.textContent = 'No moves yet.';
        return;
      }

      movesCountEl.textContent = mainlineMoves.length + ' moves';

      // render each move as clickable token; highlights current
      mainlineMoves.forEach((san, i) => {
        // show move number for white moves
        const moveNumber = Math.floor(i / 2) + 1;
        const side = (i % 2 === 0) ? 'w' : 'b';
        const token = document.createElement('span');
        token.className = 'move-item' + (i === currentIndex - 1 ? ' current' : '');
        token.title = mainlineComments[i] || '';
        token.textContent = (side === 'w') ? (moveNumber + '. ' + san) : (san);
        token.dataset.index = i + 1; // to jump to that ply (1-based)
        token.addEventListener('click', () => {
          jumpToPly(parseInt(token.dataset.index, 10));
        });
        moveListEl.appendChild(token);
      });
      highlightCurrent();
    }

    function highlightCurrent() {
      const items = moveListEl.querySelectorAll('.move-item');
      items.forEach(el => {
        const idx = parseInt(el.dataset.index, 10);
        if (idx === currentIndex) el.classList.add('current'); else el.classList.remove('current');
      });
    }

    // Jump navigation: apply moves from start to ply N
    function jumpToPly(ply) {
      // ply is number of plies to apply (0..mainlineMoves.length)
      if (ply < 0) ply = 0;
      if (ply > mainlineMoves.length) ply = mainlineMoves.length;
      game.reset();
      for (let i = 0; i < ply; i++) {
        try {
          game.move(mainlineMoves[i], { sloppy: true });
        } catch (e) {
          console.warn('Failed to apply move', mainlineMoves[i], e);
          break;
        }
      }
      currentIndex = ply;
      renderBoard();
      buildMoveList();
    }

    // Next & Prev handlers
    function nextPly() {
      if (currentIndex < mainlineMoves.length) {
        jumpToPly(currentIndex + 1);
      }
    }
    function prevPly() {
      if (currentIndex > 0) {
        jumpToPly(currentIndex - 1);
      }
    }

    // Undo last applied move (only when at end)
    function undoLast() {
      if (game.history().length > 0) {
        game.undo();
        currentIndex = game.history().length;
        renderBoard();
        buildMoveList();
      }
    }

    // Reset board & state
    function resetBoard() {
      game.reset();
      mainlineMoves = [];
      mainlineComments = [];
      currentIndex = 0;
      renderBoard();
      buildMoveList();
    }

    // Load PGN using pgn-parser then build mainline
    function loadPgnText(pgnText) {
      if (!pgnText || !pgnText.trim()) {
        alert('Paste a PGN or FEN first.');
        return;
      }

      // If the user pasted a single FEN (no moves) — detect and load directly
      const isFenOnly = /^[rnbqkpRNBQKP1-8]+\/.*\s(w|b)\s(-|K?Q?k?q?)\s(-|\d+)\s*\d+\s*\d*$/.test(pgnText.trim().split('\n')[0]);
      if (isFenOnly) {
        try {
          game.load(pgnText.trim());
          currentIndex = 0;
          mainlineMoves = [];
          mainlineComments = [];
          renderBoard();
          buildMoveList();
          return;
        } catch (e) {
          // continue to parse as PGN if load fails
        }
      }

      let parsed;
      try {
        parsed = pgnParser.parse(pgnText, { startRule: 'games' });
      } catch (e) {
        console.error('pgnParser parse error', e);
        // fallback: try basic cleaner & Chess.js loader
        try {
          const ok = game.load_pgn(pgnText);
          if (!ok) throw new Error('chess.js returned false');
          mainlineMoves = game.history();
          mainlineComments = [];
          currentIndex = mainlineMoves.length;
          renderBoard();
          buildMoveList();
          return;
        } catch (err2) {
          alert('Failed to parse PGN. See console for details.');
          throw e;
        }
      }

      // Extract moves & tags
      const extracted = extractMainline(parsed);
      mainlineMoves = extracted.moves || [];
      mainlineComments = extracted.comments || [];

      // If headers contain FEN & SetUp, apply start position before applying moves
      const headers = (parsed[0] && parsed[0].headers) ? parsed[0].headers : (parsed[0] && parsed[0].tags ? parsed[0].tags : {});
      // pgn-parser places headers in parsed[0].headers as array; handle both formats
      let headerMap = {};
      if (Array.isArray(parsed[0].headers)) {
        parsed[0].headers.forEach(h => { if (h.name) headerMap[h.name] = h.value; });
      } else if (parsed[0].tags) {
        headerMap = parsed[0].tags;
      } else if (parsed[0].headers && typeof parsed[0].headers === 'object') {
        headerMap = parsed[0].headers;
      }

      game.reset();
      if (headerMap['FEN'] && headerMap['SetUp'] === '1') {
        try {
          game.load(headerMap['FEN']);
        } catch (e) {
          // If headerMap['FEN'] isn't directly loadable into chess.js, try game.reset() and continue
          console.warn('Failed to load header FEN', headerMap['FEN'], e);
        }
      }

      // apply mainline moves sequentially
      for (const san of mainlineMoves) {
        try {
          game.move(san, { sloppy: true });
        } catch (e) {
          console.warn('Failed to apply SAN:', san, e);
          break;
        }
      }

      // After applying all moves set currentIndex to full length (end position)
      currentIndex = mainlineMoves.length;
      renderBoard();
      buildMoveList();
    }

    // UI event wiring
    loadPgnBtn.addEventListener('click', () => {
      loadPgnText(pgnTextarea.value);
    });

    clearBtn.addEventListener('click', () => { pgnTextarea.value = ''; });

    resetBtn.addEventListener('click', () => {
      if (confirm('Reset board and clear moves?')) resetBoard();
    });

    loadFenBtn.addEventListener('click', () => {
      const text = pgnTextarea.value.trim();
      if (!text) { alert('Paste a FEN string into the textarea, then click Load FEN.'); return; }
      try {
        // Try to find a FEN line in the input
        const fenCandidate = text.split('\n').find(line => /^[rnbqkpRNBQKP1-8\/]+ .*$/.test(line.trim()));
        const fenToLoad = fenCandidate || text.trim();
        const ok = game.load(fenToLoad);
        if (!ok) { alert('Invalid FEN'); return; }
        currentIndex = 0;
        mainlineMoves = [];
        mainlineComments = [];
        renderBoard();
        buildMoveList();
      } catch (e) {
        console.error('Load FEN error', e);
        alert('Failed to load FEN. See console.');
      }
    });

    prevBtn.addEventListener('click', prevPly);
    nextBtn.addEventListener('click', nextPly);
    undoBtn.addEventListener('click', undoLast);
    flipBtn.addEventListener('click', () => {
      const o = cg.data.orientation === 'white' ? 'black' : 'white';
      cg.set({ orientation: o });
      orientationSelect.value = o;
    });

    orientationSelect.addEventListener('change', () => {
      const o = orientationSelect.value;
      cg.set({ orientation: o });
    });

    // Initialize UI state
    resetBoard();

    // Expose some helpers for debugging (optional)
    window.iq4u = {
      game, cg,
      loadPgnText,
      jumpToPly,
      mainlineMoves
    };
  </script>
</body>
</html>
