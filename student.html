<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>IQ4U — Student Puzzle (centered top board + resizer)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    /* --- base styles (kept largely the same) --- */
    html,body{
      overscroll-behavior-y: contain; /* prevent pull-to-refresh propagation */
    }
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .container{ display:grid; grid-template-columns:420px 1fr; gap:18px; align-items:start; }

    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); }

    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; }

    /* --- TOP BOARD SECTION (spans entire grid and centers content) --- */
    .board-top{ grid-column: 1 / -1; display:flex; flex-direction:column; align-items:center; gap:12px; }

    /* controls centered above the board */
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; }

    /* board wrapper flexible with a max-width; can be adjusted via JS */
    #board-wrapper{ width:100%; max-width:920px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; }
    /* Prevent touch gestures & accidental selection when on board */
    #board-wrapper, #board {
      touch-action: none;                /* disable default touch behaviors on the board */
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      user-select: none;
      -ms-touch-action: none;
    }
    /* board fills wrapper width and keeps square aspect ratio */
    #board{ width:100%; aspect-ratio: 1 / 1; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; max-height:80vh; }

    /* Resizer UI */
    .resizer{ display:flex; gap:10px; align-items:center; background:transparent; }
    .resizer .range{ width:260px; }
    .resizer small{ color:#444; display:block; min-width:48px; text-align:center; font-size:13px; }

    /* keep the original right/left panel sizing below the board unchanged */
    #movesList{ min-height:220px; max-height:300px; overflow:auto; padding:8px; border-radius:6px; background:#fbfdff; border:1px solid #eef2ff; display:none; }

    textarea{ width:100%; min-height:120px; padding:8px; border-radius:6px; border:1px solid #e6eefc; font-family:monospace; }

    @media (max-width:900px){
      .container{ grid-template-columns:1fr; }
      /* for small screens, keep board-top spanning full width and padding handled naturally */
      #board-wrapper{ max-width:100%; }
      #board{ height:80vw; width:100%; aspect-ratio: auto; max-height:420px; }
      .resizer .range{ width:140px; }
    }

    /* bottom multiplayer panel style */
    .multiplayer-panel { margin-top: 18px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .multiplayer-panel input[type="text"] { padding:6px 8px; border-radius:6px; border:1px solid #e6eefc; }
    .multiplayer-panel select { padding:6px 8px; border-radius:6px; border:1px solid #e6eefc; }
    .status-bubble { padding:8px 10px; border-radius:8px; background:#f3f6ff; border:1px solid #e6eeff; color:#0b2; font-weight:600; }

    /* make buttons a little bigger on touch devices */
    @media (pointer: coarse) {
      button { padding:10px 14px; font-size:15px; }
      .resizer .range { touch-action: pan-x; } /* allow horizontal drag on the slider */
    }
  </style>
</head>
<body>

  <!-- TOP BOARD SECTION (spans both columns) -->
  <div class="board-top">
    <div class="controls" aria-hidden="false">
      <button id="undoBtn">Undo</button>
      <button id="prevBtn">Previous</button>
      <button id="nextBtn">Next</button>
      <button id="flipBtn">Flip</button>

      <!-- Resizer UI (added) -->
      <div style="width:18px;"></div><!-- small gap -->
      <div class="resizer" aria-label="Board resizer controls">
        <button id="presetSmall" title="Small">S</button>
        <button id="presetMed" title="Medium">M</button>
        <button id="presetLarge" title="Large">L</button>
        <input id="boardSizeRange" class="range" type="range" min="240" max="1200" step="10" value="920" aria-label="Board size">
        <small id="boardSizeLabel">920px</small>
      </div>
    </div>

    <div class="panel" style="width:100%; max-width:920px;">
      <div id="board-wrapper"><div id="board" aria-label="Chessboard container"></div></div>

      <div style="margin-top:10px; display:flex; justify-content:space-between; align-items:center;">
        <div>Orientation:
          <select id="orientationSelect"><option value="white">White</option><option value="black">Black</option></select>
        </div>
        <div>FEN: <code id="fenDisplay" style="font-family:monospace;"></code></div>
      </div>
      <div class="info" id="msg" aria-live="polite"></div>
    </div>
  </div>

  <!-- BELOW: original two-column layout preserved (panels are same size as before) -->
  <div class="container" style="margin-top:18px;">
    <div style="display:flex; flex-direction:column; gap:12px;">
      <div class="panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>PGN / FEN Input</strong>
          <div style="display:flex; gap:8px;">
            <button id="loadPgnBtn">Load PGN</button>
            <button id="showAnswerBtn">Show answer</button>
          </div>
        </div>
        <div style="margin-top:8px;">
          <textarea id="pgnInput" placeholder="Paste PGN or FEN here. Example PGN: 1. e4 e5 2. Nf3 Nc6"></textarea>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <input type="file" id="pgnFile" accept=".pgn,text/plain">
            <button id="clearPgn">Clear</button>
            <button id="loadFenBtn">Load FEN</button>
            <button id="resetBtn">Reset</button>
          </div>
        </div>
      </div>
    </div>

    <div style="display:flex; flex-direction:column; gap:12px;">
      <div class="panel">
        <strong>Moves (hidden by default)</strong>
        <div id="movesList"></div>
      </div>
    </div>
  </div>

  <!-- New multiplayer panel moved to BOTTOM as requested -->
  <div class="panel multiplayer-panel" style="margin-top:18px; max-width:920px;">
    <div style="display:flex; gap:8px; align-items:center;">
      <label for="emailInputBottom" class="small">Your email:</label>
      <input id="emailInputBottom" type="text" placeholder="example@gmail.com" />
      <button id="joinBtnBottom">Join Online</button>
    </div>

    <div style="display:flex; gap:8px; align-items:center;">
      <label class="small" for="onlinePlayersBottom">Online Players:</label>
      <select id="onlinePlayersBottom"></select>
      <button id="challengeBtnBottom">Challenge Player</button>
    </div>

    <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
      <div id="multiplayStatus" class="muted">Not connected</div>
      <div id="pairedBubble" class="status-bubble" style="display:none;">Paired</div>
    </div>
  </div>

  <!-- jQuery (optional) and chessboard lib -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <!-- Inline PGN parser (unchanged) -->
  <script>
/* @module Chess PGN Parser, @version 1.3.7 (same inline as before) */
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).parser={})}(this,(function(e){"use strict";e.pgn2json=function(e){var n,t,i=e.split("\n"),r={str:{},moves:[],annotations:[],nag:[]},o=[];i.forEach(((e,n,t)=>t[n]=t[n].trim().replace("\r",""))),i=function(e){return e.filter((e=>"%"!==e.trim()[0]))}(i),[r.str,n]=function(e){var n={};for(let i=0;i<e.length;i++){var t=e[i];if("["===t[0]){let e=t.substring(1,t.indexOf(" ")),i=t.substring(t.indexOf(" ")+2,t.length-2);n[e]=i}else if("["!==t[0]&&""!==t.trim())return[n,e.slice(e.indexOf(t)).join(" ").trim().split("")]}}(i),t=n.join("").split(" ");for(let e=1;t.includes(`${e}.`);e++)o.push(t.indexOf(`${e}.`));return r.nag=function(e,n){var t=[];return e.filter((e=>e.includes("$"))).map((i=>{var r=0;t.length&&(r=t[t.length-1]);var o=n.filter((n=>n<e.indexOf(i,r)));return t.push(o[o.length-1]),{moveCount:o.length,value:i}}))}(t,o),r.annotations=function(e,n,t){for(var i=[];-1!==e.indexOf("{");){var r=e.indexOf("{"),o=e.indexOf("}"),f=e.splice(r,o-r+2).join(""),l=n.indexOf(f.split(" ")[0]);i.push({moveCount:t.filter((e=>e<l)).length,comment:f.substring(1,f.length-2)})}return i}(n,t,o),(n=(n=n.join("").split(" ")).filter((e=>!e.includes(".")&&!e.includes("$")))).pop(),r.moves=n,JSON.stringify(r,null,4)},Object.defineProperty(e,"__esModule",{value:!0})}));
  </script>

  <!-- Main script (most logic preserved; socket.io parts replaced by Firebase RTDB below) -->
  <script>
  (function(){
    // keep your CHESS_URL (unchanged)
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    // DOM refs
    const pgnInput = document.getElementById('pgnInput');
    const pgnFile = document.getElementById('pgnFile');
    const loadPgnBtn = document.getElementById('loadPgnBtn');
    const showAnswerBtn = document.getElementById('showAnswerBtn');
    const clearPgnBtn = document.getElementById('clearPgn');
    const loadFenBtn = document.getElementById('loadFenBtn');
    const resetBtn = document.getElementById('resetBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const undoBtn = document.getElementById('undoBtn');
    const flipBtn = document.getElementById('flipBtn');
    const orientationSelect = document.getElementById('orientationSelect');
    const movesList = document.getElementById('movesList');
    const fenDisplay = document.getElementById('fenDisplay');
    const msgEl = document.getElementById('msg');

    // bottom multiplayer DOM
    const emailInputBottom = document.getElementById('emailInputBottom');
    const joinBtnBottom = document.getElementById('joinBtnBottom');
    const onlinePlayersBottom = document.getElementById('onlinePlayersBottom');
    const challengeBtnBottom = document.getElementById('challengeBtnBottom');
    const multiplayStatus = document.getElementById('multiplayStatus');
    const pairedBubble = document.getElementById('pairedBubble');

    // Set initial dropdown state: show "No Player" and disable challenge
    onlinePlayersBottom.innerHTML = '<option value=\"\" disabled selected>No Player</option>';
    challengeBtnBottom.disabled = true;
    challengeBtnBottom.setAttribute('aria-disabled', 'true');

    // Resizer refs
    const boardWrapper = document.getElementById('board-wrapper');
    const boardSizeRange = document.getElementById('boardSizeRange');
    const boardSizeLabel = document.getElementById('boardSizeLabel');
    const presetSmall = document.getElementById('presetSmall');
    const presetMed = document.getElementById('presetMed');
    const presetLarge = document.getElementById('presetLarge');

    // state
    let game = null, board = null, pgnMoves = [], stepIndex = 0, currentTheme = FALLBACK_THEME;

    // multiplayer state (migrated to Firebase)
    let isPaired = false;
    let myColor = null; // "white" or "black"
    let myEmail = '';

    // puzzles state
    let puzzles = [];       // array of PGN strings
    let puzzleIndex = 0;    // index into puzzles[]

    function setMsg(t, ms){ msgEl.textContent = t||''; if(ms>0) setTimeout(()=>{ if(msgEl.textContent===t) msgEl.textContent=''; }, ms); }

    // Robust helpers (same as before)
    function stripCommentsAndVariations(raw){
      if(!raw || typeof raw !== 'string') return '';
      let s = raw.replace(/\{[^}]*\}/g, ' ');
      s = s.replace(/%[^\n]*\n/g, ' ');
      while(/\([^()]*\)/.test(s)) s = s.replace(/\([^()]*\)/g, ' ');
      return s;
    }

    function extractLastFEN(raw){
      if(!raw || typeof raw !== 'string') return null;
      const re = /\[FEN\s+"([^"]+)"\]/g;
      let m, last=null;
      while((m=re.exec(raw))!==null) last = m[1];
      return last;
    }

    function extractSANMoves(pgnClean){
      if(!pgnClean || typeof pgnClean !== 'string') return [];
      let body = pgnClean.replace(/\[[^\]]*\]/g, ' ');
      body = body.replace(/\s+/g,' ').trim();
      if(!body) return [];
      const tokens = body.split(' ').filter(t => t && !/^\d+\.{1,3}$/.test(t) && t!=='1-0' && t!=='0-1' && t!=='1/2-1/2' && t!=='*');
      return tokens;
    }

    function refreshMovesUI(){
      if(!pgnMoves || pgnMoves.length===0){ movesList.innerHTML = '<div class="small">No moves loaded.</div>'; return; }
      let html='';
      for(let i=0;i<pgnMoves.length;i+=2){
        const no = Math.floor(i/2)+1;
        html += `<div style="padding:6px;border-radius:6px;"><strong>${no}.</strong> ${pgnMoves[i]||''} ${pgnMoves[i+1]||''}</div>`;
      }
      movesList.innerHTML = html;
    }

    // chessboard callbacks
    function onDrop(source, target){
      if(!game) return 'snapback';
      const move = game.move({ from: source, to: target, promotion:'q' });
      if(move === null){ setMsg('Illegal move', 1200); return 'snapback'; }
      const expected = pgnMoves[stepIndex];
      if(expected){
        if(move.san !== expected){
          game.undo();
          setTimeout(()=> board.position(game.fen()), 60);
          setMsg('Wrong move — not the expected solution', 1400);
          return 'snapback';
        } else {
          stepIndex++; board.position(game.fen()); fenDisplay.textContent = game.fen(); refreshMovesUI();
          scheduleAutoplayIfOpponentToMove();
          // emit via firebase when paired
          try{ if(isPaired && window.firebaseMultiplayer) window.firebaseMultiplayer.emitMove(game.fen()); }catch(e){}
        }
      } else {
        board.position(game.fen()); fenDisplay.textContent = game.fen();
        if(isPaired && window.firebaseMultiplayer){
          try{ window.firebaseMultiplayer.emitMove(game.fen()); }catch(e){}
        }
      }
    }
    function onSnapEnd(){ if(board) board.position(game.fen()); }

    function createBoard(theme){
      const orientation = orientationSelect.value || 'white';
      if(board && typeof board.destroy === 'function'){ try{ board.destroy(); }catch(e){} }
      board = Chessboard('board', {
        draggable: true,
        position: game ? game.fen() : 'start',
        orientation: orientation,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: theme
      });
    }

    // new: setBoardSize(px) - adjusts board-wrapper max-width and triggers resize
    function setBoardSize(px){
      if(!px || isNaN(px)) return;
      const clamped = Math.max(240, Math.min(1200, Number(px)));
      boardWrapper.style.maxWidth = clamped + 'px';
      boardSizeRange.value = clamped;
      boardSizeLabel.textContent = clamped + 'px';
      try{
        if(board && typeof board.resize === 'function'){
          board.resize();
        } else {
          createBoard(currentTheme);
        }
      }catch(e){
        createBoard(currentTheme);
      }
    }

    // PGN extraction — use parser if available but fallback safely
    function extractMovesFromPGN(pgn){
      if(typeof parser !== 'undefined' && typeof parser.pgn2json === 'function'){
        try{
          const jsonStr = parser.pgn2json(pgn);
          if(typeof jsonStr === 'string' && jsonStr.length>10){
            const parsed = JSON.parse(jsonStr);
            if(parsed && Array.isArray(parsed.moves) && parsed.moves.length>0){
              return { moves: parsed.moves.filter(m=>typeof m==='string'&&m.trim()), headers: parsed.str||{} };
            }
          }
        }catch(e){
          console.warn('parser.pgn2json failed, falling back', e);
        }
      }
      const cleaned = stripCommentsAndVariations(pgn);
      const tokens = extractSANMoves(cleaned);
      return { moves: tokens, headers: {} };
    }

    function preparePuzzleFromPGN(pgn){
      try{ stopAutoplay(); }catch(e){}
      if(!pgn || typeof pgn !== 'string'){ setMsg('No PGN provided', 1200); return; }
      const res = extractMovesFromPGN(pgn);
      pgnMoves = res.moves || []; stepIndex = 0;
      const fen = (res.headers && res.headers.FEN) ? res.headers.FEN : extractLastFEN(pgn);
      try{
        if(typeof Chess === 'undefined'){ setMsg('Chess.js not loaded (check console)',0); movesList.style.display='block'; movesList.textContent = pgn; return; }
        game = fen ? new Chess(fen) : new Chess();
      }catch(e){
        console.error('Failed to init Chess:', e); setMsg('Chess engine error',0); return;
      }
      fenDisplay.textContent = game.fen(); refreshMovesUI();
      chooseTheme().then(theme => { currentTheme = theme; createBoard(currentTheme); scheduleAutoplayIfOpponentToMove(); });
    }

    // autoplay opponent moves while it's opponent turn (student is White)
    let autoplayTimer = null;
    function scheduleAutoplayIfOpponentToMove(){
      try{ if(autoplayTimer) { clearTimeout(autoplayTimer); autoplayTimer = null; } }catch(e){}
      const studentColor = 'w';
      const speed = 900;
      function step(){
        if(!game || stepIndex >= pgnMoves.length){ clearTimeout(autoplayTimer); autoplayTimer=null; return; }
        if(game.turn() === studentColor){ clearTimeout(autoplayTimer); autoplayTimer=null; return; }
        const san = pgnMoves[stepIndex];
        const r = game.move(san, { sloppy:true });
        if(!r){ console.warn('Invalid PGN move at', stepIndex, san); movesList.style.display='block'; setMsg('PGN invalid — see notation',0); clearTimeout(autoplayTimer); autoplayTimer=null; return; }
        stepIndex++;
        if(board) board.position(game.fen()); fenDisplay.textContent = game.fen();
        if(stepIndex < pgnMoves.length && game.turn() !== studentColor) autoplayTimer = setTimeout(step, speed);
      }
      if(game && game.turn() !== studentColor) autoplayTimer = setTimeout(step, speed); else setAllowedMoveForStudent();
    }
    function stopAutoplay(){ if(autoplayTimer) clearTimeout(autoplayTimer); autoplayTimer = null; }

    function setAllowedMoveForStudent(){}

    // piece-theme detection
    async function pieceExists(url){
      try{
        const res = await fetch(url, { method:'HEAD', cache:'no-store', mode:'cors' });
        return res.ok;
      }catch(e){
        return false;
      }
    }
    async function chooseTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const ok = await pieceExists(test); return ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // file upload handling
    pgnFile.addEventListener('change', function(ev){
      const file = ev.target.files[0]; if(!file) return;
      const reader = new FileReader();
      reader.onload = function(e){
        const text = e.target.result;
        const parts = splitPGNs(text);
        if(parts && parts.length>0){
          puzzles = parts.slice();
          puzzleIndex = 0;
          pgnInput.value = puzzles[0];
          setMsg(`Loaded ${puzzles.length} puzzle(s) from file. Showing 1/${puzzles.length}`, 2200);
        } else {
          puzzles = [text];
          puzzleIndex = 0;
          pgnInput.value = text;
        }
      };
      reader.readAsText(file,'utf-8');
    });

    function splitPGNs(raw){
      if(!raw || typeof raw !== 'string') return [];
      const byEvent = raw.split(/\n(?=\[Event\s)/g).map(s=>s.trim()).filter(Boolean);
      if(byEvent.length>1) return byEvent;
      return raw.split(/\n\s*\n/).map(s=>s.trim()).filter(Boolean);
    }

    // UI wiring
    loadPgnBtn.addEventListener('click', function(){
      const txt = pgnInput.value.trim();
      if(!txt){ setMsg('Paste or upload a PGN first', 1500); return; }
      const parts = splitPGNs(txt);
      if(parts && parts.length>1){
        puzzles = parts.slice();
        puzzleIndex = 0;
        setMsg(`Detected ${puzzles.length} puzzles. Loading 1/${puzzles.length}`, 1800);
        preparePuzzleFromPGN(puzzles[puzzleIndex]);
      } else {
        puzzles = [txt];
        puzzleIndex = 0;
        preparePuzzleFromPGN(txt);
      }
    });

    showAnswerBtn.onclick = function(){
      if(movesList.style.display === 'none' || movesList.style.display === ''){ movesList.style.display='block'; this.textContent='Hide answer'; } else { movesList.style.display='none'; this.textContent='Show answer'; }
    };
    clearPgnBtn.onclick = ()=>{ pgnInput.value=''; puzzles = []; puzzleIndex = 0; };
    loadFenBtn.onclick = ()=> {
      const txt = pgnInput.value.trim(); if(!txt){ alert('Paste FEN first'); return; }
      try{ if(!game) game = new Chess(); const ok = game.load(txt); if(!ok){ alert('Invalid FEN'); return; } stepIndex=0; pgnMoves=[]; if(board) board.position(game.fen()); fenDisplay.textContent=game.fen(); }catch(e){ alert('Invalid FEN'); }
    };
    resetBtn.onclick = ()=> { if(!game) game = new Chess(); else game.reset(); stepIndex=0; pgnMoves=[]; if(board) board.position(game.fen()); fenDisplay.textContent = game.fen(); refreshMovesUI(); setMsg('Reset',900); };

    nextBtn.onclick = ()=> {
      if(puzzles && puzzles.length > 1){
        if(puzzleIndex < puzzles.length - 1){
          puzzleIndex++;
          pgnInput.value = puzzles[puzzleIndex];
          preparePuzzleFromPGN(puzzles[puzzleIndex]);
          setMsg(`Loaded puzzle ${puzzleIndex+1}/${puzzles.length}`, 1500);
        } else {
          setMsg('Already at last puzzle', 1200);
        }
        return;
      }
      if(!game || stepIndex>=pgnMoves.length) return;
      const san = pgnMoves[stepIndex];
      const r = game.move(san, { sloppy:true });
      if(!r){ alert('Invalid PGN move'); return; }
      stepIndex++;
      if(board) board.position(game.fen());
      fenDisplay.textContent = game.fen();
    };

    prevBtn.onclick = ()=> {
      if(puzzles && puzzles.length > 1){
        if(puzzleIndex > 0){
          puzzleIndex--;
          pgnInput.value = puzzles[puzzleIndex];
          preparePuzzleFromPGN(puzzles[puzzleIndex]);
          setMsg(`Loaded puzzle ${puzzleIndex+1}/${puzzles.length}`, 1500);
        } else {
          setMsg('Already at first puzzle', 1200);
        }
        return;
      }
      if(!game || stepIndex<=0) return;
      game.undo();
      stepIndex = Math.max(0, stepIndex-1);
      if(board) board.position(game.fen());
      fenDisplay.textContent = game.fen();
    };

    undoBtn.onclick = ()=> { if(!game) return; game.undo(); if(board) board.position(game.fen()); fenDisplay.textContent = game.fen(); };
    flipBtn.onclick = ()=> { if(board) board.flip(); };
    orientationSelect.onchange = ()=> { if(board) createBoard(currentTheme); };

    // Resizer event wiring
    boardSizeRange.addEventListener('input', (e)=> {
      setBoardSize(e.target.value);
    });
    presetSmall.addEventListener('click', ()=> setBoardSize(360));
    presetMed.addEventListener('click', ()=> setBoardSize(720));
    presetLarge.addEventListener('click', ()=> setBoardSize(920));

    // Boot sequence: loads Chess.js and initial board
    async function boot(){
      if(typeof Chess === 'undefined'){
        try{
          const mod = await import(CHESS_URL + '?t=' + Date.now());
          const candidate = mod.default || mod.Chess || mod;
          if(candidate) window.Chess = candidate;
        }catch(e){}
        if(typeof Chess === 'undefined'){
          var s = document.createElement('script'); s.src = CHESS_URL + '?t=' + Date.now(); s.async=false;
          s.onload = ()=> { console.info('Chess.js loaded via script tag'); };
          s.onerror = ()=> { console.warn('Chess.js failed to load from CHESS_URL'); setMsg('Chess.js failed to load — check console', 0); };
          document.head.appendChild(s);
        }
      }

      try{
        currentTheme = await chooseTheme();
      }catch(e){ currentTheme = FALLBACK_THEME; }
      game = new Chess();
      createBoard(currentTheme);
      fenDisplay.textContent = game.fen();
      refreshMovesUI();
      setMsg('', 0);
      const initial = parseInt(getComputedStyle(boardWrapper).maxWidth,10) || boardWrapper.clientWidth || 920;
      setBoardSize(initial);
      // Firebase multiplayer initialized below; does not auto-register until Join pressed
    }

    boot();

    let resizeTimer = null;
    window.addEventListener('resize', ()=> {
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=> {
        try{
          if(board && typeof board.resize === 'function'){
            board.resize();
          } else {
            createBoard(currentTheme);
          }
        }catch(e){
          createBoard(currentTheme);
        }
      }, 150);
    });

    // Expose a simple helper for external code to update board and notify partner
    window.onBoardMove = function(newFen){
      try{
        if(!newFen) return;
        if(!game) game = new Chess();
        if(typeof game.load === 'function') game.load(newFen);
        if(board) board.position(newFen);
        fenDisplay.textContent = newFen;
        if(isPaired && window.firebaseMultiplayer){
          window.firebaseMultiplayer.emitMove(newFen);
        }
      }catch(e){}
    };

    // When loading a FEN or resetting, notify partner if paired
    loadFenBtn.addEventListener('click', function(){
      setTimeout(()=> {
        try{ if(isPaired && window.firebaseMultiplayer){ window.firebaseMultiplayer.emitMove(game.fen()); } }catch(e){}
      }, 120);
    });
    resetBtn.addEventListener('click', function(){
      setTimeout(()=> {
        try{ if(isPaired && window.firebaseMultiplayer){ window.firebaseMultiplayer.emitMove(game.fen()); } }catch(e){}
      }, 120);
    });

    // --- NEW: touch handling to prevent mobile browser refresh while dragging pieces ---
    (function installTouchGuards(){
      let touchStartedOnBoard = false;

      // mark when a touch starts inside #board
      boardWrapper.addEventListener('touchstart', function tstart(e){
        // if more than 1 finger, ignore (let browser handle)
        if(e.touches && e.touches.length > 1) return;
        touchStartedOnBoard = true;
        // We don't call preventDefault here: we want to allow slidable interactions like slider.
        // The touchmove handler below will prevent scroll if touch started inside board.
      }, { passive: true });

      // prevent default scrolling while moving finger on board (must be passive:false)
      boardWrapper.addEventListener('touchmove', function tmove(e){
        if(touchStartedOnBoard){
          // prevent page scroll / pull-to-refresh while dragging on board
          e.preventDefault();
          // Note: this will not stop the chessboard library handling piece dragging
        }
      }, { passive: false });

      // clear flag on touchend/cancel
      boardWrapper.addEventListener('touchend', function tend(e){
        touchStartedOnBoard = false;
      }, { passive: true });
      boardWrapper.addEventListener('touchcancel', function tc(e){
        touchStartedOnBoard = false;
      }, { passive: true });

      // also guard pointer events (for browsers using pointer events)
      boardWrapper.addEventListener('pointerdown', function pd(e){
        // only intercept touch pointers (not mouse)
        if(e.pointerType === 'touch'){
          // prevent gestures that might start on long-press
          // do not preventDefault here to not block click entirely; chessboard will handle pointer events
          // but ensure the page doesn't overscroll while pointer is on board by adding class
          boardWrapper.classList.add('pointer-touch-active');
        }
      }, { passive: true });

      boardWrapper.addEventListener('pointerup', function pu(e){
        if(e.pointerType === 'touch'){
          boardWrapper.classList.remove('pointer-touch-active');
        }
      }, { passive: true });
    })();

    // cleanup before unload (best-effort)
    window.addEventListener('pagehide', ()=> { try{ /* nothing to do now */ }catch(e){} });

    // When loading a FEN or resetting, notify partner if paired (already wired above)
  })();
  </script>

  <!-- ===========================
       FIREBASE REALTIME DATABASE
       INSERTED CONFIG (from user)
       =========================== -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
  (function(){
    // ======= YOUR FIREBASE CONFIG (cleaned) =======
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb693d0736fe0da4bb"
    };
    // ==============================================

    if(FIREBASE_CONFIG){
      firebase.initializeApp(FIREBASE_CONFIG);
      const db = firebase.database();

      // DOM refs (already defined above)
      const joinBtnBottom = document.getElementById('joinBtnBottom');
      const emailInputBottom = document.getElementById('emailInputBottom');
      const onlinePlayersBottom = document.getElementById('onlinePlayersBottom');
      const challengeBtnBottom = document.getElementById('challengeBtnBottom');
      const multiplayStatus = document.getElementById('multiplayStatus');
      const pairedBubble = document.getElementById('pairedBubble');

      let myId = (sessionStorage.getItem('iq4u_clientId')) ? sessionStorage.getItem('iq4u_clientId') : ('c_' + Math.random().toString(36).slice(2,10));
      sessionStorage.setItem('iq4u_clientId', myId);
      let myEmail = '';
      let currentGameId = null;
      let isPairedLocal = false;
      let presenceTimer = null;

      const onlineRef = db.ref('online');
      const challengesRef = db.ref('challenges');
      const gamesRef = db.ref('games');
      let movesRef = null;

      function goOnline(email){
        myEmail = email || ('anon-'+myId);
        const node = onlineRef.child(myId);
        node.set({ email: myEmail, ts: firebase.database.ServerValue.TIMESTAMP })
          .then(()=> {
            multiplayStatus.textContent = 'Connected as ' + myEmail;
          })
          .catch(err => multiplayStatus.textContent = 'Presence write error');
        node.onDisconnect().remove();
        if(presenceTimer) clearInterval(presenceTimer);
        presenceTimer = setInterval(()=> node.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
      }

      function goOffline(){
        if(presenceTimer) clearInterval(presenceTimer);
        onlineRef.child(myId).remove().catch(()=>{});
        multiplayStatus.textContent = 'Not connected';
      }

      onlineRef.on('value', snap => {
        const v = snap.val() || {};
        onlinePlayersBottom.innerHTML = '';
        let count = 0;
        for(const id in v){
          if(!v.hasOwnProperty(id)) continue;
          if(id === myId) continue;
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = v[id].email || id;
          onlinePlayersBottom.appendChild(opt);
          count++;
        }
        if(count === 0){
          const opt = document.createElement('option');
          opt.value = '';
          opt.disabled = true;
          opt.selected = true;
          opt.textContent = 'No Player';
          onlinePlayersBottom.appendChild(opt);
          challengeBtnBottom.disabled = true;
        } else {
          challengeBtnBottom.disabled = false;
        }
      });

      function sendChallengeTo(targetId){
        if(!targetId) return;
        const ch = challengesRef.child(targetId).push();
        ch.set({
          fromId: myId,
          fromEmail: myEmail,
          ts: firebase.database.ServerValue.TIMESTAMP
        }).then(()=> {
          multiplayStatus.textContent = 'Challenge sent';
          setTimeout(()=> ch.remove().catch(()=>{}), 60_000);
        }).catch(err => multiplayStatus.textContent = 'Challenge send failed');
      }

      challengesRef.child(myId).on('child_added', snap => {
        const data = snap.val();
        const key = snap.key;
        if(!data) return;
        const fromEmail = data.fromEmail || data.fromId;
        const accept = confirm(`${fromEmail} challenges you. Accept?`);
        if(accept){
          const gameNode = gamesRef.push();
          const gameId = gameNode.key;
          const gameData = { white: data.fromId, black: myId, createdAt: firebase.database.ServerValue.TIMESTAMP };
          gameNode.set(gameData).then(()=>{
            movesRef = db.ref('moves/' + gameId);
            currentGameId = gameId;
            isPairedLocal = true;
            pairedBubble.style.display = 'inline-block';
            multiplayStatus.textContent = 'Paired: You are Black';
            db.ref('notifications/' + data.fromId + '/' + gameId).set({ type:'startGame', gameId, white: data.fromId, black: myId });
            challengesRef.child(myId).child(key).remove().catch(()=>{});
            // start watching moves for this game
            watchMoves(gameId);
            window.isPaired = true;
          });
        } else {
          if(data.fromId){
            db.ref('challengeDeclined/' + data.fromId + '/' + myId).set({ email: myEmail, ts: firebase.database.ServerValue.TIMESTAMP });
          }
          challengesRef.child(myId).child(key).remove().catch(()=>{});
        }
      });

      db.ref('notifications/' + myId).on('child_added', snap => {
        const n = snap.val(); if(!n) return;
        if(n.type === 'startGame' && n.gameId){
          currentGameId = n.gameId;
          watchMoves(currentGameId);
          isPairedLocal = true;
          if(n.white === myId) multiplayStatus.textContent = 'Paired: You are White';
          else multiplayStatus.textContent = 'Paired: You are Black';
          pairedBubble.style.display = 'inline-block';
        }
        snap.ref.remove().catch(()=>{});
      });

      db.ref('challengeDeclined/' + myId).on('child_added', snap => {
        const d = snap.val(); if(!d) return;
        multiplayStatus.textContent = (d.email || 'Player') + ' declined your challenge';
        snap.ref.remove().catch(()=>{});
      });

      function watchMoves(gameId){
        if(!gameId) return;
        movesRef = db.ref('moves/' + gameId);
        movesRef.on('child_added', snap => {
          const m = snap.val();
          if(m && m.fen){
            if(typeof window.onBoardMove === 'function') window.onBoardMove(m.fen);
          } else {
            // fallback
          }
        });
      }

      function emitMoveForGame(gameId, fen){
        if(!gameId || !fen) return;
        const node = db.ref('moves/' + gameId).push();
        node.set({ fen: fen, by: myId, ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
      }

      joinBtnBottom.addEventListener('click', function(){
        const email = (emailInputBottom.value || '').trim();
        if(!email) return alert('Enter email to join online');
        goOnline(email);
      });

      challengeBtnBottom.addEventListener('click', function(){
        const target = onlinePlayersBottom.value;
        if(!target) return alert('Select a player');
        sendChallengeTo(target);
      });

      // expose API used by board code
      window.firebaseMultiplayer = {
        emitMove: function(fen){
          if(!currentGameId) return console.warn('Not in game');
          emitMoveForGame(currentGameId, fen);
        },
        startWatchingGame: function(gameId){
          currentGameId = gameId;
          watchMoves(gameId);
        },
        getMyId: () => myId,
        getMyEmail: () => myEmail,
        goOffline: goOffline
      };

      // cleanup
      window.addEventListener('beforeunload', ()=> { try{ goOffline(); }catch(e){} });

    } else {
      // FIREBASE_CONFIG missing: wire Join button to show friendly message
      joinBtnBottom.addEventListener('click', function(){ alert('Firebase not configured. Paste your Firebase config into this HTML file.'); });
      challengeBtnBottom.addEventListener('click', function(){ alert('Firebase not configured.'); });
    }

  })();
  </script>

  <!-- Optional lightweight debug overlay injection (no UI changes) -->
  <script>
  (function(){
    if(window.__IQ4U_injection_done) return;
    window.__IQ4U_injection_done = true;
    // Minimal console hint to open debug overlay if needed (Shift+D)
    console.info('If you want a debug overlay, ask me to inject it — it will not change UI.');
  })();
  </script>

</body>
</html>
