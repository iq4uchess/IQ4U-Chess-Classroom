<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U — Student Puzzle (PGN Autoplay + Firebase)</title>

  <!-- Chessground (board), Chess.js (logic) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@8.0.0/assets/chessground.base.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chessground@8.0.0/assets/chessground.css" />
  <script src="https://cdn.jsdelivr.net/npm/chessground@8.0.0/dist/chessground.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>

  <!-- Firebase compat libraries for RTDB -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:12px;background:#f7f8fb}
    .wrap{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:420px 1fr;gap:18px}
    .panel{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(20,20,40,0.06)}
    #board{width:100%;max-width:760px;height:760px;margin:0 auto}
    textarea{width:100%;height:180px;font-family:monospace;font-size:13px}
    .muted{color:#666;font-size:13px}
    #notation{white-space:pre-wrap;font-family:monospace;font-size:13px;max-height:300px;overflow:auto;border:1px solid #eee;padding:8px}
    .controls{display:flex;gap:8px;align-items:center;justify-content:flex-end}
    .small{font-size:13px;color:#444}
    #msg{color:#a33;font-weight:600;margin-top:6px}
    .row{display:flex;gap:8px;align-items:center}
    .switch{display:inline-flex;align-items:center;gap:6px}
    select{padding:6px}
  </style>
</head>
<body>
  <h2 style="text-align:center">IQ4U — Student Puzzle (PGN Autoplay + Firebase)</h2>

  <div class="wrap">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="muted">Puzzle source (paste / upload / remote)</div>
        <div style="display:flex;gap:8px">
          <button id="loadBtn">Load & Play</button>
          <button id="showBtn">Show answer</button>
        </div>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px">
        <input type="file" id="pgnFile" accept=".pgn,text/plain" />
        <button id="clearBtn">Clear</button>
      </div>

      <div style="margin-top:8px">
        <label class="small">Select puzzle from uploaded file:</label>
        <select id="pgnSelect"><option value="">-- no file loaded --</option></select>
      </div>

      <div style="margin-top:8px">
        <label class="small">Paste PGN (single puzzle) — textarea will be used if no selection:</label>
        <textarea id="pgnText">[Event "Trapped pieces: Chapter 1"]
[FEN "r1bq1rk1/ppp2pb1/3p3p/4n1pQ/2B1P3/2PP2B1/PP3PPP/RN2R1K1 b - - 0 1"]
[SetUp "1"]

1... Bg4 2. Qxg4 Nxg4 *</textarea>
      </div>

      <p class="muted">Notes: comments { } and variations ( ) are stripped before play so mainline is used. Notation hidden by default.</p>

      <div style="margin-top:8px;display:flex;gap:12px;align-items:center">
        <div class="switch"><input type="checkbox" id="playAsBlack" /> <label for="playAsBlack">Student plays as Black</label></div>
        <div class="switch"><input type="checkbox" id="restrictMove" checked /> <label for="restrictMove">Restrict to correct move</label></div>
      </div>

      <div style="margin-top:8px">
        <label class="small">Autoplay speed (ms per half-move): <input id="speed" type="number" value="900" style="width:100px" /></label>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
        <button id="prevBtn">Prev</button>
        <button id="nextBtn">Next</button>
      </div>

      <div style="margin-top:10px">
        <div id="msg"></div>
      </div>

      <div style="margin-top:10px">
        <div id="notation" hidden></div>
      </div>
    </div>

    <div class="panel" style="display:flex;flex-direction:column;align-items:center">
      <div id="board"></div>
      <div style="width:100%;display:flex;justify-content:space-between;align-items:center;margin-top:6px">
        <div class="muted">FEN: <span id="fenText">start</span></div>
        <div class="muted">Turn: <span id="turnText">-</span></div>
      </div>
    </div>
  </div>

  <script>
  /************************************************************************
   * PGN autoplay + Chessground integration for student.html
   * + Firebase RTDB listener (dedupe & validation)
   ************************************************************************/

  // ----- Utilities -----
  function stripCommentsAndVariations(pgnRaw){
    let s = pgnRaw.replace(/\{[^}]*\}/g, ' ');
    s = s.replace(/%[^\n]*\n/g, ' ');
    while (/\([^()]*\)/.test(s)) s = s.replace(/\([^()]*\)/g, ' ');
    return s;
  }

  function extractLastFEN(pgnRaw){
    const re = /\[FEN\s+"([^"]+)"\]/g;
    let match, last = null;
    while ((match = re.exec(pgnRaw)) !== null) last = match[1];
    return last;
  }

  function extractSANMoves(pgnClean){
    let body = pgnClean.replace(/\[[^\]]*\]/g, ' ');
    body = body.replace(/\s+/g, ' ').trim();
    const tokens = body.split(/\s+/).filter(t =>
      t && !/^\d+\.{1,3}$/.test(t) &&
      t !== '1-0' && t !== '0-1' && t !== '1/2-1/2' && t !== '*'
    );
    return tokens;
  }

  function splitPGNs(raw){
    const regex = /(\[Event[\s\S]*?)(?=(\n\[Event|\n\s*$))/g;
    const found = [];
    let m;
    while ((m = regex.exec(raw)) !== null) found.push(m[1].trim());
    if (found.length === 0) return raw.split(/\n\s*\n/).map(s=>s.trim()).filter(Boolean);
    return found;
  }

  function parseTitleFromPGN(pgn){
    const cn = pgn.match(/\[ChapterName\s+"([^\"]+)"\]/);
    if (cn) return cn[1];
    const ev = pgn.match(/\[Event\s+"([^\"]+)"\]/);
    if (ev) return ev[1];
    const fn = pgn.match(/\[FEN\s+"([^\"]+)"\]/);
    if (fn) return 'FEN: ' + fn[1].slice(0,20);
    return 'Untitled puzzle';
  }

  // ----- DOM ----
  const pgnText = document.getElementById('pgnText');
  const pgnFile = document.getElementById('pgnFile');
  const loadBtn = document.getElementById('loadBtn');
  const showBtn = document.getElementById('showBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const speedInput = document.getElementById('speed');
  const notationDiv = document.getElementById('notation');
  const fenText = document.getElementById('fenText');
  const turnText = document.getElementById('turnText');
  const msgDiv = document.getElementById('msg');
  const pgnSelect = document.getElementById('pgnSelect');
  const clearBtn = document.getElementById('clearBtn');
  const playAsBlackChk = document.getElementById('playAsBlack');
  const restrictChk = document.getElementById('restrictMove');

  // ----- Game & board state ----
  let game = new Chess();
  let cg = null;
  let moves = [];               // SAN moves (sequence)
  let currentMoveIndex = 0;     // count of HALF-moves applied
  let autoplayTimer = null;
  let loadedPGNs = [];          // from file: [{title,pgn}]

  // ----- Firebase RTDB setup (using your config) -----
  const firebaseConfig = {
    apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
    authDomain: "iq4u-chess-classroom.firebaseapp.com",
    databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "iq4u-chess-classroom",
    storageBucket: "iq4u-chess-classroom.firebasestorage.app",
    messagingSenderId: "833620718306",
    appId: "1:833620718306:web:b599bb693d0736fe0da4bb"
  };

  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // Path teacher will write to. Adjust as needed.
  const remotePath = '/classrooms/room1/currentPuzzle';
  let lastRemoteTs = 0; // dedupe

  function isLikelyPGN(s){
    if (!s || typeof s !== 'string') return false;
    return /\b1\./.test(s) || /\[FEN\s+"/.test(s) || s.trim().split(/\s+/).length > 4;
  }

  // Listener: expects either plain string or object { pgn: string, ts: number }
  db.ref(remotePath).on('value', (snap) => {
    const val = snap.val();
    if (!val) return;
    let pgn = null;
    let ts = Date.now();
    if (typeof val === 'string') pgn = val;
    else if (val.pgn && typeof val.pgn === 'string'){ pgn = val.pgn; ts = val.ts || Date.now(); }
    else { console.warn('Remote payload not recognized', val); return; }

    if (ts <= lastRemoteTs) return; // already processed
    if (!isLikelyPGN(pgn)) { console.warn('Remote value not PGN-like', pgn); return; }

    lastRemoteTs = ts;
    try { prepareFromPGNString(pgn); }
    catch (err){ console.error('Failed to load remote PGN', err); }
  });

  // Optional helper: teacher push example (use in master UI only)
  function teacherPushPuzzle(roomPath, pgnString){
    const payload = { pgn: pgnString, ts: Date.now() };
    return firebase.database().ref(roomPath).set(payload);
  }

  // student color helper
  function getStudentColorFromUIOrFEN(fen){ return playAsBlackChk.checked ? 'b' : 'w'; }

  function initChessground(fen, orientation){
    if (cg) cg.destroy();
    cg = Chessground(document.getElementById('board'), {
      fen: fen || 'start',
      orientation: orientation || 'white',
      turnColor: (fen && fen.split(' ')[1] === 'b') ? 'black' : 'white',
      movable: { color: 'white', dests: {}, showDests: true, events: { after: onUserMove } },
      draggable: { enabled: true },
      coordinates: true
    });
  }

  function updateTurnText(){ turnText.textContent = game.turn() === 'w' ? 'White' : 'Black'; }

  function expectedMoveObjAtIndex(idx){
    const legal = game.moves({ verbose: true });
    const expectedSAN = moves[idx];
    if (!expectedSAN) return null;
    for (let mv of legal) if (mv.san === expectedSAN) return mv;
    return null;
  }

  function setAllowedMoveForStudent(){
    const restrict = restrictChk.checked;
    const studentColor = getStudentColorFromUIOrFEN(game.fen());
    cg.options.movable.color = studentColor === 'w' ? 'white' : 'black';
    if (!restrict){
      const dests = {};
      const legal = game.moves({ verbose: true });
      for (let mv of legal){
        if ((studentColor === 'w' && mv.color === 'w') || (studentColor === 'b' && mv.color === 'b')){
          if (!dests[mv.from]) dests[mv.from] = [];
          if (!dests[mv.from].includes(mv.to)) dests[mv.from].push(mv.to);
        }
      }
      cg.set({ movable: { color: cg.options.movable.color, dests: dests } });
      return;
    }

    if ((game.turn() === 'w' && studentColor === 'w') || (game.turn() === 'b' && studentColor === 'b')){
      const exp = expectedMoveObjAtIndex(currentMoveIndex);
      if (!exp){ notationDiv.hidden = false; msgDiv.textContent = 'Cannot find expected move — showing notation'; setTimeout(()=> msgDiv.textContent = '', 2500); setAllowedMoveForStudent(); return; }
      const dests = {}; dests[exp.from] = [exp.to];
      cg.set({ movable: { color: cg.options.movable.color, dests: dests } });
    } else {
      cg.set({ movable: { color: cg.options.movable.color, dests: {} } });
    }
  }

  function onUserMove(orig, dest){
    const attempted = game.move({ from: orig, to: dest, promotion: 'q' });
    if (!attempted){ msgDiv.textContent = 'Illegal move — try again'; setTimeout(()=> msgDiv.textContent = '', 1500); cg.set({ fen: game.fen() }); return; }
    if (restrictChk.checked){ const expected = moves[currentMoveIndex]; if (attempted.san !== expected){ game.undo(); cg.set({ fen: game.fen() }); msgDiv.textContent = 'Wrong move — not the puzzle solution'; setTimeout(()=> msgDiv.textContent = '', 1600); setAllowedMoveForStudent(); return; } }
    currentMoveIndex++; cg.set({ fen: game.fen() }); updateTurnText(); setTimeout(() => { setAllowedMoveForStudent(); if ((game.turn() !== getStudentColorFromUIOrFEN(game.fen())) && currentMoveIndex < moves.length) autoplayStep(); }, 250);
  }

  function autoplayStep(){
    if (currentMoveIndex >= moves.length) { stopAutoplay(); return; }
    const san = moves[currentMoveIndex];
    const result = game.move(san, { sloppy: true });
    if (!result){ console.warn('Invalid PGN move at', currentMoveIndex, san); notationDiv.hidden = false; msgDiv.textContent = 'PGN contains an invalid move. See notation.'; return; }
    currentMoveIndex++; cg.set({ fen: game.fen() }); updateTurnText(); const studentColor = getStudentColorFromUIOrFEN(game.fen()); if ((game.turn() !== studentColor) && currentMoveIndex < moves.length){ setTimeout(autoplayStep, Math.max(60, parseInt(speedInput.value || '900',10))); } else { setAllowedMoveForStudent(); }
  }

  function startAutoplay(){ stopAutoplay(); const studentColor = getStudentColorFromUIOrFEN(game.fen()); if (game.turn() !== studentColor) autoplayStep(); else setAllowedMoveForStudent(); }
  function stopAutoplay(){ if (autoplayTimer){ clearInterval(autoplayTimer); autoplayTimer = null; } }

  function prepareFromPGNString(pgn){ stopAutoplay(); const lastFen = extractLastFEN(pgn); const cleaned = stripCommentsAndVariations(pgn); const sanMoves = extractSANMoves(cleaned); moves = sanMoves || []; currentMoveIndex = 0; if (lastFen){ game = new Chess(lastFen); fenText.textContent = lastFen; } else { game = new Chess(); fenText.textContent = game.fen(); } notationDiv.textContent = moves.join(' '); notationDiv.hidden = true; const orientation = playAsBlackChk.checked ? 'black' : 'white'; initChessground(game.fen(), orientation); updateTurnText(); setAllowedMoveForStudent(); startAutoplay(); }

  pgnFile.addEventListener('change', (ev) => { const file = ev.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function(e){ const text = e.target.result; const parts = splitPGNs(text); loadedPGNs = parts.map(p => ({ title: parseTitleFromPGN(p), pgn: p })); populateSelectFromLoaded(); if (loadedPGNs.length > 0){ pgnSelect.selectedIndex = 1; onSelectChange(); } }; reader.readAsText(file, 'utf-8'); });

  function populateSelectFromLoaded(){ pgnSelect.innerHTML = '<option value="">-- choose puzzle --</option>'; loadedPGNs.forEach((g,i)=>{ const opt = document.createElement('option'); opt.value = i; opt.textContent = (i+1) + '. ' + g.title; pgnSelect.appendChild(opt); }); }

  function onSelectChange(){ const idx = pgnSelect.value; if (idx === '') return; const selected = loadedPGNs[Number(idx)]; if (selected){ pgnText.value = selected.pgn; prepareFromPGNString(selected.pgn); } }

  pgnSelect.addEventListener('change', onSelectChange);

  loadBtn.addEventListener('click', () => { const idx = pgnSelect.value; if (idx !== ''){ const selected = loadedPGNs[Number(idx)]; if (selected) prepareFromPGNString(selected.pgn); else prepareFromPGNString(pgnText.value); } else { prepareFromPGNString(pgnText.value); } });

  pauseBtn.addEventListener('click', () => { stopAutoplay(); pauseBtn.textContent = 'Resume'; });

  resetBtn.addEventListener('click', () => { stopAutoplay(); currentMoveIndex = 0; const startFen = extractLastFEN(pgnText.value) || (loadedPGNs[pgnSelect.value] && extractLastFEN(loadedPGNs[pgnSelect.value].pgn)); if (startFen) game.load(startFen); else game.reset(); cg.set({ fen: game.fen() }); fenText.textContent = game.fen(); updateTurnText(); setAllowedMoveForStudent(); });

  prevBtn.addEventListener('click', () => { if (currentMoveIndex <= 0) return; stopAutoplay(); game.undo(); currentMoveIndex = Math.max(0, currentMoveIndex - 1); cg.set({ fen: game.fen() }); updateTurnText(); setAllowedMoveForStudent(); });

  nextBtn.addEventListener('click', () => { if (currentMoveIndex >= moves.length) return; stopAutoplay(); const san = moves[currentMoveIndex]; const res = game.move(san, { sloppy: true }); if (!res) { console.warn('Invalid next move', san); notationDiv.hidden = false; return; } currentMoveIndex++; cg.set({ fen: game.fen() }); updateTurnText(); setAllowedMoveForStudent(); });

  showBtn.addEventListener('click', () => { if (notationDiv.hidden){ notationDiv.hidden = false; showBtn.textContent = 'Hide answer'; } else { notationDiv.hidden = true; showBtn.textContent = 'Show answer'; } });

  clearBtn.addEventListener('click', () => { pgnText.value = ''; loadedPGNs = []; pgnSelect.innerHTML = '<option value="">-- no file loaded --</option>'; });

  restrictChk.addEventListener('change', () => setAllowedMoveForStudent());
  playAsBlackChk.addEventListener('change', () => { initChessground(game.fen(), playAsBlackChk.checked ? 'black' : 'white'); setAllowedMoveForStudent(); });

  window.addEventListener('load', () => { const sample = pgnText.value.trim(); if (sample) prepareFromPGNString(sample); });
  </script>
</body>
</html>
