<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U — Student Board</title>

  <!-- Chessboard CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />

  <style>
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:16px; background:#f6f7fb; color:#111; }
    .controls{ display:flex; justify-content:flex-end; gap:8px; margin-bottom:12px; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .container{ display:grid; grid-template-columns:420px 1fr; gap:18px; align-items:start; }
    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); }
    #board-wrapper{ width:420px; height:420px; display:flex; align-items:center; justify-content:center; }
    #board{ width:400px; height:400px; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; }
    #movesList{ min-height:220px; max-height:300px; overflow:auto; padding:8px; border-radius:6px; background:#fbfdff; border:1px solid #eef2ff; display:none; }
    textarea{ width:100%; min-height:120px; padding:8px; border-radius:6px; border:1px solid #e6eefc; font-family:monospace; }
    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; }
    @media (max-width:900px){ .container{ grid-template-columns:1fr; } #board-wrapper{ width:100%; } #board{ width:100%; height:80vw; max-height:420px; } .controls{ justify-content:center; } }
  </style>
</head>
<body>
  <div class="controls">
    <button id="undoBtn">Undo</button>
    <button id="prevBtn">Previous</button>
    <button id="nextBtn">Next</button>
    <button id="flipBtn">Flip</button>
  </div>

  <div class="container">
    <div class="panel">
      <div id="board-wrapper"><div id="board" aria-label="Chessboard container"></div></div>
      <div style="margin-top:10px; display:flex; justify-content:space-between; align-items:center;">
        <div>Orientation:
          <select id="orientationSelect"><option value="white">White</option><option value="black">Black</option></select>
        </div>
        <div>FEN: <code id="fenDisplay" style="font-family:monospace;"></code></div>
      </div>
      <div class="info" id="msg" aria-live="polite"></div>
    </div>

    <div style="display:flex; flex-direction:column; gap:12px;">
      <div class="panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>PGN / FEN Input</strong>
          <div style="display:flex; gap:8px;">
            <button id="loadPgnBtn">Load PGN</button>
            <button id="showAnswerBtn">Show answer</button>
          </div>
        </div>
        <div style="margin-top:8px;">
          <textarea id="pgnInput" placeholder="Paste PGN or FEN here. Example PGN: 1. e4 e5 2. Nf3 Nc6"></textarea>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <input type="file" id="pgnFile" accept=".pgn,text/plain">
            <button id="clearPgn">Clear</button>
            <button id="loadFenBtn">Load FEN</button>
            <button id="resetBtn">Reset</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <strong>Moves (hidden by default)</strong>
        <div id="movesList"></div>
      </div>
    </div>
  </div>

  <!-- jQuery (optional) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- =========================
       INLINE PGN PARSER (1.3.7)
       This defines global `parser.pgn2json()`.
       ========================= -->
  <script>
/* @module Chess PGN Parser, @version 1.3.7, @copyright Aditya D.S. 2020, @license MIT */
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).parser={})}(this,(function(e){"use strict";e.pgn2json=function(e){var n,t,i=e.split("\n"),r={str:{},moves:[],annotations:[],nag:[]},o=[];i.forEach(((e,n,t)=>t[n]=t[n].trim().replace("\r",""))),i=function(e){return e.filter((e=>"%"!==e.trim()[0]))}(i),[r.str,n]=function(e){var n={};for(let i=0;i<e.length;i++){var t=e[i];if("["===t[0]){let e=t.substring(1,t.indexOf(" ")),i=t.substring(t.indexOf(" ")+2,t.length-2);n[e]=i}else if("["!==t[0]&&""!==t.trim())return[n,e.slice(e.indexOf(t)).join(" ").trim().split("")]}}(i),t=n.join("").split(" ");for(let e=1;t.includes(`${e}.`);e++)o.push(t.indexOf(`${e}.`));return r.nag=function(e,n){var t=[];return e.filter((e=>e.includes("$"))).map((i=>{var r=0;t.length&&(r=t[t.length-1]);var o=n.filter((n=>n<e.indexOf(i,r)));return t.push(o[o.length-1]),{moveCount:o.length,value:i}}))}(t,o),r.annotations=function(e,n,t){for(var i=[];-1!==e.indexOf("{");){var r=e.indexOf("{"),o=e.indexOf("}"),f=e.splice(r,o-r+2).join(""),l=n.indexOf(f.split(" ")[0]);i.push({moveCount:t.filter((e=>e<l)).length,comment:f.substring(1,f.length-2)})}return i}(n,t,o),(n=(n=n.join("").split(" ")).filter((e=>!e.includes(".")&&!e.includes("$")))).pop(),r.moves=n,JSON.stringify(r,null,4)},Object.defineProperty(e,"__esModule",{value:!0})}));
  </script>
  <!-- End inline parser -->

  <script>
  (function(){
    // -------------------------
    // Keep your original CHESS_URL and piece-theme logic unchanged.
    // -------------------------
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    // helpers to fetch/check piece file
    async function pieceExists(url){
      try{
        const h = await fetch(url, { method:'HEAD', cache:'no-store', mode:'cors' });
        if (h.ok) return true;
      }catch(e){
        try{
          const r = await fetch(url + '?t=' + Date.now(), { method:'GET', cache:'no-store', mode:'cors' });
          return r.ok && ((r.headers.get('content-type')||'').includes('image') || (r.headers.get('content-type')||'').includes('svg'));
        }catch(e2){ return false; }
      }
      return false;
    }

    async function chooseTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const ok = await pieceExists(test); return ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // ensure Chess.js is present (as your old code did)
    async function ensureChess(){
      if (typeof Chess !== 'undefined') return true;
      try{
        // try dynamic import first (works if server serves proper module)
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        const candidate = mod.default || mod.Chess || mod;
        if (candidate){ window.Chess = candidate; return true; }
      }catch(err){ /* ignore */ }
      // fallback to script tag (synchronous load)
      return new Promise(resolve => {
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = false;
        s.onload = () => resolve(typeof Chess !== 'undefined');
        s.onerror = () => resolve(false);
        document.head.appendChild(s);
      });
    }

    // application state
    let currentTheme = FALLBACK_THEME;
    let game = null;
    let board = null;
    let pgnMoves = [];   // moves in SAN order (mainline)
    let stepIndex = 0;   // next move index to apply
    let autoplayTimer = null;
    const speedMsDefault = 900;

    // DOM refs
    const fenDisplay = document.getElementById('fenDisplay');
    const movesList = document.getElementById('movesList');
    const msgEl = document.getElementById('msg');

    function setMsg(t, ms){
      msgEl.textContent = t || '';
      if (ms && ms>0) setTimeout(()=>{ if(msgEl.textContent===t) msgEl.textContent=''; }, ms);
    }

    function updateFen(){ if(game) fenDisplay.textContent = game.fen(); else fenDisplay.textContent = ''; }

    function refreshMovesUI(){
      // Populate movesList with all moves (SAN) — used as "answer" only; hidden by default
      if (!pgnMoves || pgnMoves.length===0){ movesList.innerHTML = '<div class="small">No moves loaded.</div>'; return; }
      let html = '';
      for (let i=0;i<pgnMoves.length;i+=2){
        const no = Math.floor(i/2)+1;
        html += `<div style="padding:6px;border-radius:6px;"><strong>${no}.</strong> ${pgnMoves[i]||''} ${pgnMoves[i+1]||''}</div>`;
      }
      movesList.innerHTML = html;
    }

    // chessboard.js callbacks
    function onDrop(source, target){
      if (!game) return 'snapback';
      // try to make the move
      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) {
        setMsg('Illegal move', 1200);
        return 'snapback';
      }

      // Compare against expected SAN at current index
      const expected = pgnMoves[stepIndex];
      if (expected){
        if (move.san !== expected){
          // wrong move: undo and snapback
          game.undo();
          setTimeout(()=> { board.position(game.fen()); }, 60);
          setMsg('Wrong move — that is not the solution', 1400);
          return 'snapback';
        } else {
          // correct move by student
          stepIndex++;
          board.position(game.fen());
          updateFen();
          refreshMovesUI();
          // after student move, autoplay opponent moves if any
          scheduleAutoplayIfOpponentToMove();
        }
      } else {
        // no expected move (maybe puzzle finished) — accept but stop
        board.position(game.fen());
        updateFen();
      }
    }

    function onSnapEnd(){
      if (board) board.position(game.fen());
    }

    function createBoard(theme){
      const orientation = document.getElementById('orientationSelect').value || 'white';
      if (board && typeof board.destroy === 'function') {
        try { board.destroy(); } catch(e) {}
      }
      board = Chessboard('board', {
        draggable: true,
        position: game ? game.fen() : 'start',
        orientation: orientation,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: theme
      });
    }

    // PGN -> SAN moves extraction using parser.pgn2json (preferred) with chess.js fallback
    function extractMovesFromPGN(pgn){
      // 1) try parser.pgn2json
      try{
        if (typeof parser !== 'undefined' && typeof parser.pgn2json === 'function'){
          const jsonStr = parser.pgn2json(pgn);
          const parsed = JSON.parse(jsonStr);
          // parsed.moves is array of SAN-like tokens (may include move numbers removed by parser)
          if (parsed && Array.isArray(parsed.moves) && parsed.moves.length>0){
            return { moves: parsed.moves.filter(m=>typeof m==='string' && m.trim()), headers: parsed.str || {} };
          }
        }
      }catch(e){
        console.warn('parser.pgn2json failed', e);
      }

      // 2) fallback: try Chess.js to load_pgn
      try{
        const tmp = new Chess();
        // try either load_pgn or load
        let ok = false;
        try { ok = typeof tmp.load_pgn === 'function' ? tmp.load_pgn(pgn) : (typeof tmp.load === 'function' ? tmp.load(pgn) : false); } catch(e2){ ok = false; }
        if (ok){
          return { moves: tmp.history(), headers: {} };
        }
      }catch(e){
        console.warn('Chess.js fallback pgn load failed', e);
      }

      // final fallback: naive strip and tokenization
      // Strip comments and variations, remove tags, and return tokens (this is weaker)
      try{
        let s = pgn.replace(/\{[^}]*\}/g,' ');
        s = s.replace(/%[^\n]*\n/g,' ');
        while (/\([^()]*\)/.test(s)) s = s.replace(/\([^()]*\)/g,' ');
        s = s.replace(/\[[^\]]*\]/g,' ');
        s = s.replace(/\s+/g,' ').trim();
        const toks = s.split(' ').filter(t=> t && !/^\d+\.{1,3}$/.test(t) && t!=='1-0' && t!=='0-1' && t!=='1/2-1/2' && t!=='*');
        return { moves: toks, headers: {} };
      }catch(e){
        return { moves: [], headers: {} };
      }
    }

    // set up puzzle: apply starting FEN if provided and prepare pgnMoves
    function preparePuzzleFromPGN(pgn){
      stopAutoplay();
      const result = extractMovesFromPGN(pgn);
      pgnMoves = result.moves || [];
      stepIndex = 0;

      // If parser provided FEN header with SetUp=1, try to load it
      let startFen = null;
      if (result.headers && result.headers.FEN){
        startFen = result.headers.FEN;
        if (result.headers.SetUp !== undefined && result.headers.SetUp !== '1') startFen = null; // only use FEN if SetUp=1
      }

      // initialize game
      try{
        if (typeof Chess === 'undefined'){ setMsg('Chess.js not loaded. See console.', 0); movesList.style.display='block'; movesList.textContent = pgn; return; }
        game = startFen ? new Chess(startFen) : new Chess();
      }catch(e){
        console.error('Failed to construct Chess:', e);
        setMsg('Chess engine error. See console.', 0);
        return;
      }

      updateFen();
      refreshMovesUI(); // (hidden by default)
      // init board with piece theme and orientation
      chooseTheme().then(theme => {
        currentTheme = theme;
        createBoard(currentTheme);
        // If FEN indicates black to move OR the first move in pgn is a black move (like "1... Bg4"),
        // we should autoplay opponent moves until it becomes student's turn (student assumed to be White).
        scheduleAutoplayIfOpponentToMove();
      });
    }

    // autoplay: apply opponent moves automatically while it is not student's turn (student = White)
    function scheduleAutoplayIfOpponentToMove(){
      stopAutoplay();
      const studentColor = 'w'; // fixed: student is always White (no checkbox)
      // while game exists and it's not White to move, apply moves automatically with delay
      const speed = Math.max(60, parseInt(document.getElementById('speed') ? document.getElementById('speed').value : speedMsDefault, 10) || speedMsDefault);

      function step(){
        // if puzzle finished or no move at index, stop
        if (!game || stepIndex >= pgnMoves.length) { stopAutoplay(); setAllowedMoveForStudent(); return; }
        // If it is student's turn, stop autoplay
        if (game.turn() === studentColor) { stopAutoplay(); setAllowedMoveForStudent(); return; }
        // Otherwise apply next move (opponent)
        const san = pgnMoves[stepIndex];
        const res = game.move(san, { sloppy: true });
        if (!res){
          // invalid move in PGN: show notation and stop
          console.warn('Invalid PGN move at', stepIndex, san);
          movesList.style.display = 'block';
          setMsg('PGN contains invalid move. See notation.', 0);
          stopAutoplay();
          return;
        }
        stepIndex++;
        if (board) board.position(game.fen());
        updateFen();
        // continue until student's turn or moves exhausted
        if (stepIndex < pgnMoves.length && game.turn() !== studentColor){
          autoplayTimer = setTimeout(step, speed);
        } else {
          setAllowedMoveForStudent();
          stopAutoplay();
        }
      }

      // begin
      if (game.turn() !== studentColor && stepIndex < pgnMoves.length){
        autoplayTimer = setTimeout(step, speed);
      } else {
        setAllowedMoveForStudent();
      }
    }

    function stopAutoplay(){ if (autoplayTimer) { clearTimeout(autoplayTimer); autoplayTimer = null; } }

    // set allowed moves for student: restrict so student can only play expected SAN at stepIndex
    function setAllowedMoveForStudent(){
      // chessboard.js does not provide per-square dest restriction like chessground.
      // We'll enforce restriction in onDrop by rejecting wrong SAN moves (already implemented).
      // To provide visual guidance we could highlight source square; for now, keep behavior simple.
      // (Board remains draggable — onDrop will accept or snapback.)
      // No extra code needed here for chessboard.js approach.
    }

    // UI wiring
    function wireUI(){
      document.getElementById('undoBtn').onclick = () => { if (!game) return; game.undo(); board.position(game.fen()); updateFen(); };
      document.getElementById('flipBtn').onclick = () => board.flip();
      document.getElementById('resetBtn').onclick = () => { if (!game) { game = new Chess(); } else { game.reset(); } pgnMoves=[]; stepIndex=0; board.position(game.fen()); updateFen(); refreshMovesUI(); setMsg('Reset', 900); };
      document.getElementById('clearPgn').onclick = () => { document.getElementById('pgnInput').value = ''; };
      document.getElementById('loadFenBtn').onclick = () => {
        const txt = document.getElementById('pgnInput').value.trim();
        if (!txt){ alert('Paste FEN first'); return; }
        if (!game) game = new Chess();
        const ok = game.load(txt);
        if (!ok){ alert('Invalid FEN'); return; }
        pgnMoves=[]; stepIndex=0; board.position(game.fen()); updateFen(); refreshMovesUI();
      };

      // Load PGN: prepare puzzle and autoplay opponent moves automatically
      document.getElementById('loadPgnBtn').onclick = () => {
        const pgn = document.getElementById('pgnInput').value.trim();
        if (!pgn){ alert('Paste PGN'); return; }
        preparePuzzleFromPGN(pgn);
      };

      // Show/hide answer
      document.getElementById('showAnswerBtn').onclick = function(){
        if (movesList.style.display === 'none' || movesList.style.display === '') {
          movesList.style.display = 'block';
          this.textContent = 'Hide answer';
        } else {
          movesList.style.display = 'none';
          this.textContent = 'Show answer';
        }
      };

      // file upload: take first PGN in file
      document.getElementById('pgnFile').addEventListener('change', function(ev){
        const file = ev.target.files[0]; if(!file) return;
        const reader = new FileReader();
        reader.onload = function(e){
          const text = e.target.result;
          // naive split by blank lines/events; we take first puzzle
          const parts = text.split(/\n\s*\n/).map(s=>s.trim()).filter(Boolean);
          const chosen = parts.length>0 ? parts[0] : text;
          document.getElementById('pgnInput').value = chosen;
          preparePuzzleFromPGN(chosen);
        };
        reader.readAsText(file,'utf-8');
      });

      document.getElementById('nextBtn').onclick = function(){
        // apply next PGN move (regardless of side)
        if (!game || stepIndex >= pgnMoves.length) return;
        const san = pgnMoves[stepIndex];
        const res = game.move(san, { sloppy:true });
        if (!res){ alert('Invalid PGN move'); return; }
        stepIndex++;
        board.position(game.fen());
        updateFen();
      };

      document.getElementById('prevBtn').onclick = function(){
        if (!game || stepIndex<=0) return;
        game.undo();
        stepIndex = Math.max(0, stepIndex-1);
        board.position(game.fen());
        updateFen();
      };

      // orientation select
      document.getElementById('orientationSelect').onchange = function(){
        if (board) {
          // re-create board with new orientation while preserving position
          const theme = currentTheme || FALLBACK_THEME;
          createBoard(theme);
        }
      };
    }

    // boot sequence
    window.addEventListener('load', async () => {
      const okChess = await ensureChess();
      if (!okChess){ console.error('Chess.js failed to load'); alert('Chess.js failed to load. See console.'); return; }

      currentTheme = await chooseTheme();
      game = new Chess();
      createBoard(currentTheme);
      updateFen();
      refreshMovesUI();
      wireUI();

      // Auto-load if there's PGN text already in textarea
      const sample = document.getElementById('pgnInput').value.trim();
      if (sample) preparePuzzleFromPGN(sample);

      // expose debug
      window._iq4u = { game, board, currentTheme, pgnMoves };
      console.log('IQ4U puzzle loaded. Piece theme:', currentTheme);
    });
  })();
  </script>
</body>
</html>
