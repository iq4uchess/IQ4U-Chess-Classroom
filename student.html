<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>IQ4U — Student Puzzle (centered top board + resizer)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    /* --- base styles (kept largely the same) --- */
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .container{ display:grid; grid-template-columns:420px 1fr; gap:18px; align-items:start; }

    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); }

    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; }

    /* --- TOP BOARD SECTION (spans entire grid and centers content) --- */
    .board-top{ grid-column: 1 / -1; display:flex; flex-direction:column; align-items:center; gap:12px; }

    /* controls centered above the board */
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; }

    /* board wrapper flexible with a max-width; can be adjusted via JS */
    #board-wrapper{ width:100%; max-width:920px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; }
    /* board fills wrapper width and keeps square aspect ratio */
    #board{ width:100%; aspect-ratio: 1 / 1; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; max-height:80vh; }

    /* Resizer UI */
    .resizer{ display:flex; gap:10px; align-items:center; background:transparent; }
    .resizer .range{ width:260px; }
    .resizer small{ color:#444; display:block; min-width:48px; text-align:center; font-size:13px; }

    /* keep the original right/left panel sizing below the board unchanged */
    #movesList{ min-height:220px; max-height:300px; overflow:auto; padding:8px; border-radius:6px; background:#fbfdff; border:1px solid #eef2ff; display:none; }

    textarea{ width:100%; min-height:120px; padding:8px; border-radius:6px; border:1px solid #e6eefc; font-family:monospace; }

    @media (max-width:900px){
      .container{ grid-template-columns:1fr; }
      /* for small screens, keep board-top spanning full width and padding handled naturally */
      #board-wrapper{ max-width:100%; }
      #board{ height:80vw; width:100%; aspect-ratio: auto; max-height:420px; }
      .resizer .range{ width:140px; }
    }
  </style>
</head>
<body>

  <!-- TOP BOARD SECTION (spans both columns) -->
  <div class="board-top">
    <div class="controls" aria-hidden="false">
      <button id="undoBtn">Undo</button>
      <button id="prevBtn">Previous</button>
      <button id="nextBtn">Next</button>
      <button id="flipBtn">Flip</button>

      <!-- Resizer UI (added) -->
      <div style="width:18px;"></div><!-- small gap -->
      <div class="resizer" aria-label="Board resizer controls">
        <button id="presetSmall" title="Small">S</button>
        <button id="presetMed" title="Medium">M</button>
        <button id="presetLarge" title="Large">L</button>
        <input id="boardSizeRange" class="range" type="range" min="240" max="1200" step="10" value="920" aria-label="Board size">
        <small id="boardSizeLabel">920px</small>
      </div>
    </div>

    <div class="panel" style="width:100%; max-width:920px;">
      <div id="board-wrapper"><div id="board" aria-label="Chessboard container"></div></div>

      <div style="margin-top:10px; display:flex; justify-content:space-between; align-items:center;">
        <div>Orientation:
          <select id="orientationSelect"><option value="white">White</option><option value="black">Black</option></select>
        </div>
        <div>FEN: <code id="fenDisplay" style="font-family:monospace;"></code></div>
      </div>
      <div class="info" id="msg" aria-live="polite"></div>
    </div>
  </div>

  <!-- BELOW: original two-column layout preserved (panels are same size as before) -->
  <div class="container" style="margin-top:18px;">
    <div style="display:flex; flex-direction:column; gap:12px;">
      <div class="panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>PGN / FEN Input</strong>
          <div style="display:flex; gap:8px;">
            <button id="loadPgnBtn">Load PGN</button>
            <button id="showAnswerBtn">Show answer</button>
          </div>
        </div>
        <div style="margin-top:8px;">
          <textarea id="pgnInput" placeholder="Paste PGN or FEN here. Example PGN: 1. e4 e5 2. Nf3 Nc6"></textarea>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <input type="file" id="pgnFile" accept=".pgn,text/plain">
            <button id="clearPgn">Clear</button>
            <button id="loadFenBtn">Load FEN</button>
            <button id="resetBtn">Reset</button>
          </div>
        </div>
      </div>
    </div>

    <div style="display:flex; flex-direction:column; gap:12px;">
      <div class="panel">
        <strong>Moves (hidden by default)</strong>
        <div id="movesList"></div>
      </div>
    </div>
  </div>

  <!-- jQuery (optional) and chessboard lib -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <!-- Inline PGN parser (unchanged) -->
  <script>
/* @module Chess PGN Parser, @version 1.3.7 (same inline as before) */
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).parser={})}(this,(function(e){"use strict";e.pgn2json=function(e){var n,t,i=e.split("\n"),r={str:{},moves:[],annotations:[],nag:[]},o=[];i.forEach(((e,n,t)=>t[n]=t[n].trim().replace("\r",""))),i=function(e){return e.filter((e=>"%"!==e.trim()[0]))}(i),[r.str,n]=function(e){var n={};for(let i=0;i<e.length;i++){var t=e[i];if("["===t[0]){let e=t.substring(1,t.indexOf(" ")),i=t.substring(t.indexOf(" ")+2,t.length-2);n[e]=i}else if("["!==t[0]&&""!==t.trim())return[n,e.slice(e.indexOf(t)).join(" ").trim().split("")]}}(i),t=n.join("").split(" ");for(let e=1;t.includes(`${e}.`);e++)o.push(t.indexOf(`${e}.`));return r.nag=function(e,n){var t=[];return e.filter((e=>e.includes("$"))).map((i=>{var r=0;t.length&&(r=t[t.length-1]);var o=n.filter((n=>n<e.indexOf(i,r)));return t.push(o[o.length-1]),{moveCount:o.length,value:i}}))}(t,o),r.annotations=function(e,n,t){for(var i=[];-1!==e.indexOf("{");){var r=e.indexOf("{"),o=e.indexOf("}"),f=e.splice(r,o-r+2).join(""),l=n.indexOf(f.split(" ")[0]);i.push({moveCount:t.filter((e=>e<l)).length,comment:f.substring(1,f.length-2)})}return i}(n,t,o),(n=(n=n.join("").split(" ")).filter((e=>!e.includes(".")&&!e.includes("$")))).pop(),r.moves=n,JSON.stringify(r,null,4)},Object.defineProperty(e,"__esModule",{value:!0})}));
  </script>

  <!-- Main script (keeps your logic intact, only layout/CSS changed above) -->
  <script>
  (function(){
    // keep your CHESS_URL (unchanged)
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    // DOM refs
    const pgnInput = document.getElementById('pgnInput');
    const pgnFile = document.getElementById('pgnFile');
    const loadPgnBtn = document.getElementById('loadPgnBtn');
    const showAnswerBtn = document.getElementById('showAnswerBtn');
    const clearPgnBtn = document.getElementById('clearPgn');
    const loadFenBtn = document.getElementById('loadFenBtn');
    const resetBtn = document.getElementById('resetBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const undoBtn = document.getElementById('undoBtn');
    const flipBtn = document.getElementById('flipBtn');
    const orientationSelect = document.getElementById('orientationSelect');
    const movesList = document.getElementById('movesList');
    const fenDisplay = document.getElementById('fenDisplay');
    const msgEl = document.getElementById('msg');

    // Resizer refs
    const boardWrapper = document.getElementById('board-wrapper');
    const boardSizeRange = document.getElementById('boardSizeRange');
    const boardSizeLabel = document.getElementById('boardSizeLabel');
    const presetSmall = document.getElementById('presetSmall');
    const presetMed = document.getElementById('presetMed');
    const presetLarge = document.getElementById('presetLarge');

    // state
    let game = null, board = null, pgnMoves = [], stepIndex = 0, currentTheme = FALLBACK_THEME;

    // puzzles state: when multiple PGNs are present
    let puzzles = [];       // array of PGN strings
    let puzzleIndex = 0;    // index into puzzles[]

    function setMsg(t, ms){ msgEl.textContent = t||''; if(ms>0) setTimeout(()=>{ if(msgEl.textContent===t) msgEl.textContent=''; }, ms); }

    // Robust helpers (fixed newline handling and safer operations)
    function stripCommentsAndVariations(raw){
      if(!raw || typeof raw !== 'string') return '';
      // Remove curly-brace comments
      let s = raw.replace(/\{[^}]*\}/g, ' ');
      // Remove percent-comments
      s = s.replace(/%[^\n]*\n/g, ' ');
      // Remove parenthesis variations (non-greedy; repeated until none left)
      while(/\([^()]*\)/.test(s)) s = s.replace(/\([^()]*\)/g, ' ');
      return s;
    }

    function extractLastFEN(raw){
      if(!raw || typeof raw !== 'string') return null;
      const re = /\[FEN\s+"([^"]+)"\]/g;
      let m, last=null;
      while((m=re.exec(raw))!==null) last = m[1];
      return last;
    }

    function extractSANMoves(pgnClean){
      if(!pgnClean || typeof pgnClean !== 'string') return [];
      // remove tag pairs like [Event "..."]
      let body = pgnClean.replace(/\[[^\]]*\]/g, ' ');
      // collapse whitespace
      body = body.replace(/\s+/g,' ').trim();
      if(!body) return [];
      const tokens = body.split(' ').filter(t => t && !/^\d+\.{1,3}$/.test(t) && t!=='1-0' && t!=='0-1' && t!=='1/2-1/2' && t!=='*');
      return tokens;
    }

    function splitPGNs(raw){
      if(!raw || typeof raw !== 'string') return [];
      // Try split by [Event occurrences first
      const events = raw.split(/\n(?=\[Event\s)/);
      const cleaned = events.map(e => e.trim()).filter(Boolean);
      if(cleaned.length>1) return cleaned;
      // Otherwise split by two or more newlines
      return raw.split(/\n\s*\n/).map(s=>s.trim()).filter(Boolean);
    }

    function refreshMovesUI(){
      if(!pgnMoves || pgnMoves.length===0){ movesList.innerHTML = '<div class="small">No moves loaded.</div>'; return; }
      let html='';
      for(let i=0;i<pgnMoves.length;i+=2){
        const no = Math.floor(i/2)+1;
        html += `<div style="padding:6px;border-radius:6px;"><strong>${no}.</strong> ${pgnMoves[i]||''} ${pgnMoves[i+1]||''}</div>`;
      }
      movesList.innerHTML = html;
    }

    // chessboard callbacks
    function onDrop(source, target){
      if(!game) return 'snapback';
      const move = game.move({ from: source, to: target, promotion:'q' });
      if(move === null){ setMsg('Illegal move', 1200); return 'snapback'; }
      // enforce expected move if exists
      const expected = pgnMoves[stepIndex];
      if(expected){
        if(move.san !== expected){
          game.undo();
          setTimeout(()=> board.position(game.fen()), 60);
          setMsg('Wrong move — not the expected solution', 1400);
          return 'snapback';
        } else {
          stepIndex++; board.position(game.fen()); fenDisplay.textContent = game.fen(); refreshMovesUI();
          // after student's correct move, let autoplay opponent if any
          scheduleAutoplayIfOpponentToMove();
        }
      } else {
        board.position(game.fen()); fenDisplay.textContent = game.fen();
      }
    }
    function onSnapEnd(){ if(board) board.position(game.fen()); }

    function createBoard(theme){
      const orientation = orientationSelect.value || 'white';
      if(board && typeof board.destroy === 'function'){ try{ board.destroy(); }catch(e){} }
      // chessboard-js reads the element size; #board is flexible in CSS now
      board = Chessboard('board', {
        draggable: true,
        position: game ? game.fen() : 'start',
        orientation: orientation,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: theme
      });
    }

    // new: setBoardSize(px) - adjusts board-wrapper max-width and triggers resize
    function setBoardSize(px){
      if(!px || isNaN(px)) return;
      const clamped = Math.max(240, Math.min(1200, Number(px)));
      boardWrapper.style.maxWidth = clamped + 'px';
      boardSizeRange.value = clamped;
      boardSizeLabel.textContent = clamped + 'px';
      // If chessboard-js supports resize(), prefer that; otherwise recreate the board
      try{
        if(board && typeof board.resize === 'function'){
          board.resize();
        } else {
          // recreate to force correct sizing
          createBoard(currentTheme);
        }
      }catch(e){
        // fallback recreate
        createBoard(currentTheme);
      }
    }

    // PGN extraction — use parser if available but fallback safely
    function extractMovesFromPGN(pgn){
      // try inline parser
      if(typeof parser !== 'undefined' && typeof parser.pgn2json === 'function'){
        try{
          const jsonStr = parser.pgn2json(pgn);
          if(typeof jsonStr === 'string' && jsonStr.length>10){
            const parsed = JSON.parse(jsonStr);
            if(parsed && Array.isArray(parsed.moves) && parsed.moves.length>0){
              return { moves: parsed.moves.filter(m=>typeof m==='string'&&m.trim()), headers: parsed.str||{} };
            }
          }
        }catch(e){
          // swallow and fallback
          console.warn('parser.pgn2json failed, falling back', e);
        }
      }
      // fallback naive clean
      const cleaned = stripCommentsAndVariations(pgn);
      const tokens = extractSANMoves(cleaned);
      return { moves: tokens, headers: {} };
    }

    // prepare puzzle
    function preparePuzzleFromPGN(pgn){
      try{ stopAutoplay(); }catch(e){}
      if(!pgn || typeof pgn !== 'string'){ setMsg('No PGN provided', 1200); return; }
      console.log('preparePuzzleFromPGN: received PGN (first 200 chars):', pgn.slice(0,200).replace(/\n/g,' '));
      const res = extractMovesFromPGN(pgn);
      pgnMoves = res.moves || []; stepIndex = 0;
      // try FEN header
      const fen = (res.headers && res.headers.FEN) ? res.headers.FEN : extractLastFEN(pgn);
      try{
        if(typeof Chess === 'undefined'){ setMsg('Chess.js not loaded (check console)',0); movesList.style.display='block'; movesList.textContent = pgn; return; }
        game = fen ? new Chess(fen) : new Chess();
      }catch(e){
        console.error('Failed to init Chess:', e); setMsg('Chess engine error',0); return;
      }
      fenDisplay.textContent = game.fen(); refreshMovesUI(); // hidden by default
      chooseTheme().then(theme => { currentTheme = theme; createBoard(currentTheme); scheduleAutoplayIfOpponentToMove(); });
    }

    // autoplay opponent moves while it's opponent turn (student is White)
    let autoplayTimer = null;
    function scheduleAutoplayIfOpponentToMove(){
      try{ if(autoplayTimer) { clearTimeout(autoplayTimer); autoplayTimer = null; } }catch(e){}
      const studentColor = 'w';
      const speed = 900;
      function step(){
        if(!game || stepIndex >= pgnMoves.length){ clearTimeout(autoplayTimer); autoplayTimer=null; return; }
        if(game.turn() === studentColor){ clearTimeout(autoplayTimer); autoplayTimer=null; return; }
        const san = pgnMoves[stepIndex];
        const r = game.move(san, { sloppy:true });
        if(!r){ console.warn('Invalid PGN move at', stepIndex, san); movesList.style.display='block'; setMsg('PGN invalid — see notation',0); clearTimeout(autoplayTimer); autoplayTimer=null; return; }
        stepIndex++;
        if(board) board.position(game.fen()); fenDisplay.textContent = game.fen();
        if(stepIndex < pgnMoves.length && game.turn() !== studentColor) autoplayTimer = setTimeout(step, speed);
      }
      if(game && game.turn() !== studentColor) autoplayTimer = setTimeout(step, speed); else setAllowedMoveForStudent();
    }
    function stopAutoplay(){ if(autoplayTimer) clearTimeout(autoplayTimer); autoplayTimer = null; }

    function setAllowedMoveForStudent(){
      // chessboard.js has no per-square restriction; enforcement happens in onDrop (snapback)
      // This function kept for parity and future UI hints.
    }

    // piece-theme detection
    async function pieceExists(url){
      try{
        const res = await fetch(url, { method:'HEAD', cache:'no-store', mode:'cors' });
        return res.ok;
      }catch(e){
        return false;
      }
    }
    async function chooseTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const ok = await pieceExists(test); return ok ? CUSTOM_PIECE_THEME : FALLBACK_THEME; }catch(e){ return FALLBACK_THEME; }
    }

    // file upload handling
    pgnFile.addEventListener('change', function(ev){
      const file = ev.target.files[0]; if(!file) return;
      const reader = new FileReader();
      reader.onload = function(e){
        const text = e.target.result;
        const parts = splitPGNs(text);
        // populate puzzles[] with detected parts; default to first part in textarea
        if(parts && parts.length>0){
          puzzles = parts.slice();
          puzzleIndex = 0;
          pgnInput.value = puzzles[0];
          setMsg(`Loaded ${puzzles.length} puzzle(s) from file. Showing 1/${puzzles.length}`, 2200);
        } else {
          puzzles = [text];
          puzzleIndex = 0;
          pgnInput.value = text;
        }
        console.log('Uploaded .pgn file — parts:', puzzles.length);
      };
      reader.readAsText(file,'utf-8');
    });

    // helpers: split by [Event] or blank lines
    function splitPGNs(raw){
      if(!raw || typeof raw !== 'string') return [];
      const byEvent = raw.split(/\n(?=\[Event\s)/g).map(s=>s.trim()).filter(Boolean);
      if(byEvent.length>1) return byEvent;
      return raw.split(/\n\s*\n/).map(s=>s.trim()).filter(Boolean);
    }

    // UI wiring
    loadPgnBtn.addEventListener('click', function(){
      const txt = pgnInput.value.trim();
      console.log('Load PGN clicked. Text len:', txt.length);
      if(!txt){ setMsg('Paste or upload a PGN first', 1500); return; }

      const parts = splitPGNs(txt);
      if(parts && parts.length>1){
        puzzles = parts.slice();
        puzzleIndex = 0;
        setMsg(`Detected ${puzzles.length} puzzles. Loading 1/${puzzles.length}`, 1800);
        preparePuzzleFromPGN(puzzles[puzzleIndex]);
      } else {
        puzzles = [txt];
        puzzleIndex = 0;
        preparePuzzleFromPGN(txt);
      }
    });

    // other UI
    showAnswerBtn.onclick = function(){
      if(movesList.style.display === 'none' || movesList.style.display === ''){ movesList.style.display='block'; this.textContent='Hide answer'; } else { movesList.style.display='none'; this.textContent='Show answer'; }
    };
    clearPgnBtn.onclick = ()=>{ pgnInput.value=''; puzzles = []; puzzleIndex = 0; };
    loadFenBtn.onclick = ()=> {
      const txt = pgnInput.value.trim(); if(!txt){ alert('Paste FEN first'); return; }
      try{ if(!game) game = new Chess(); const ok = game.load(txt); if(!ok){ alert('Invalid FEN'); return; } stepIndex=0; pgnMoves=[]; if(board) board.position(game.fen()); fenDisplay.textContent=game.fen(); }catch(e){ alert('Invalid FEN'); }
    };
    resetBtn.onclick = ()=> { if(!game) game = new Chess(); else game.reset(); stepIndex=0; pgnMoves=[]; if(board) board.position(game.fen()); fenDisplay.textContent = game.fen(); refreshMovesUI(); setMsg('Reset',900); };

    // NEXT / PREV behaviour:
    // - If multiple puzzles are loaded (puzzles.length > 1), Next/Prev switches puzzles.
    // - Otherwise, Next/Prev advances/rewinds moves as before.

    nextBtn.onclick = ()=> {
      if(puzzles && puzzles.length > 1){
        if(puzzleIndex < puzzles.length - 1){
          puzzleIndex++;
          pgnInput.value = puzzles[puzzleIndex];
          preparePuzzleFromPGN(puzzles[puzzleIndex]);
          setMsg(`Loaded puzzle ${puzzleIndex+1}/${puzzles.length}`, 1500);
        } else {
          setMsg('Already at last puzzle', 1200);
        }
        return;
      }
      // single puzzle -> advance move
      if(!game || stepIndex>=pgnMoves.length) return;
      const san = pgnMoves[stepIndex];
      const r = game.move(san, { sloppy:true });
      if(!r){ alert('Invalid PGN move'); return; }
      stepIndex++;
      if(board) board.position(game.fen());
      fenDisplay.textContent = game.fen();
    };

    prevBtn.onclick = ()=> {
      if(puzzles && puzzles.length > 1){
        if(puzzleIndex > 0){
          puzzleIndex--;
          pgnInput.value = puzzles[puzzleIndex];
          preparePuzzleFromPGN(puzzles[puzzleIndex]);
          setMsg(`Loaded puzzle ${puzzleIndex+1}/${puzzles.length}`, 1500);
        } else {
          setMsg('Already at first puzzle', 1200);
        }
        return;
      }
      // single puzzle -> previous move
      if(!game || stepIndex<=0) return;
      game.undo();
      stepIndex = Math.max(0, stepIndex-1);
      if(board) board.position(game.fen());
      fenDisplay.textContent = game.fen();
    };

    undoBtn.onclick = ()=> { if(!game) return; game.undo(); if(board) board.position(game.fen()); fenDisplay.textContent = game.fen(); };
    flipBtn.onclick = ()=> { if(board) board.flip(); };
    orientationSelect.onchange = ()=> { if(board) createBoard(currentTheme); };

    // Resizer event wiring
    boardSizeRange.addEventListener('input', (e)=> {
      setBoardSize(e.target.value);
    });
    presetSmall.addEventListener('click', ()=> setBoardSize(360));
    presetMed.addEventListener('click', ()=> setBoardSize(720));
    presetLarge.addEventListener('click', ()=> setBoardSize(920));

    // boot
    async function boot(){
      // ensure Chess.js
      if(typeof Chess === 'undefined'){
        try{
          // try dynamic import then fallback to script tag (like your previous logic)
          const mod = await import(CHESS_URL + '?t=' + Date.now());
          const candidate = mod.default || mod.Chess || mod;
          if(candidate) window.Chess = candidate;
        }catch(e){ /* ignore */ }
        if(typeof Chess === 'undefined'){
          var s = document.createElement('script'); s.src = CHESS_URL + '?t=' + Date.now(); s.async=false;
          s.onload = ()=> { console.info('Chess.js loaded via script tag'); };
          s.onerror = ()=> { console.warn('Chess.js failed to load from CHESS_URL'); setMsg('Chess.js failed to load — check console', 0); };
          document.head.appendChild(s);
        }
      }

      // after libs load (or attempted), initialize
      try{
        currentTheme = await chooseTheme();
      }catch(e){ currentTheme = FALLBACK_THEME; }
      game = new Chess();
      createBoard(currentTheme);
      fenDisplay.textContent = game.fen();
      refreshMovesUI();
      setMsg('', 0);
      console.log('Boot complete. Using piece theme:', currentTheme);

      // Initialize resizer default to current wrapper size (read CSS max-width or fallback)
      const initial = parseInt(getComputedStyle(boardWrapper).maxWidth,10) || boardWrapper.clientWidth || 920;
      setBoardSize(initial);
    }

    boot();

    // Recreate / resize board on window resize to ensure chessboard-js picks up new element size
    let resizeTimer = null;
    window.addEventListener('resize', ()=> {
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=> {
        try{
          if(board && typeof board.resize === 'function'){
            board.resize();
          } else {
            createBoard(currentTheme);
          }
        }catch(e){
          createBoard(currentTheme);
        }
      }, 150);
    });

  })();
  </script>
</body>
</html>


