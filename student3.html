<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U â€” Student Puzzle (student3)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    html,body{ overscroll-behavior-y: contain; height:100%; }
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; -webkit-font-smoothing:antialiased; display:flex; flex-direction:column; align-items:center; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); margin:0 auto; max-width:980px; width:100%; box-sizing:border-box; }
    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; text-align:center; }
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; width:100%; }
    #board-wrapper{ width:100%; max-width:760px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; margin:0 auto; position:relative; padding:16px; }
    #board-wrapper, #board { touch-action: none; -webkit-user-select: none; -webkit-touch-callout: none; user-select: none; -ms-touch-action: none; }
    #board{ width:100%; aspect-ratio: 1 / 1; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; max-height:88vh; min-width:520px; min-height:520px; box-shadow: 0 6px 18px rgba(2,6,23,0.04); border-radius:8px; padding:6px; }
    .resizer{ display:flex; gap:10px; align-items:center; background:transparent; justify-content:center; width:100%; }
    .resizer .range{ width:320px; }
    .resizer small{ color:#444; display:block; min-width:48px; text-align:center; font-size:13px; }
    textarea{ width:100%; max-width:720px; min-height:80px; padding:8px; border-radius:6px; border:1px solid #e6eefc; font-family:monospace; display:block; margin:0 auto; box-sizing:border-box; }
    .notation { margin-top:12px; padding:8px; border-radius:6px; border:1px solid #eef2ff; background:#fbfdff; min-height:44px; max-height:180px; overflow:auto; font-family:monospace; font-size:13px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .notation .move { white-space:normal; display:inline-block; padding:4px 8px; border-radius:6px; background:transparent; }
    .notation .move.current { background:#0f172a; color:#fff; }
    .tactic-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .solution-controls { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .solution-controls .small { margin-left:6px; margin-right:2px; }
    @media (max-width:900px){
      #board{ height:80vw; width:100%; aspect-ratio: auto; max-height:620px; min-width:300px; min-height:300px; }
      .resizer .range{ width:200px; }
    }
    .status-bubble { padding:8px 10px; border-radius:8px; background:#f3f6ff; border:1px solid #e6eeff; color:#0b2; font-weight:600; }
    .promote-modal { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; border-radius:10px; padding:12px; box-shadow:0 10px 30px rgba(2,6,23,0.2); z-index:9999; display:none; }
    .logout-btn { background:#dc2626; }
    .stats { margin-top:10px; display:flex; gap:16px; align-items:center; justify-content:flex-end; font-weight:600; color:#111; }
    .cb-last-move { outline: 3px solid rgba(255,200,0,0.95); outline-offset: -3px; box-shadow: inset 0 0 0 2px rgba(255,200,0,0.25); }
    .puzzle-meta { margin-left:8px; font-weight:600; color:#222; }
    .engine-controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 14px; }
    h1 { color: #0f172a; margin-bottom: 10px; text-align: center; }
    #engineOnBtn { background: #10b981; }
    #engineOffBtn { background: #ef4444; display: none; }
    .engine-status { padding: 4px 8px; border-radius: 4px; background: #f3f4f6; font-size: 12px; color: #666; }
    #engineThinking { display: none; color: #059669; font-weight: 600; }
    .engine-strength { display: flex; align-items: center; gap: 8px; }
    .engine-strength input[type="range"] { width: 180px; }
  </style>
</head>

<body>

<h1>Student3 - Play vs Stockfish Engine</h1>

<div class="panel">
  <div class="controls">
    <button id="undoBtn">Undo</button>
    <button id="flipBtn">Flip</button>
    <button id="resetBtn" style="background:#8b0f0f;">Reset Game</button>
    <button id="logoutBtn" class="logout-btn" style="margin-left:auto;">Logout</button>
  </div>

  <div class="resizer">
    <input id="boardSizeRange" name="board-size" class="range" type="range" min="360" max="1400" step="10" value="760" aria-label="Board size">
    <small id="boardSizeLabel">760px</small>
  </div>

  <div id="board-wrapper" style="margin-top:12px;">
    <div id="board" aria-label="Chessboard container"></div>
  </div>

  <div id="status" class="info">White to move</div>
  
  <div id="movesList" class="notation" aria-live="polite" role="status">No moves yet.</div>
</div>

<!-- Engine Controls Panel -->
<div class="panel" style="margin-top:18px;">
  <div class="engine-controls">
    <div>
      <label class="small">Engine Side:</label>
      <select id="engineColor">
        <option value="white">Engine as White</option>
        <option value="black" selected>Engine as Black</option>
        <option value="both">Engine vs Engine</option>
        <option value="none">Human vs Human</option>
      </select>
    </div>
    
    <div class="engine-strength">
      <label class="small">Skill Level:</label>
      <input type="range" id="engineLevelRange" min="0" max="20" value="10">
      <span id="engineLevelDisplay">10</span>
    </div>
    
    <div>
      <label class="small">Thinking Time (ms):</label>
      <select id="engineTime">
        <option value="500">500 ms</option>
        <option value="1000" selected>1 sec</option>
        <option value="2000">2 sec</option>
        <option value="3000">3 sec</option>
        <option value="5000">5 sec</option>
        <option value="10000">10 sec</option>
      </select>
    </div>
    
    <div>
      <span id="engineThinking" style="display:none;">ðŸ¤” Thinking...</span>
      <span id="engineDepth" class="engine-status">Depth: -</span>
    </div>
    
    <button id="engineOnBtn">Start Stockfish</button>
    <button id="engineOffBtn" style="display:none;">Stop Stockfish</button>
  </div>
</div>

<!-- Online Presence Panel (same as student2.html) -->
<div class="panel multiplayer-panel" style="margin-top:18px;" id="multiplayerPanel">
  <div style="display:flex; gap:8px; align-items:center;">
    <label for="emailInputBottom" class="small">Your username:</label>
    <input id="emailInputBottom" name="username" type="text" placeholder="your username (e.g. student3)" />
    <button id="joinBtnBottom">Join Online</button>
  </div>

  <div style="margin-left:auto; display:flex; gap:8px; align-items:center; margin-top:10px;">
    <div id="multiplayStatus" class="muted">Not connected</div>
    <div id="pairedBubble" class="status-bubble" style="display:none;">Paired</div>
  </div>
</div>

<!-- Promotion Modal -->
<div class="promote-modal" id="promoteModal" role="dialog" aria-modal="true">
  <div style="font-weight:700; text-align:center; margin-bottom:8px;">Choose promotion</div>
  <div class="row">
    <button data-piece="q">Q</button>
    <button data-piece="r">R</button>
    <button data-piece="b">B</button>
    <button data-piece="n">N</button>
  </div>
</div>

<!-- Libraries -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

<!-- Custom Stockfish Engine Module -->
<script>
// Stockfish Engine Manager Module
(function() {
  let stockfishEngine = null;
  let stockfishReady = false;
  let stockfishOnBestMove = null;
  
  // FIXED ISSUE 1: Use relative paths for same-origin compliance
  const STOCKFISH_JS_URL = './js/stockfish/Stockfish-17.1-.js-.wasm-.nnue-main/stockfish-17.1.js';
  const STOCKFISH_NNUE_URL = './js/stockfish/Stockfish-17.1-.js-.wasm-.nnue-main/stockfish-17.1.nnue';

  // Export functions to global scope
  window.StockfishManager = {
    start: function(callback) {
      // FIXED ISSUE 4: Only create if not already running
      if (stockfishEngine) {
        if (!stockfishReady) {
          console.log('[Stockfish] Engine already starting, please wait...');
          return;
        }
        console.log('[Stockfish] Engine already running');
        return;
      }

      stockfishOnBestMove = callback;
      console.log('[Stockfish] Creating worker from:', STOCKFISH_JS_URL);
      stockfishEngine = new Worker(STOCKFISH_JS_URL);

      stockfishEngine.onmessage = (e) => {
        const msg = e.data;
        console.log('[Stockfish]', msg);

        if (msg === 'uciok') {
          // Load NNUE evaluation file
          console.log('[Stockfish] Setting NNUE file:', STOCKFISH_NNUE_URL);
          stockfishEngine.postMessage(`setoption name EvalFile value ${STOCKFISH_NNUE_URL}`);
          stockfishEngine.postMessage('isready');
        }

        if (msg === 'readyok') {
          stockfishReady = true;
          console.log('âœ… Stockfish ready (NNUE loaded)');
        }

        // FIXED ISSUE 2: Correct depth parsing
        if (msg.startsWith('info') && msg.includes(' depth ')) {
          const depthMatch = msg.match(/depth (\d+)/);
          if (depthMatch) {
            const depthElement = document.getElementById('engineDepth');
            if (depthElement) {
              depthElement.textContent = `Depth: ${depthMatch[1]}`;
            }
          }
        }

        // FIXED ISSUE 2: Clean bestmove handling
        if (msg.startsWith('bestmove')) {
          const parts = msg.split(' ');
          if (parts.length >= 2) {
            const move = parts[1];
            if (move && move !== '(none)' && move !== 'none' && move !== 'null') {
              if (stockfishOnBestMove) stockfishOnBestMove(move);
            }
          }
        }
      };

      stockfishEngine.postMessage('uci');
    },

    askMove: function(fen, movetime = 2000) {
      // FIXED ISSUE 3: Use movetime only (valid UCI)
      if (!stockfishEngine || !stockfishReady) {
        console.warn('[Stockfish] Engine not ready');
        return;
      }

      stockfishEngine.postMessage('ucinewgame');
      stockfishEngine.postMessage('position fen ' + fen);
      stockfishEngine.postMessage(`go movetime ${movetime}`);
    },

    setSkillLevel: function(level) {
      if (!stockfishEngine || !stockfishReady) {
        console.warn('[Stockfish] Engine not ready');
        return;
      }
      
      // Stockfish Skill Level (0-20)
      stockfishEngine.postMessage(`setoption name Skill Level value ${level}`);
      
      // Additional settings for weaker play at lower levels
      if (level < 10) {
        stockfishEngine.postMessage('setoption name Skill Level Maximum Error value 100');
        stockfishEngine.postMessage('setoption name Skill Level Probability value 50');
      }
      
      console.log(`[Stockfish] Skill level set to ${level}`);
    },

    stop: function() {
      if (stockfishEngine && stockfishReady) {
        stockfishEngine.postMessage('stop');
      }
    },

    destroy: function() {
      if (!stockfishEngine) return;
      
      try {
        stockfishEngine.terminate();
      } catch (e) {
        console.warn('[Stockfish] Error terminating worker:', e);
      }
      
      stockfishEngine = null;
      stockfishReady = false;
      console.log('[Stockfish] Engine destroyed');
    },

    isReady: function() {
      return stockfishReady;
    },

    isRunning: function() {
      return stockfishEngine !== null;
    }
  };
})();
</script>

<!-- Main Game Script -->
<script>
// GLOBAL GAME INSTANCE - REQUIRED FOR MASTER SPECTATING
window.game = null;

(function(){
  // Config
  const PIECES_BASE = '/IQ4U-Chess-Classroom/assets/pieces/cburnett/';
  
  // DOM
  const boardEl = document.getElementById('board');
  const boardWrapper = document.getElementById('board-wrapper');
  const boardSizeRange = document.getElementById('boardSizeRange');
  const boardSizeLabel = document.getElementById('boardSizeLabel');
  const statusEl = document.getElementById('status');
  const movesList = document.getElementById('movesList');
  const engineLevelRange = document.getElementById('engineLevelRange');
  const engineLevelDisplay = document.getElementById('engineLevelDisplay');
  const engineTimeSelect = document.getElementById('engineTime');
  const engineColorSelect = document.getElementById('engineColor');
  const engineOnBtn = document.getElementById('engineOnBtn');
  const engineOffBtn = document.getElementById('engineOffBtn');
  const engineThinking = document.getElementById('engineThinking');
  const engineDepth = document.getElementById('engineDepth');
  const undoBtn = document.getElementById('undoBtn');
  const flipBtn = document.getElementById('flipBtn');
  const resetBtn = document.getElementById('resetBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const emailInputBottom = document.getElementById('emailInputBottom');
  const joinBtnBottom = document.getElementById('joinBtnBottom');
  const multiplayStatus = document.getElementById('multiplayStatus');
  const pairedBubble = document.getElementById('pairedBubble');

  // State
  let board = null;
  let game = new Chess(); // Local game instance
  window.game = game; // EXPOSED GLOBALLY FOR SPECTATING
  let engineEnabled = false;
  let engineColor = 'black';
  let engineLevel = 10;
  let engineThinkTime = 1000;
  let isThinking = false;
  let lastMoveSquares = [];
  let pendingPromo = null;

  // Promotion Modal
  const promoteModal = document.getElementById('promoteModal');
  function showPromotionDialog(){ promoteModal.style.display='block'; }
  function hidePromotionDialog(){ promoteModal.style.display='none'; }
  promoteModal.addEventListener('click', function(e){
    if(e.target && e.target.dataset && e.target.dataset.piece){
      const p = e.target.dataset.piece;
      if(pendingPromo && pendingPromo.resolve) pendingPromo.resolve(p);
      pendingPromo = null;
      hidePromotionDialog();
    }
  });

  // FEN Emitter (for master spectating)
  window.emitFenToMaster = function() {
    if (!window.game || !window.firebaseMultiplayer) return;
    try {
      const fen = window.game.fen();
      if (window.firebaseMultiplayer.emitFen) {
        window.firebaseMultiplayer.emitFen({ fen: fen });
      }
    } catch(e) {
      console.warn('FEN emit failed:', e);
    }
  };

  // Helpers
  function pieceTheme(piece){ 
    return PIECES_BASE + piece + '.svg'; 
  }
  
  function createBoard(){
    if(board && typeof board.destroy==='function'){ 
      try{ board.destroy(); }catch(e){} 
    }
    board = Chessboard('board', {
      draggable: true,
      position: game.fen(),
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: pieceTheme,
      orientation: 'white'
    });
    updateStatus();
    refreshNotation();
  }
  
  function onSnapEnd(){ 
    if(board) board.position(game.fen());
  }

  // Update game status
  function updateStatus() {
    let status = '';
    
    if (game.in_checkmate()) {
      status = 'Game over, ' + (game.turn() === 'w' ? 'black' : 'white') + ' wins by checkmate!';
    } else if (game.in_draw()) {
      status = 'Game over, drawn position';
    } else if (game.in_stalemate()) {
      status = 'Game over, stalemate';
    } else if (game.in_threefold_repetition()) {
      status = 'Game over, threefold repetition';
    } else if (game.insufficient_material()) {
      status = 'Game over, insufficient material';
    } else {
      status = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
      if (game.in_check()) {
        status += ', ' + (game.turn() === 'w' ? 'white' : 'black') + ' is in check';
      }
    }
    
    statusEl.innerHTML = status;
  }

  // Refresh move notation
  function refreshNotation() {
    try {
      const hist = game.history();
      if (!hist || hist.length === 0) {
        movesList.innerHTML = 'No moves yet.';
        return;
      }
      
      movesList.innerHTML = '';
      for (let i = 0; i < hist.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        const whiteMove = hist[i] || '';
        const blackMove = hist[i + 1] || '';
        
        const div = document.createElement('div');
        div.className = 'move';
        div.innerHTML = `<strong>${moveNum}.</strong>&nbsp;${whiteMove}`;
        if (blackMove) {
          div.innerHTML += `&nbsp;${blackMove}`;
        }
        movesList.appendChild(div);
      }
      
      // Scroll to latest move
      movesList.scrollTop = movesList.scrollHeight;
    } catch (e) {
      console.warn('Notation refresh error:', e);
    }
  }

  /* ---- LAST MOVE HIGHLIGHT ---- */
  function setPersistentLastMove(src, tgt){
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    ['square-'+src,'square-'+tgt].forEach(cls=>{
      const el = document.querySelector('.'+cls);
      if(el) el.classList.add('cb-last-move');
      lastMoveSquares.push(cls.replace('square-',''));
    });
  }

  // Drag start handler
  function onDragStart(source, piece, position, orientation) {
    // Don't allow dragging if game is over
    if (game.game_over()) {
      return false;
    }
    
    // Don't allow dragging if engine is thinking
    if (isThinking) {
      return false;
    }
    
    // Don't allow dragging if it's engine's turn
    if (engineEnabled && !isHumanTurn()) {
      return false;
    }
    
    // Only allow dragging own pieces
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
    
    return true;
  }

  // Check if it's human's turn
  function isHumanTurn() {
    if (!engineEnabled) return true;
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    
    if (engineColor === 'both') return false;
    if (engineColor === 'none') return true;
    if (engineColor === 'white' && currentPlayer === 'white') return false;
    if (engineColor === 'black' && currentPlayer === 'black') return false;
    
    return true;
  }

  // Drop handler
  async function onDrop(source, target) {
    // Try the move
    const moveObj = { from: source, to: target };
    
    // Check for pawn promotion
    const legal = game.moves({verbose:true}) || [];
    const candidatePromo = legal.find(m => m.from === source && m.to === target && m.promotion);
    let chosenPromo = null;
    
    if (candidatePromo) {
      chosenPromo = await new Promise(resolve => { 
        pendingPromo = { from:source, to:target, resolve }; 
        showPromotionDialog(); 
      });
      pendingPromo = null;
      if (!chosenPromo) chosenPromo = 'q';
      moveObj.promotion = chosenPromo;
    }

    const mv = game.move(moveObj);
    if (mv === null) {
      return 'snapback';
    }

    // Update board and status
    board.position(game.fen());
    setPersistentLastMove(mv.from, mv.to);
    updateStatus();
    refreshNotation();
    
    // Update master board
    window.emitFenToMaster();
    
    // If engine is enabled and it's engine's turn, ask engine to move
    if (engineEnabled && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 100);
    }
    
    return 'snap';
  }

  // Process engine's best move
  function processBestMove(moveStr) {
    if (!moveStr || moveStr === '(none)' || moveStr === 'none' || moveStr === 'null') {
      console.log('[Stockfish] No valid move found');
      isThinking = false;
      engineThinking.style.display = 'none';
      return;
    }
    
    console.log('[Stockfish] Processing move:', moveStr);
    
    // Convert UCI to chess.js format
    const from = moveStr.substring(0, 2);
    const to = moveStr.substring(2, 4);
    const promotion = moveStr.length > 4 ? moveStr.substring(4, 5) : null;
    
    // Make the move
    let move = null;
    if (promotion) {
      move = game.move({
        from: from,
        to: to,
        promotion: promotion.toLowerCase()
      });
    } else {
      move = game.move({
        from: from,
        to: to
      });
    }
    
    if (move) {
      // Update board
      board.position(game.fen());
      setPersistentLastMove(move.from, move.to);
      updateStatus();
      refreshNotation();
      isThinking = false;
      engineThinking.style.display = 'none';
      
      // Update master board
      window.emitFenToMaster();
      
      // If engine vs engine and game not over, trigger next move
      if (engineColor === 'both' && !game.game_over()) {
        setTimeout(askEngineToMove, 1000);
      }
    } else {
      console.error('Stockfish made illegal move:', moveStr);
      isThinking = false;
      engineThinking.style.display = 'none';
      
      // Try to make a different move
      setTimeout(() => {
        if (engineEnabled && !game.game_over() && !isHumanTurn()) {
          askEngineToMove();
        }
      }, 500);
    }
  }

  // Ask engine to make a move
  function askEngineToMove() {
    if (game.game_over() || isThinking || !engineEnabled) {
      console.log('[Game] Not asking engine - game over, thinking, or engine disabled');
      return;
    }
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    if (engineColor === 'both' || 
        (engineColor === 'white' && currentPlayer === 'white') ||
        (engineColor === 'black' && currentPlayer === 'black')) {
      
      if (!window.StockfishManager.isReady()) {
        console.warn('[Stockfish] Engine not ready yet');
        setTimeout(askEngineToMove, 500);
        return;
      }
      
      isThinking = true;
      engineThinking.style.display = 'inline';
      engineDepth.textContent = 'Depth: -';
      
      // Ask Stockfish for move (using movetime only - FIXED ISSUE 3)
      window.StockfishManager.askMove(game.fen(), engineThinkTime);
      console.log(`[Stockfish] Asking for move with ${engineThinkTime}ms thinking time`);
    }
  }

  // Start engine
  function startEngine() {
    console.log('[Engine] Starting Stockfish...');
    
    // FIXED ISSUE 4: Don't destroy/recreate unnecessarily
    if (!window.StockfishManager.isRunning()) {
      window.StockfishManager.start(processBestMove);
    }
    
    engineEnabled = true;
    engineOnBtn.style.display = 'none';
    engineOffBtn.style.display = 'inline-block';
    
    // Update multiplayer status
    if (multiplayStatus) {
      multiplayStatus.textContent = 'Playing vs Stockfish';
    }
    
    // Set skill level after a short delay to ensure engine is ready
    setTimeout(() => {
      if (window.StockfishManager.isReady()) {
        window.StockfishManager.setSkillLevel(engineLevel);
      }
    }, 800);
    
    // If engine should move first
    if (!game.game_over() && !isHumanTurn()) {
      console.log('[Engine] Engine moves first, waiting for ready state...');
      
      const checkReady = setInterval(() => {
        if (window.StockfishManager.isReady()) {
          clearInterval(checkReady);
          setTimeout(askEngineToMove, 300);
        }
      }, 200);
      
      // Timeout after 5 seconds
      setTimeout(() => {
        clearInterval(checkReady);
      }, 5000);
    }
  }

  // Stop engine
  function stopEngine() {
    console.log('[Engine] Stopping Stockfish...');
    
    engineEnabled = false;
    isThinking = false;
    engineThinking.style.display = 'none';
    engineDepth.textContent = 'Depth: -';
    
    // Only destroy if engine is running
    if (window.StockfishManager.isRunning()) {
      window.StockfishManager.destroy();
    }
    
    engineOnBtn.style.display = 'inline-block';
    engineOffBtn.style.display = 'none';
    
    // Update multiplayer status
    if (multiplayStatus && multiplayStatus.textContent === 'Playing vs Stockfish') {
      multiplayStatus.textContent = 'Stockfish stopped';
    }
  }

  // Reset game
  function resetGame() {
    game = new Chess();
    window.game = game; // Update global reference
    board.position('start');
    updateStatus();
    refreshNotation();
    
    // Clear last move highlights
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    
    // Reset engine thinking
    isThinking = false;
    engineThinking.style.display = 'none';
    engineDepth.textContent = 'Depth: -';
    
    if (engineEnabled && !game.game_over() && !isHumanTurn()) {
      setTimeout(() => {
        if (window.StockfishManager.isReady()) {
          askEngineToMove();
        }
      }, 500);
    }
    
    // Update master board
    window.emitFenToMaster();
  }

  // Undo move
  function undoMove() {
    if (!game || game.history().length === 0) {
      return;
    }
    
    // Undo last move
    game.undo();
    
    // If engine vs human and we just undid engine's move, also undo human's move
    if (engineEnabled && engineColor !== 'both' && game.history().length > 0) {
      game.undo();
    }
    
    board.position(game.fen());
    updateStatus();
    refreshNotation();
    
    // Clear last move highlights
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    
    // Reset engine thinking
    isThinking = false;
    engineThinking.style.display = 'none';
    engineDepth.textContent = 'Depth: -';
    
    // Update master board
    window.emitFenToMaster();
  }

  // Board size controls
  function setBoardSize(px){ 
    if(!px || isNaN(px)) return; 
    const clamped = Math.max(360, Math.min(1400, Number(px))); 
    boardWrapper.style.maxWidth = clamped + 'px'; 
    boardSizeRange.value = clamped; 
    boardSizeLabel.textContent = clamped + 'px'; 
    try{ 
      if(board && typeof board.resize === 'function'){ 
        board.resize(); 
      } 
    }catch(e){} 
  }

  // Event listeners
  $(document).ready(function() {
    // Initialize board
    createBoard();
    
    // Set initial board size
    const initial = parseInt(getComputedStyle(boardWrapper).maxWidth,10) || boardWrapper.clientWidth || 760;
    setBoardSize(initial);
    
    // Engine controls
    engineOnBtn.addEventListener('click', startEngine);
    engineOffBtn.addEventListener('click', stopEngine);

    // Game controls
    resetBtn.addEventListener('click', resetGame);
    undoBtn.addEventListener('click', undoMove);
    flipBtn.addEventListener('click', () => { 
      if(board) board.flip(); 
    });
    
    logoutBtn.onclick = () => { 
      localStorage.clear(); 
      if (window.firebaseMultiplayer && window.firebaseMultiplayer.goOffline) {
        window.firebaseMultiplayer.goOffline();
      }
      location.href = 'index.html'; 
    };
    
    // Engine settings
    engineColorSelect.addEventListener('change', () => {
      engineColor = engineColorSelect.value;
      
      if (engineEnabled && !game.game_over() && !isHumanTurn()) {
        setTimeout(() => {
          if (window.StockfishManager.isReady()) {
            askEngineToMove();
          }
        }, 300);
      }
    });

    engineLevelRange.addEventListener('input', () => {
      engineLevel = Number(engineLevelRange.value);
      engineLevelDisplay.textContent = engineLevel;
      
      // Update Stockfish skill level if engine is running
      if (engineEnabled && window.StockfishManager.isReady()) {
        window.StockfishManager.setSkillLevel(engineLevel);
      }
    });

    engineTimeSelect.addEventListener('change', () => {
      engineThinkTime = Number(engineTimeSelect.value);
    });

    // Initialize engine level display
    engineLevelDisplay.textContent = engineLevelRange.value;
    
    // Board size range
    boardSizeRange.addEventListener('input', (e) => setBoardSize(e.target.value));
    
    // Handle moves from master (same as student2.html)
    window.onBoardMove = function(payload){
      try{
        if(!payload) return;
        if(typeof payload === 'string'){
          if(game.load) game.load(payload);
          if(board) board.position(game.fen());
          updateStatus();
          refreshNotation();
          return;
        }
        if(payload.move && payload.move.from && payload.move.to){
          const mvObj = { from: payload.move.from, to: payload.move.to };
          if(payload.move.promotion) mvObj.promotion = payload.move.promotion;
          const applied = game.move(mvObj);
          if(applied === null){
            if(payload.fen && game.load){
              game.load(payload.fen);
            }
          } else {
            setPersistentLastMove(payload.move.from, payload.move.to);
          }
        } else if(payload.fen){
          if(game.load) game.load(payload.fen);
        }
        if(board) board.position(game.fen());
        updateStatus();
        refreshNotation();
      }catch(e){ console.warn('onBoardMove failed', e); }
    };
    
    // Auto-join if username exists
    try{ 
      const uname = localStorage.getItem('username') || localStorage.getItem('email') || ''; 
      if(uname && emailInputBottom) emailInputBottom.value = uname; 
    }catch(e){}
  });

})();
</script>

<!-- FIREBASE - IDENTICAL TO student2.html -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<script>
(function(){
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
    authDomain: "iq4u-chess-classroom.firebaseapp.com",
    databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "iq4u-chess-classroom",
    storageBucket: "iq4uchess-classroom.firebasestorage.app",
    messagingSenderId: "833620718306",
    appId: "1:833620718306:web:b599bb6936fe0da4bb"
  };
  try{ firebase.initializeApp(FIREBASE_CONFIG); }catch(e){}

  (function(){
    const db = firebase.database();
    const onlineRef = db.ref('online');

    let myId = sessionStorage.getItem('iq4u_clientId') ||
      ('c_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', myId);

    let myEmail = '';
    let currentGameId = null;
    let presenceTimer = null;
    let isSpectated = false;

    function goOnline(email){
      myEmail = email || ('anon-'+myId);
      const node = onlineRef.child(myId);
      node.set({ email: myEmail, role: 'student', ts: firebase.database.ServerValue.TIMESTAMP });
      if(presenceTimer) clearInterval(presenceTimer);
      presenceTimer = setInterval(
        ()=>node.update({ ts: firebase.database.ServerValue.TIMESTAMP }),
        25000
      );
      if (multiplayStatus) {
        multiplayStatus.textContent = 'Connected as ' + myEmail;
      }
    }

    function goOffline(){
      if(presenceTimer) clearInterval(presenceTimer);
      onlineRef.child(myId).remove().catch(()=>{});
      if (multiplayStatus) {
        multiplayStatus.textContent = 'Not connected';
      }
      isSpectated = false;
      if (pairedBubble) pairedBubble.style.display = 'none';
    }

    joinBtnBottom.addEventListener('click', ()=>{
      const email = (emailInputBottom.value||'').trim();
      if(!email) return alert('Enter username');
      localStorage.setItem('username', email);
      goOnline(email);
    });

    /* =========================================================
       SPECTATE INVITE HANDLER (IDENTICAL TO student2.html)
       ========================================================= */
    db.ref('spectateInvites/'+myId).on('child_added', snap=>{
      const invite = snap.val();
      if(!invite) return;

      const fromEmail = invite.fromEmail || invite.fromId || 'Master';
      const accept = confirm(fromEmail + ' wants to spectate your board. Accept?');

      // Get current FEN
      const currentFen = window.game ? window.game.fen() : 
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

      // Send response
      if(invite.fromId){
        const respPath = `spectateResponses/${invite.fromId}/${myId}`;
        
        db.ref(respPath).set({
          studentId: myId,
          studentEmail: myEmail || null,
          accepted: accept,
          boardId: invite.boardId || null,
          fen: accept ? currentFen : null,
          ts: firebase.database.ServerValue.TIMESTAMP
        }).catch(err=>{
          console.warn('[STUDENT3] spectate response failed', err);
        });
      }

      // If accepted, set flag
      if (accept) {
        isSpectated = true;
        if (multiplayStatus) {
          multiplayStatus.textContent = 'Master is spectating';
        }
      }

      snap.ref.remove().catch(()=>{});
    });

    /* =========================================================
       FIREBASE MULTIPLAYER OBJECT (IDENTICAL TO student2.html)
       ========================================================= */
    window.firebaseMultiplayer = {
      emitMove: function(arg){
        if(!currentGameId) return;
        db.ref('moves/'+currentGameId).push({
          payload: arg,
          by: myId,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      },
      emitFen: function(arg){
        // Write to moves/<myId> path
        db.ref('moves/'+myId).push({
          payload: arg,
          by: myId,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      },
      getMyId: ()=>myId,
      getMyEmail: ()=>myEmail,
      goOffline: goOffline
    };

    // Auto-join if username exists
    setTimeout(() => {
      const saved = (emailInputBottom && emailInputBottom.value) ? emailInputBottom.value.trim() : 
                   (localStorage.getItem('username') || localStorage.getItem('email') || '');
      if(saved){
        goOnline(saved);
      }
    }, 500);

  })();
})();
</script>

</body>
</html>
