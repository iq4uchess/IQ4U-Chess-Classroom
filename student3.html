<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U â€” Student Puzzle (student3)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    html,body{ overscroll-behavior-y: contain; height:100%; }
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; -webkit-font-smoothing:antialiased; display:flex; flex-direction:column; align-items:center; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); margin:0 auto; max-width:980px; width:100%; box-sizing:border-box; }
    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; text-align:center; }
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; width:100%; }
    #board-wrapper{ width:100%; max-width:760px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; margin:0 auto; position:relative; padding:16px; }
    #board-wrapper, #board { touch-action: none; -webkit-user-select: none; -webkit-touch-callout: none; user-select: none; -ms-touch-action: none; }
    #board{ width:100%; aspect-ratio: 1 / 1; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; max-height:88vh; min-width:520px; min-height:520px; box-shadow: 0 6px 18px rgba(2,6,23,0.04); border-radius:8px; padding:6px; }
    .resizer{ display:flex; gap:10px; align-items:center; background:transparent; justify-content:center; width:100%; }
    .resizer .range{ width:320px; }
    .resizer small{ color:#444; display:block; min-width:48px; text-align:center; font-size:13px; }
    #engineLog{ font-family:monospace; font-size:12px; overflow:auto; height:140px; background:#0b1220; color:#e6eefc; padding:8px; border-radius:8px; }
    .engine-controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 14px; }
    h1 { color: #0f172a; margin-bottom: 10px; text-align: center; }
    #engineOnBtn { background: #10b981; }
    #engineOffBtn { background: #ef4444; display: none; }
    .log-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    @media (max-width:900px){
      #board{ height:80vw; width:100%; aspect-ratio: auto; max-height:620px; min-width:300px; min-height:300px; }
      .resizer .range{ width:200px; }
    }
    .cb-last-move { outline: 3px solid rgba(255,200,0,0.95); outline-offset: -3px; box-shadow: inset 0 0 0 2px rgba(255,200,0,0.25); }
  </style>
</head>

<body>

<h1>Student3 - Play vs Stockfish</h1>

<div class="panel">
  <div class="controls">
    <button id="undoBtn">Undo</button>
    <button id="flipBtn">Flip</button>
    <button id="resetBtn" style="background:#8b0f0f;">Reset Game</button>
  </div>

  <div class="resizer">
    <input id="boardSizeRange" name="board-size" class="range" type="range" min="360" max="1400" step="10" value="760" aria-label="Board size">
    <small id="boardSizeLabel">760px</small>
  </div>

  <div id="board-wrapper" style="margin-top:12px;">
    <div id="board" aria-label="Chessboard container"></div>
  </div>

  <div id="status" class="info">White to move</div>
</div>

<!-- Engine Controls Panel -->
<div class="panel" style="margin-top:18px;">
  <div class="engine-controls">
    <div>
      <label class="small">Engine Side:</label>
      <select id="engineColor">
        <option value="white">Engine as White</option>
        <option value="black" selected>Engine as Black</option>
        <option value="both">Engine vs Engine</option>
        <option value="none">Human vs Human</option>
      </select>
    </div>
    
    <div>
      <label class="small">Skill Level:</label>
      <select id="engineLevel">
        <option value="1">1 (Easiest)</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5 (Default)</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="10">10</option>
        <option value="15">15</option>
        <option value="20">20 (Hardest)</option>
      </select>
    </div>
    
    <button id="engineOnBtn">Start Engine</button>
    <button id="engineOffBtn" style="display:none;">Stop Engine</button>
  </div>
</div>

<!-- Engine Log Panel -->
<div class="panel" style="margin-top:18px;">
  <div class="log-header">
    <strong>Engine Debug Log</strong>
    <button id="engineClearBtn">Clear Log</button>
  </div>
  <div id="engineLog"></div>
</div>

<!-- Same libraries as student2.html -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

<!-- Stockfish Worker - Inline Blob to avoid CORS issues -->
<script>
// Create Stockfish worker as a blob
const stockfishCode = `
  // Simple Stockfish-like engine (minimal implementation)
  self.onmessage = function(e) {
    const cmd = e.data;
    
    if (cmd === 'uci') {
      self.postMessage('id name SimpleChessEngine 1.0');
      self.postMessage('id author IQ4U');
      self.postMessage('uciok');
    } else if (cmd === 'isready') {
      self.postMessage('readyok');
    } else if (cmd.startsWith('position')) {
      // Store position
      self.position = cmd;
    } else if (cmd.startsWith('setoption')) {
      // Ignore options for now
    } else if (cmd.startsWith('go')) {
      // Generate a simple move
      setTimeout(() => {
        // Simple move generator - just pick a random legal move
        // In a real implementation, you would parse the position
        const moves = ['e2e4', 'e7e5', 'g1f3', 'b8c6', 'f1b5', 'a7a6'];
        const randomMove = moves[Math.floor(Math.random() * moves.length)];
        self.postMessage('bestmove ' + randomMove);
      }, 500);
    }
  };
`;

// Create blob URL for Stockfish worker
const stockfishBlob = new Blob([stockfishCode], { type: 'application/javascript' });
const STOCKFISH_BLOB_URL = URL.createObjectURL(stockfishBlob);
</script>

<script>
// GLOBAL GAME INSTANCE - REQUIRED FOR MASTER SPECTATING
window.game = null;

(function(){
  // Config
  const PIECES_BASE = '/IQ4U-Chess-Classroom/assets/pieces/cburnett/';
  
  // DOM
  const boardEl = document.getElementById('board');
  const boardWrapper = document.getElementById('board-wrapper');
  const boardSizeRange = document.getElementById('boardSizeRange');
  const boardSizeLabel = document.getElementById('boardSizeLabel');
  const statusEl = document.getElementById('status');
  const engineLogEl = document.getElementById('engineLog');
  const engineClearBtn = document.getElementById('engineClearBtn');
  const engineLevelSelect = document.getElementById('engineLevel');
  const engineColorSelect = document.getElementById('engineColor');
  const engineOnBtn = document.getElementById('engineOnBtn');
  const engineOffBtn = document.getElementById('engineOffBtn');
  const undoBtn = document.getElementById('undoBtn');
  const flipBtn = document.getElementById('flipBtn');
  const resetBtn = document.getElementById('resetBtn');

  // State
  let board = null;
  let game = new Chess(); // Local game instance
  window.game = game; // EXPOSED GLOBALLY FOR SPECTATING
  let engine = null;
  let engineEnabled = false;
  let engineColor = 'black';
  let engineLevel = 5;
  let isThinking = false;
  let lastMoveSquares = [];

  // FEN Emitter (for master spectating)
  window.emitFenToMaster = function() {
    if (!window.game || !window.firebaseMultiplayer) return;
    try {
      const fen = window.game.fen();
      if (window.firebaseMultiplayer.emitFen) {
        window.firebaseMultiplayer.emitFen({ fen: fen });
      }
    } catch(e) {
      console.warn('FEN emit failed:', e);
    }
  };

  // Helpers
  function pieceTheme(piece){ 
    return PIECES_BASE + piece + '.svg'; 
  }
  
  function createBoard(){
    if(board && typeof board.destroy==='function'){ 
      try{ board.destroy(); }catch(e){} 
    }
    board = Chessboard('board', {
      draggable: true,
      position: game.fen(),
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: pieceTheme,
      orientation: 'white'
    });
  }
  
  function onSnapEnd(){ 
    if(board) board.position(game.fen());
  }

  // Update game status
  function updateStatus() {
    let status = '';
    
    if (game.in_checkmate()) {
      status = 'Game over, ' + (game.turn() === 'w' ? 'black' : 'white') + ' wins by checkmate!';
    } else if (game.in_draw()) {
      status = 'Game over, drawn position';
    } else if (game.in_stalemate()) {
      status = 'Game over, stalemate';
    } else if (game.in_threefold_repetition()) {
      status = 'Game over, threefold repetition';
    } else if (game.insufficient_material()) {
      status = 'Game over, insufficient material';
    } else {
      status = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
      if (game.in_check()) {
        status += ', ' + (game.turn() === 'w' ? 'white' : 'black') + ' is in check';
      }
    }
    
    statusEl.innerHTML = status;
  }

  /* ---- LAST MOVE HIGHLIGHT ---- */
  function setPersistentLastMove(src, tgt){
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    ['square-'+src,'square-'+tgt].forEach(cls=>{
      const el = document.querySelector('.'+cls);
      if(el) el.classList.add('cb-last-move');
      lastMoveSquares.push(cls.replace('square-',''));
    });
  }

  // Log helper
  function panelLog(msg, type='log'){
    const line = document.createElement('div');
    line.textContent = `[${new Date().toLocaleTimeString().slice(0,8)}] ${msg}`;
    if(type==='warn') line.style.color = '#ffd166';
    else if(type==='error') line.style.color = '#ff6b6b';
    else if(type==='engine') line.style.color = '#4ade80';
    else if(type==='move') line.style.color = '#60a5fa';
    engineLogEl.appendChild(line);
    engineLogEl.scrollTop = engineLogEl.scrollHeight;
    console.log(msg);
  }

  // Drag start handler
  function onDragStart(source, piece, position, orientation) {
    // Don't allow dragging if game is over
    if (game.game_over()) {
      return false;
    }
    
    // Don't allow dragging if engine is thinking
    if (isThinking) {
      return false;
    }
    
    // Don't allow dragging if it's engine's turn
    if (engineEnabled && !isHumanTurn()) {
      return false;
    }
    
    // Only allow dragging own pieces
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
    
    return true;
  }

  // Check if it's human's turn
  function isHumanTurn() {
    if (!engineEnabled) return true;
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    
    if (engineColor === 'both') return false;
    if (engineColor === 'none') return true;
    if (engineColor === 'white' && currentPlayer === 'white') return false;
    if (engineColor === 'black' && currentPlayer === 'black') return false;
    
    return true;
  }

  // Drop handler
  function onDrop(source, target) {
    // Try the move
    const moveObj = { from: source, to: target };
    
    // Check for pawn promotion
    const piece = game.get(source);
    if (piece && piece.type === 'p') {
      if ((piece.color === 'w' && target[1] === '8') || 
          (piece.color === 'b' && target[1] === '1')) {
        moveObj.promotion = 'q'; // Auto-promote to queen
      }
    }

    const mv = game.move(moveObj);
    if (mv === null) {
      panelLog('Illegal move: ' + source + '-' + target, 'warn');
      return 'snapback';
    }

    // Update board and status
    board.position(game.fen());
    setPersistentLastMove(mv.from, mv.to);
    updateStatus();
    
    // Log the move
    panelLog(`Human moved: ${mv.san}`, 'move');
    
    // Update master board
    window.emitFenToMaster();
    
    // If engine is enabled and it's engine's turn, ask engine to move
    if (engineEnabled && engine && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 100);
    }
    
    return 'snap';
  }

  // Engine message handler
  function hookEngine(worker) {
    worker.onmessage = function(e) {
      const line = e.data;
      
      if (line.startsWith('bestmove')) {
        panelLog('[engine] ' + line, 'engine');
        processBestMove(line);
      } else if (line === 'readyok') {
        panelLog('[engine] Ready', 'engine');
      } else if (line.startsWith('uciok')) {
        panelLog('[engine] UCI ready', 'engine');
      }
    };
    
    worker.onerror = function(e) {
      panelLog('Engine worker error: ' + e.message, 'error');
    };
  }

  // Process engine's best move
  function processBestMove(line) {
    if (!line.startsWith('bestmove')) return;
    
    const parts = line.split(' ');
    if (parts.length < 2) return;
    
    const moveStr = parts[1];
    if (moveStr === '(none)') return;
    
    // Convert UCI to chess.js format
    const from = moveStr.substring(0, 2);
    const to = moveStr.substring(2, 4);
    const promotion = moveStr.length > 4 ? moveStr.substring(4, 5) : null;
    
    // Make the move
    let move = null;
    if (promotion) {
      move = game.move({
        from: from,
        to: to,
        promotion: promotion.toLowerCase()
      });
    } else {
      move = game.move({
        from: from,
        to: to
      });
    }
    
    if (move) {
      // Update board
      board.position(game.fen());
      setPersistentLastMove(move.from, move.to);
      updateStatus();
      isThinking = false;
      
      // Log the move
      panelLog(`Engine moved: ${move.san}`, 'engine');
      
      // Update master board
      window.emitFenToMaster();
      
      // If engine vs engine and game not over, trigger next move
      if (engineColor === 'both' && !game.game_over()) {
        setTimeout(askEngineToMove, 1000);
      }
    } else {
      panelLog('Engine made illegal move: ' + moveStr, 'error');
      isThinking = false;
    }
  }

  // Ask engine to make a move
  function askEngineToMove() {
    if (!engine || game.game_over() || isThinking) return;
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    if (engineColor === 'both' || 
        (engineColor === 'white' && currentPlayer === 'white') ||
        (engineColor === 'black' && currentPlayer === 'black')) {
      
      isThinking = true;
      panelLog(`[engine] Thinking as ${currentPlayer}...`, 'engine');
      
      // Send position to engine
      engine.postMessage('position fen ' + game.fen());
      
      // Set thinking time based on skill level
      const thinkTime = Math.max(500, engineLevel * 200); // 500ms to 4000ms
      
      // Ask for move
      engine.postMessage('go movetime ' + thinkTime);
    }
  }

  // Start engine
  function startEngine() {
    panelLog('Starting Chess Engine...');
    
    if (engine) {
      try { engine.terminate(); } catch(e) {}
      engine = null;
    }
    
    // Create Web Worker with our blob URL
    try {
      engine = new Worker(STOCKFISH_BLOB_URL);
      hookEngine(engine);
      
      // Initialize
      engine.postMessage('uci');
      engine.postMessage('isready');
      
      engineEnabled = true;
      engineOnBtn.style.display = 'none';
      engineOffBtn.style.display = 'inline-block';
      
      panelLog('Engine started. Skill level: ' + engineLevel);
      panelLog('Note: Using simple chess engine for demonstration');
      
      // If engine should move first
      if (!game.game_over() && !isHumanTurn()) {
        setTimeout(askEngineToMove, 500);
      }
    } catch (error) {
      panelLog('Failed to start engine: ' + error.message, 'error');
      panelLog('Creating fallback simple engine...', 'warn');
      
      // Create a simple fallback engine
      engine = {
        postMessage: function(cmd) {
          if (cmd === 'uci') {
            setTimeout(() => {
              if (this.onmessage) this.onmessage({data: 'uciok'});
            }, 50);
          } else if (cmd === 'isready') {
            setTimeout(() => {
              if (this.onmessage) this.onmessage({data: 'readyok'});
            }, 50);
          } else if (cmd.startsWith('position fen')) {
            this.position = game.fen();
          } else if (cmd.startsWith('go')) {
            setTimeout(() => {
              // Generate a simple legal move
              const moves = game.moves();
              if (moves.length > 0) {
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                if (this.onmessage) this.onmessage({data: 'bestmove ' + randomMove});
              } else {
                if (this.onmessage) this.onmessage({data: 'bestmove (none)'});
              }
            }, 800);
          }
        },
        terminate: function() {
          engine = null;
        }
      };
      
      hookEngine(engine);
      engineEnabled = true;
      engineOnBtn.style.display = 'none';
      engineOffBtn.style.display = 'inline-block';
      panelLog('Fallback engine started');
      
      if (!game.game_over() && !isHumanTurn()) {
        setTimeout(askEngineToMove, 500);
      }
    }
  }

  // Stop engine
  function stopEngine() {
    engineEnabled = false;
    isThinking = false;
    
    if (engine && engine.terminate) {
      try { 
        engine.terminate(); 
        panelLog('Engine stopped');
      } catch(e) {
        panelLog('Error stopping engine: ' + e.message, 'error');
      }
      engine = null;
    }
    
    engineOnBtn.style.display = 'inline-block';
    engineOffBtn.style.display = 'none';
  }

  // Reset game
  function resetGame() {
    game = new Chess();
    window.game = game; // Update global reference
    board.position('start');
    updateStatus();
    panelLog('Game reset to starting position');
    
    // Clear last move highlights
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    
    if (engineEnabled && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 500);
    }
    
    // Update master board
    window.emitFenToMaster();
  }

  // Undo move
  function undoMove() {
    if (!game || game.history().length === 0) {
      panelLog('No moves to undo', 'warn');
      return;
    }
    
    // Undo last move
    game.undo();
    
    // If engine vs human and we just undid engine's move, also undo human's move
    if (engineEnabled && engineColor !== 'both' && game.history().length > 0) {
      game.undo();
    }
    
    board.position(game.fen());
    updateStatus();
    panelLog('Undid last move');
    
    // Clear last move highlights
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    
    // Update master board
    window.emitFenToMaster();
  }

  // Board size controls
  function setBoardSize(px){ 
    if(!px || isNaN(px)) return; 
    const clamped = Math.max(360, Math.min(1400, Number(px))); 
    boardWrapper.style.maxWidth = clamped + 'px'; 
    boardSizeRange.value = clamped; 
    boardSizeLabel.textContent = clamped + 'px'; 
    try{ 
      if(board && typeof board.resize === 'function'){ 
        board.resize(); 
      } 
    }catch(e){} 
  }

  // Event listeners
  $(document).ready(function() {
    // Initialize board
    createBoard();
    updateStatus();
    panelLog('Chess board initialized. Click "Start Engine" to play vs Chess Engine.');
    
    // Set initial board size
    const initial = parseInt(getComputedStyle(boardWrapper).maxWidth,10) || boardWrapper.clientWidth || 760;
    setBoardSize(initial);
    
    // Engine controls
    engineOnBtn.addEventListener('click', startEngine);
    engineOffBtn.addEventListener('click', stopEngine);
    
    engineClearBtn.addEventListener('click', () => {
      engineLogEl.innerHTML = '';
      panelLog('Log cleared');
    });

    // Game controls
    resetBtn.addEventListener('click', resetGame);
    undoBtn.addEventListener('click', undoMove);
    flipBtn.addEventListener('click', () => { 
      if(board) board.flip(); 
    });
    
    // Engine settings
    engineColorSelect.addEventListener('change', () => {
      engineColor = engineColorSelect.value;
      panelLog(`Engine side: ${engineColor}`);
      
      if (engineEnabled && !game.game_over() && !isHumanTurn()) {
        setTimeout(askEngineToMove, 300);
      }
    });

    engineLevelSelect.addEventListener('change', () => {
      engineLevel = Number(engineLevelSelect.value);
      if (engineEnabled) {
        panelLog(`Engine skill level set to: ${engineLevel}`);
      }
    });

    // Board size range
    boardSizeRange.addEventListener('input', (e) => setBoardSize(e.target.value));
    
    // Handle moves from master (same as student2.html)
    window.onBoardMove = function(payload){
      try{
        if(!payload) return;
        if(typeof payload === 'string'){
          if(game.load) game.load(payload);
          if(board) board.position(game.fen());
          updateStatus();
          return;
        }
        if(payload.move && payload.move.from && payload.move.to){
          const mvObj = { from: payload.move.from, to: payload.move.to };
          if(payload.move.promotion) mvObj.promotion = payload.move.promotion;
          const applied = game.move(mvObj);
          if(applied === null){
            if(payload.fen && game.load){
              game.load(payload.fen);
            }
          } else {
            setPersistentLastMove(payload.move.from, payload.move.to);
          }
        } else if(payload.fen){
          if(game.load) game.load(payload.fen);
        }
        if(board) board.position(game.fen());
        updateStatus();
      }catch(e){ console.warn('onBoardMove failed', e); }
    };
  });

})();
</script>

<!-- FIREBASE - IDENTICAL TO student2.html -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<script>
(function(){
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
    authDomain: "iq4u-chess-classroom.firebaseapp.com",
    databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "iq4u-chess-classroom",
    storageBucket: "iq4uchess-classroom.firebasedestorage.app",
    messagingSenderId: "833620718306",
    appId: "1:833620718306:web:b599bb6936fe0da4bb"
  };
  try{ firebase.initializeApp(FIREBASE_CONFIG); }catch(e){}

  (function(){
    const db = firebase.database();
    const onlineRef = db.ref('online');

    let myId = sessionStorage.getItem('iq4u_clientId') ||
      ('c_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', myId);

    let myEmail = '';
    let presenceTimer = null;

    function goOnline(email){
      myEmail = email || ('anon-'+myId);
      const node = onlineRef.child(myId);
      node.set({ email: myEmail, role: 'student', ts: firebase.database.ServerValue.TIMESTAMP });
      if(presenceTimer) clearInterval(presenceTimer);
      presenceTimer = setInterval(
        ()=>node.update({ ts: firebase.database.ServerValue.TIMESTAMP }),
        25000
      );
    }

    function goOffline(){
      if(presenceTimer) clearInterval(presenceTimer);
      onlineRef.child(myId).remove().catch(()=>{});
    }

    /* =========================================================
       SPECTATE INVITE HANDLER (IDENTICAL TO student2.html)
       ========================================================= */
    db.ref('spectateInvites/'+myId).on('child_added', snap=>{
      const invite = snap.val();
      if(!invite) return;

      const fromEmail = invite.fromEmail || invite.fromId || 'Master';
      const accept = confirm(fromEmail + ' wants to spectate your board. Accept?');

      // Get current FEN
      const currentFen = window.game ? window.game.fen() : 
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

      // Send response
      if(invite.fromId){
        const respPath = `spectateResponses/${invite.fromId}/${myId}`;
        
        db.ref(respPath).set({
          studentId: myId,
          studentEmail: myEmail || null,
          accepted: accept,
          boardId: invite.boardId || null,
          fen: accept ? currentFen : null,
          ts: firebase.database.ServerValue.TIMESTAMP
        }).catch(err=>{
          console.warn('[STUDENT3] spectate response failed', err);
        });
      }

      snap.ref.remove().catch(()=>{});
    });

    /* =========================================================
       FIREBASE MULTIPLAYER OBJECT (IDENTICAL TO student2.html)
       ========================================================= */
    window.firebaseMultiplayer = {
      emitFen: function(arg){
        // Write to moves/<myId> path
        db.ref('moves/'+myId).push({
          payload: arg,
          by: myId,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      },
      getMyId: ()=>myId,
      getMyEmail: ()=>myEmail,
      goOffline: goOffline
    };

    // Auto-join if username exists in localStorage
    setTimeout(() => {
      const saved = localStorage.getItem('username') || localStorage.getItem('email') || '';
      if(saved){
        goOnline(saved);
      }
    }, 500);

  })();
})();
</script>

</body>
</html>
