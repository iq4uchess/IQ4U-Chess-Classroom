<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U â€” Student Puzzle (student3)</title>

  <!-- Chessboard.js CSS -->
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDIsdZ" crossorigin="anonymous">
  
  <style>
    html,body{ overscroll-behavior-y: contain; height:100%; margin:0; padding:0; }
    body{ 
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; 
      margin:16px; 
      background:#f6f7fb; 
      color:#111; 
      -webkit-font-smoothing:antialiased; 
      display:flex; 
      flex-direction:column; 
      align-items:center; 
    }
    button{ 
      padding:8px 12px; 
      border:none; 
      background:#0f172a; 
      color:#fff; 
      border-radius:8px; 
      cursor:pointer; 
      font-size:14px;
    }
    button:hover {
      background:#1e293b;
    }
    .panel{ 
      background:#fff; 
      padding:16px; 
      border-radius:10px; 
      box-shadow:0 6px 18px rgba(2,6,23,.04); 
      margin:12px auto; 
      width:100%; 
      max-width:900px;
      box-sizing:border-box; 
    }
    .info{ margin-top:8px; font-size:13px; color:#444; text-align:center; }
    #engineLog{ 
      font-family:'Courier New', monospace; 
      font-size:12px; 
      overflow:auto; 
      height:140px; 
      background:#0b1220; 
      color:#e6eefc; 
      padding:10px; 
      border-radius:8px; 
      margin-top:10px;
    }
    .small{ font-size:13px; color:#555; }
    
    /* Board container */
    #board {
      width: 500px;
      height: 500px;
      max-width: 90vw;
      max-height: 90vw;
      margin: 20px auto;
      border-radius: 8px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    }
    
    #status { 
      margin: 15px 0; 
      font-weight: bold;
      font-size: 16px;
      background: white;
      padding: 10px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }
    .controls { 
      display: flex; 
      gap: 12px; 
      margin: 15px 0; 
      justify-content: center; 
      flex-wrap: wrap;
    }
    
    .engine-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 10px;
    }
    
    select {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
      background: white;
      font-size: 14px;
    }
    
    label {
      font-size: 14px;
      font-weight: 500;
    }
    
    h1 {
      color: #0f172a;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    #engineOnBtn {
      background: #10b981;
    }
    
    #engineOffBtn {
      background: #ef4444;
      display: none;
    }
  </style>
</head>
<body>

<h1>Student3 - Play vs Stockfish</h1>

<div id="board"></div>

<div id="status">White to move</div>

<div class="controls">
  <button id="resetBtn">Reset Game</button>
  <button id="undoBtn">Undo Move</button>
  <button id="flipBtn">Flip Board</button>
</div>

<div class="panel">
  <div class="engine-controls">
    <div>
      <label class="small">Engine Side:</label>
      <select id="engineColor">
        <option value="white">Engine as White</option>
        <option value="black" selected>Engine as Black</option>
        <option value="both">Engine vs Engine</option>
        <option value="none">Human vs Human</option>
      </select>
    </div>
    
    <div>
      <label class="small">Skill Level:</label>
      <select id="engineLevel">
        <option value="1">1 (Easy)</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8" selected>8 (Hard)</option>
        <option value="10">10 (Expert)</option>
        <option value="15">15 (Master)</option>
        <option value="20">20 (Max)</option>
      </select>
    </div>
    
    <button id="engineOnBtn">Start Engine</button>
    <button id="engineOffBtn" style="display:none;">Stop Engine</button>
  </div>
</div>

<div class="panel">
  <div class="log-header">
    <strong>Engine Debug Log</strong>
    <button id="engineClearBtn">Clear Log</button>
  </div>
  <div id="engineLog"></div>
</div>

<!-- jQuery -->
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>

<!-- Chessboard.js -->
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD" crossorigin="anonymous"></script>

<!-- Chess.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>

<script>
(function(){
  // Initialize game and board
  let game = new Chess();
  let board = null;
  let engine = null;
  let engineEnabled = false;
  let engineColor = 'black';
  let engineLevel = 8;
  let isThinking = false;
  let boardFlipped = false;

  // DOM elements
  const engineLogEl = document.getElementById('engineLog');
  const engineClearBtn = document.getElementById('engineClearBtn');
  const engineLevelSelect = document.getElementById('engineLevel');
  const engineColorSelect = document.getElementById('engineColor');
  const engineOnBtn = document.getElementById('engineOnBtn');
  const engineOffBtn = document.getElementById('engineOffBtn');
  const resetBtn = document.getElementById('resetBtn');
  const undoBtn = document.getElementById('undoBtn');
  const flipBtn = document.getElementById('flipBtn');
  const statusEl = document.getElementById('status');

  // Log helper
  function panelLog(msg, type='log'){
    const line = document.createElement('div');
    line.textContent = `[${new Date().toLocaleTimeString().slice(0,8)}] ${msg}`;
    if(type==='warn') line.style.color = '#ffd166';
    else if(type==='error') line.style.color = '#ff6b6b';
    else if(type==='engine') line.style.color = '#4ade80';
    else if(type==='move') line.style.color = '#60a5fa';
    engineLogEl.appendChild(line);
    engineLogEl.scrollTop = engineLogEl.scrollHeight;
  }

  // Initialize chessboard
  function initBoard() {
    const config = {
      draggable: true,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png',
      orientation: 'white'
    };
    
    board = Chessboard('board', config);
    updateStatus();
    panelLog('Chess board initialized');
  }

  // Update game status
  function updateStatus() {
    let status = '';
    
    if (game.in_checkmate()) {
      status = 'Game over, ' + (game.turn() === 'w' ? 'black' : 'white') + ' wins by checkmate!';
    } else if (game.in_draw()) {
      status = 'Game over, drawn position';
    } else if (game.in_stalemate()) {
      status = 'Game over, stalemate';
    } else if (game.in_threefold_repetition()) {
      status = 'Game over, threefold repetition';
    } else if (game.insufficient_material()) {
      status = 'Game over, insufficient material';
    } else {
      status = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
      if (game.in_check()) {
        status += ', ' + (game.turn() === 'w' ? 'white' : 'black') + ' is in check';
      }
    }
    
    statusEl.innerHTML = status;
    
    // Log the move if there was one
    const moves = game.history();
    if (moves.length > 0) {
      const lastMove = moves[moves.length - 1];
      const player = moves.length % 2 === 1 ? 'White' : 'Black';
      panelLog(`${player}: ${lastMove}`, 'move');
    }
  }

  // Drag start handler
  function onDragStart(source, piece, position, orientation) {
    // Don't allow dragging if game is over
    if (game.game_over()) return false;
    
    // Don't allow dragging if engine is thinking
    if (isThinking) return false;
    
    // Don't allow dragging if it's engine's turn
    if (engineEnabled && !isHumanTurn()) return false;
    
    // Only allow dragging own pieces
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
    
    return true;
  }

  // Check if it's human's turn
  function isHumanTurn() {
    if (!engineEnabled) return true;
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    
    if (engineColor === 'both') return false;
    if (engineColor === 'none') return true;
    if (engineColor === 'white' && currentPlayer === 'white') return false;
    if (engineColor === 'black' && currentPlayer === 'black') return false;
    
    return true;
  }

  // Drop handler
  function onDrop(source, target) {
    // Try the move
    let move = null;
    
    // Check for pawn promotion
    const piece = game.get(source);
    if (piece && piece.type === 'p') {
      if ((piece.color === 'w' && target[1] === '8') || 
          (piece.color === 'b' && target[1] === '1')) {
        // Promote to queen by default
        move = game.move({
          from: source,
          to: target,
          promotion: 'q'
        });
      }
    }
    
    // If not a promotion, try regular move
    if (!move) {
      move = game.move({
        from: source,
        to: target,
        promotion: 'q'
      });
    }
    
    // If illegal move, snap back
    if (move === null) {
      panelLog('Illegal move: ' + source + '-' + target, 'warn');
      return 'snapback';
    }
    
    // Update board
    board.position(game.fen());
    updateStatus();
    
    // If engine is enabled and it's engine's turn, ask engine to move
    if (engineEnabled && engine && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 100);
    }
    
    return 'snap';
  }

  // Snap end handler
  function onSnapEnd() {
    board.position(game.fen());
  }

  // Engine message handler
  function hookEngine(worker) {
    worker.onmessage = e => {
      const line = typeof e.data === 'string' ? e.data : '';
      
      if (line.startsWith('bestmove')) {
        panelLog('[engine] ' + line, 'engine');
        processBestMove(line);
      } else if (line === 'readyok') {
        panelLog('[engine] Ready', 'engine');
      } else if (line.startsWith('uciok')) {
        panelLog('[engine] UCI ready', 'engine');
        // Set engine options
        engine.postMessage('setoption name Threads value 2');
        engine.postMessage('setoption name Hash value 128');
      }
    };
    
    worker.onerror = e => {
      panelLog('Engine error: ' + e.message, 'error');
    };
  }

  // Process engine's best move
  function processBestMove(line) {
    if (!line.startsWith('bestmove')) return;
    
    const parts = line.split(' ');
    if (parts.length < 2) return;
    
    const moveStr = parts[1];
    if (moveStr === '(none)') return;
    
    // Convert UCI to chess.js format
    const from = moveStr.substring(0, 2);
    const to = moveStr.substring(2, 4);
    const promotion = moveStr.length > 4 ? moveStr.substring(4, 5) : null;
    
    // Make the move
    let move = null;
    if (promotion) {
      move = game.move({
        from: from,
        to: to,
        promotion: promotion
      });
    } else {
      move = game.move({
        from: from,
        to: to
      });
    }
    
    if (move) {
      // Update board
      board.position(game.fen());
      updateStatus();
      isThinking = false;
      
      // If engine vs engine and game not over, trigger next move
      if (engineColor === 'both' && !game.game_over()) {
        setTimeout(askEngineToMove, 300);
      }
    } else {
      panelLog('Engine made illegal move: ' + moveStr, 'error');
      isThinking = false;
    }
  }

  // Ask engine to make a move
  function askEngineToMove() {
    if (!engine || game.game_over() || isThinking) return;
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    if (engineColor === 'both' || 
        (engineColor === 'white' && currentPlayer === 'white') ||
        (engineColor === 'black' && currentPlayer === 'black')) {
      
      isThinking = true;
      panelLog(`[engine] Thinking as ${currentPlayer}...`, 'engine');
      
      // Send position to engine
      engine.postMessage('position fen ' + game.fen());
      
      // Set skill level (0-20)
      const skillLevel = Math.min(20, engineLevel);
      engine.postMessage('setoption name Skill Level value ' + skillLevel);
      
      // Ask for move with time constraint
      engine.postMessage('go movetime 1500');
    }
  }

  // Start engine
  function startEngine() {
    panelLog('Starting Stockfish engine...');
    
    if (engine) {
      try { engine.terminate(); } catch(e) {}
      engine = null;
    }
    
    // Create Web Worker with Stockfish
    engine = new Worker('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js');
    hookEngine(engine);
    
    // Initialize UCI
    engine.postMessage('uci');
    engine.postMessage('isready');
    
    engineEnabled = true;
    engineOnBtn.style.display = 'none';
    engineOffBtn.style.display = 'inline-block';
    
    panelLog('Engine started. Skill level: ' + engineLevel);
    
    // If engine should move first
    if (!game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 500);
    }
  }

  // Stop engine
  function stopEngine() {
    engineEnabled = false;
    isThinking = false;
    
    if (engine) {
      try { 
        engine.terminate(); 
        panelLog('Engine stopped');
      } catch(e) {
        panelLog('Error stopping engine: ' + e.message, 'error');
      }
      engine = null;
    }
    
    engineOnBtn.style.display = 'inline-block';
    engineOffBtn.style.display = 'none';
  }

  // Event listeners
  engineOnBtn.addEventListener('click', startEngine);
  engineOffBtn.addEventListener('click', stopEngine);
  
  engineClearBtn.onclick = () => {
    engineLogEl.innerHTML = '';
    panelLog('Log cleared');
  };

  resetBtn.addEventListener('click', () => {
    game = new Chess();
    board.position('start');
    updateStatus();
    panelLog('Game reset to starting position');
    
    if (engineEnabled && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 500);
    }
  });

  undoBtn.addEventListener('click', () => {
    const moves = game.history();
    if (moves.length > 0) {
      game.undo();
      if (moves.length > 1 && engineColor !== 'both') {
        game.undo(); // Undo both player and engine move
      }
      board.position(game.fen());
      updateStatus();
      panelLog('Undid last move');
    }
  });

  flipBtn.addEventListener('click', () => {
    boardFlipped = !boardFlipped;
    board.orientation(boardFlipped ? 'black' : 'white');
    panelLog('Board flipped to ' + (boardFlipped ? 'black' : 'white') + ' view');
  });

  engineColorSelect.addEventListener('change', () => {
    engineColor = engineColorSelect.value;
    panelLog(`Engine side: ${engineColor}`);
    
    if (engineEnabled && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 300);
    }
  });

  engineLevelSelect.addEventListener('change', () => {
    engineLevel = Number(engineLevelSelect.value);
    if (engineEnabled) {
      panelLog(`Engine skill level set to: ${engineLevel}`);
    }
  });

  // Initialize everything when page loads
  $(document).ready(function() {
    initBoard();
    panelLog('Ready! Click "Start Engine" to play against Stockfish.');
    
    // Add some sample log entries
    panelLog('Welcome to Student3 - Chess with Stockfish');
    panelLog('Select engine side and skill level, then click Start Engine');
  });

})();
</script>

</body>
</html>
