<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U — Student Puzzle (student3)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    html,body{ overscroll-behavior-y: contain; height:100%; }
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; -webkit-font-smoothing:antialiased; display:flex; flex-direction:column; align-items:center; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .container{ display:grid; grid-template-columns:420px 1fr; gap:18px; align-items:start; width:100%; justify-content:center; }
    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); margin:0 auto; max-width:920px; width:100%; box-sizing:border-box; }
    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; text-align:center; }
    .board-top{ grid-column: 1 / -1; display:flex; flex-direction:column; align-items:center; gap:12px; width:100%; }
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; width:100%; }
    #board-wrapper{ width:100%; max-width:570px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; margin:0 auto; position:relative; }
    #board-wrapper, #board { touch-action: none; -webkit-user-select: none; -webkit-touch-callout: none; user-select: none; -ms-touch-action: none; }
    #board{ width:100%; aspect-ratio: 1 / 1; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; max-height:80vh; }
    .resizer{ display:flex; gap:10px; align-items:center; background:transparent; justify-content:center; width:100%; }
    .resizer .range{ width:260px; }
    .resizer small{ color:#444; display:block; min-width:48px; text-align:center; font-size:13px; }
    textarea{ width:100%; max-width:720px; min-height:80px; padding:8px; border-radius:6px; border:1px solid #e6eefc; font-family:monospace; display:block; margin:0 auto; box-sizing:border-box; }
    .notation { margin-top:12px; padding:8px; border-radius:6px; border:1px solid #eef2ff; background:#fbfdff; min-height:44px; max-height:160px; overflow:auto; font-family:monospace; font-size:13px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .notation .move { white-space:normal; display:inline-block; padding:4px 8px; border-radius:6px; background:transparent; }
    @media (max-width:900px){
      .container{ grid-template-columns:1fr; padding:0 12px; gap:12px; }
      #board-wrapper{ max-width:100%; }
      #board{ height:80vw; width:100%; aspect-ratio: auto; max-height:420px; }
      .resizer .range{ width:140px; }
      button { padding:10px 14px; font-size:15px; }
      .controls { flex-wrap:wrap; gap:12px; }
    }
    .multiplayer-panel { margin-top: 18px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; justify-content:center; max-width:920px; }
    .multiplayer-panel input[type="text"] { padding:6px 8px; border-radius:6px; border:1px solid #e6eefc; }
    .multiplayer-panel select { padding:6px 8px; border-radius:6px; border:1px solid #e6eefc; }
    .status-bubble { padding:8px 10px; border-radius:8px; background:#f3f6ff; border:1px solid #e6eeff; color:#0b2; font-weight:600; }
    .cb-last-move { outline: 3px solid rgba(255,200,0,0.95); outline-offset: -3px; box-shadow: inset 0 0 0 2px rgba(255,200,0,0.25); }
    .promote-modal { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; border-radius:10px; padding:12px; box-shadow:0 10px 30px rgba(2,6,23,0.2); z-index:9999; display:none; }
    .promote-modal .row{ display:flex; gap:8px; align-items:center; justify-content:center; }
    .promote-modal button{ min-width:44px; min-height:44px; font-weight:700; }
    .readonly-note{ color:#444; font-size:13px; margin-left:8px; }
    .logout-btn { background:#dc2626; }
    #draw-overlay { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:30; }
    .arrow-line { stroke-width:4px; stroke-linecap:round; stroke-linejoin:round; }
    .arrow-head { fill: currentColor; }
    .square-highlight { position:absolute; border-radius:50%; pointer-events:none; transform:translate(-50%,-50%); box-shadow:0 0 0 3px rgba(0,0,0,0.06); background: rgba(220,20,60,0.12); width:44px; height:44px; display:block; z-index:25; border:3px solid rgba(220,20,60,0.25); }
  </style>
</head>
<body>

  <!-- ACCESS CHECK -->
  <script>
    (function(){
      const allowedRoles = ['student1','student2','student3','student4'];
      const role = localStorage.getItem('role');
      if(!role || allowedRoles.indexOf(role) === -1){
        try{ window.location.replace('index.html'); }catch(e){ window.location.href='index.html'; }
      }
    })();
  </script>

  <div class="board-top">
    <div class="controls" aria-hidden="false">
      <button id="undoBtn">Undo</button>
      <button id="flipBtn">Flip</button>
      <button id="resignBtn" title="Resign / Reset" style="background:#8b0f0f;">Resign</button>
      <button id="logoutBtn" class="logout-btn">Logout</button>
    </div>

    <div class="resizer" aria-label="Board resizer controls" style="margin-top:6px;">
      <input id="boardSizeRange" name="board-size" class="range" type="range" min="240" max="1200" step="10" value="570" aria-label="Board size">
      <small id="boardSizeLabel">570px</small>
    </div>

    <div class="panel" style="width:100%; max-width:920px;">
      <div id="board-wrapper">
        <div id="board" aria-label="Chessboard container"></div>
        <svg id="draw-overlay" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"></svg>
      </div>

      <div class="info" id="msg" aria-live="polite"></div>

      <div id="movesList" class="notation" aria-live="polite" role="status">No moves yet.</div>

      <!-- Engine Debug Panel inserted here -->
      <div style="margin-top:10px; display:flex; justify-content:center;">
        <div style="width:100%; max-width:920px;">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px;">
            <strong style="font-size:13px;">Engine Debug Log</strong>
            <div style="display:flex; gap:8px; align-items:center;">
              <button id="engineClearBtn" style="background:#0f172a;padding:6px 8px;border-radius:6px;">Clear</button>
              <label class="small"><input id="enginePanelToggle" type="checkbox" checked /> Visible</label>
            </div>
          </div>
          <div id="engineLog" aria-live="polite" style="background:#0b1220;color:#e6eefc;padding:8px;border-radius:8px;height:160px;overflow:auto;font-family:monospace;font-size:12px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);"></div>
        </div>
      </div>

    </div>
  </div>

  <div class="container" style="margin-top:18px;">
    <div style="display:flex; flex-direction:column; gap:12px;">
      <div class="panel">
        <div style="display:flex; flex-direction:column; align-items:center;">
          <strong>FEN Input (paste FEN here)</strong>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="loadFenBtn">Load FEN</button>
          </div>

          <div style="margin-top:8px; width:100%; display:flex; justify-content:center;">
            <textarea id="pgnInput" name="fen-input" placeholder="Paste FEN here to load a position. Example FEN:
r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3"></textarea>
          </div>

          <div style="display:flex; gap:8px; margin-top:8px; justify-content:center;">
            <button id="clearPgn">Clear</button>
            <button id="resetBtnLeft" title="Reset board">Reset</button>
          </div>
        </div>
      </div>
    </div>

    <div></div>
  </div>

  <div class="panel multiplayer-panel" style="margin-top:18px; max-width:920px;" id="multiplayerPanel">
    <div style="display:flex; gap:8px; align-items:center;">
      <label for="emailInputBottom" class="small">Your username:</label>
      <input id="emailInputBottom" name="username" type="text" placeholder="your username (e.g. student3)" />
      <label class="small"><input id="spectatorToggle" name="spectator" type="checkbox" /> Spectator</label>
      <button id="joinBtnBottom">Join Online</button>
    </div>

    <div style="display:flex; gap:8px; align-items:center; margin-top:10px;">
      <label class="small" for="onlinePlayersBottom">Online Players:</label>
      <select id="onlinePlayersBottom" name="online-players"></select>
      <button id="challengeBtnBottom">Challenge Player</button>
      <span class="readonly-note" id="readonlyNote" style="display:none;">Read-only mode</span>
    </div>

    <div style="margin-left:auto; display:flex; gap:8px; align-items:center; margin-top:10px;">
      <div id="multiplayStatus" class="muted">Not connected</div>
      <div id="pairedBubble" class="status-bubble" style="display:none;">Paired</div>
    </div>

    <!-- Engine controls: levels 1..8 to match lichess-like levels -->
    <div style="width:100%; margin-top:8px; display:flex; gap:8px; align-items:center; justify-content:center;">
      <label class="small">Engine:</label>
      <select id="engineColor">
        <option value="black">Engine as Black</option>
        <option value="white">Engine as White</option>
      </select>
      <label class="small">Level</label>
      <select id="engineLevel">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8" selected>8</option>
      </select>
      <label class="small">Move time (ms)</label>
      <input id="engineMoveTime" type="number" min="50" step="50" value="300" style="width:84px; padding:6px 8px; border-radius:6px; border:1px solid #e6eefc;" />
      <button id="toggleEngineBtn">Play vs Engine</button>
    </div>
  </div>

  <div class="promote-modal" id="promoteModal" role="dialog" aria-modal="true">
    <div style="font-weight:700; text-align:center; margin-bottom:8px;">Choose promotion</div>
    <div class="row">
      <button data-piece="q">Q</button>
      <button data-piece="r">R</button>
      <button data-piece="b">B</button>
      <button data-piece="n">N</button>
    </div>
  </div>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <script>
  (function(){
    const CHESS_URL = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/libs/chess.min.js';
    const CUSTOM_PIECE_THEME = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/{piece}.svg';
    const FALLBACK_THEME = 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png';

    // DOM
    const boardWrapper = document.getElementById('board-wrapper');
    const drawOverlay = document.getElementById('draw-overlay');
    const boardSizeRange = document.getElementById('boardSizeRange');
    const boardSizeLabel = document.getElementById('boardSizeLabel');
    const msgEl = document.getElementById('msg');
    const promoteModal = document.getElementById('promoteModal');

    // controls
    const undoBtn = document.getElementById('undoBtn');
    const flipBtn = document.getElementById('flipBtn');
    const resignBtn = document.getElementById('resignBtn');
    const logoutBtn = document.getElementById('logoutBtn');

    // fen / input
    const pgnInput = document.getElementById('pgnInput');
    const loadFenBtn = document.getElementById('loadFenBtn');
    const clearPgn = document.getElementById('clearPgn');
    const resetBtnLeft = document.getElementById('resetBtnLeft');

    // notation
    const movesList = document.getElementById('movesList');

    // multiplayer UI
    const emailInputBottom = document.getElementById('emailInputBottom');
    const joinBtnBottom = document.getElementById('joinBtnBottom');
    const spectatorToggle = document.getElementById('spectatorToggle');
    const onlinePlayersBottom = document.getElementById('onlinePlayersBottom');
    const challengeBtnBottom = document.getElementById('challengeBtnBottom');
    const multiplayStatus = document.getElementById('multiplayStatus');
    const pairedBubble = document.getElementById('pairedBubble');
    const readonlyNote = document.getElementById('readonlyNote');

    // engine controls
    const engineColorSelect = document.getElementById('engineColor');
    const engineLevelSelect = document.getElementById('engineLevel');
    const engineMoveTimeInput = document.getElementById('engineMoveTime');
    const toggleEngineBtn = document.getElementById('toggleEngineBtn');

    // state
    let board = null, game = null, currentTheme = FALLBACK_THEME;
    let isSpectator = false, myColor = null, isPaired = false, pairedGameId = null;
    let pendingPromo = null;

    // engine state
    let engine = null; // Worker
    let engineEnabled = false;
    let engineColor = 'black';
    let engineLevel = 8; // 1..8
    let engineMoveTime = 300;

    // drawing state (minimal helpers)
    let lastMoveSquares = [];

    // left-click detection
    let leftClickStart = null;

    function setMsg(t, ms=0){
      if(msgEl) msgEl.textContent = t||'';
      if(ms>0) setTimeout(()=>{ if(msgEl && msgEl.textContent===t) msgEl.textContent=''; }, ms);
    }

    // safe loader for chess.js
    async function ensureChessLoaded(){
      if(typeof Chess !== 'undefined') return;
      try{
        const mod = await import(CHESS_URL + '?t=' + Date.now());
        window.Chess = mod.default || mod.Chess || mod;
      }catch(e){}
      if(typeof Chess !== 'undefined') return;
      return new Promise(resolve=>{
        const s = document.createElement('script');
        s.src = CHESS_URL + '?t=' + Date.now();
        s.async = true;
        s.onload = ()=> setTimeout(()=>resolve(), 10);
        s.onerror = ()=> resolve();
        document.head.appendChild(s);
      });
    }

    // choose piece theme
    async function chooseTheme(){
      const test = CUSTOM_PIECE_THEME.replace('{piece}','wP');
      try{ const res = await fetch(test,{method:'HEAD',cache:'no-store'}); return res.ok?CUSTOM_PIECE_THEME:FALLBACK_THEME;}catch(e){return FALLBACK_THEME}
    }

    // Minimal overlay resize helper to avoid ReferenceError
    function updateOverlaySize(){
      try{
        const boardEl = document.getElementById('board');
        const svg = document.getElementById('draw-overlay');
        if(!boardEl || !svg) return;
        const rect = boardEl.getBoundingClientRect();
        svg.style.width = Math.max(0, Math.round(rect.width)) + 'px';
        svg.style.height = Math.max(0, Math.round(rect.height)) + 'px';
        svg.setAttribute('viewBox', `0 0 ${Math.max(0, Math.round(rect.width))} ${Math.max(0, Math.round(rect.height))}`);
      }catch(e){ console.warn('updateOverlaySize failed', e); }
    }
    window.addEventListener('resize', updateOverlaySize);

    // create board
    function createBoard(theme){
      const orientation = (isPaired && myColor==='black') ? 'black' : 'white';
      if(board && typeof board.destroy === 'function'){ try{ board.destroy(); }catch(e){} }
      if(typeof game === 'undefined' || game===null) game = new Chess();
      board = Chessboard('board', {
        draggable: !isSpectator,
        position: game ? game.fen() : 'start',
        orientation: orientation,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: theme
      });
      try{ if(board && typeof board.position === 'function') board.position(game.fen()); }catch(e){ console.warn('board.position error', e); }
      refreshNotation();
      setTimeout(updateOverlaySize, 30);
    }

    function onSnapEnd(){ if(board) board.position(game.fen()); }

    // promotion dialog
    function showPromotionDialog(){ promoteModal.style.display='block'; }
    function hidePromotionDialog(){ promoteModal.style.display='none'; }
    promoteModal.addEventListener('click', function(e){
      if(e.target && e.target.dataset && e.target.dataset.piece){
        const p = e.target.dataset.piece;
        if(pendingPromo && pendingPromo.resolve) pendingPromo.resolve(p);
        hidePromotionDialog();
      }
    });

    // onDrop (with promotion)
    async function onDrop(source, target){
      if(!game) return 'snapback';
      if(isSpectator){ setMsg('Spectator — cannot move',1000); return 'snapback'; }

      // If playing against engine and engine controls the side the user tried to move, block
      if(engineEnabled){
        const humanSide = (engineColor==='white') ? 'b' : 'w';
        const piece = game.get(source);
        if(piece && piece.color !== humanSide){ setMsg('Not your piece (engine game)',900); return 'snapback'; }
      }

      if(isPaired && myColor){
        const our = (myColor==='white') ? 'w' : 'b';
        const piece = game.get(source);
        if(!piece){ setMsg('No piece at source',900); return 'snapback'; }
        if(piece.color !== our){ setMsg('Not your piece',900); return 'snapback'; }
        if(game.turn() !== our){ setMsg('Not your turn',900); return 'snapback'; }
      }

      const legal = game.moves({ verbose:true }) || [];
      const candidate = legal.find(m => m.from === source && m.to === target && m.promotion);
      let chosenPromo = null;
      if(candidate){
        chosenPromo = await new Promise(resolve => { pendingPromo = { from:source, to:target, resolve }; showPromotionDialog(); });
        pendingPromo = null;
        if(!chosenPromo) chosenPromo = 'q';
      }

      const moveObj = { from: source, to: target };
      if(chosenPromo) moveObj.promotion = chosenPromo;
      const mv = game.move(moveObj);
      if(mv === null){ setMsg('Illegal move',900); return 'snapback'; }

      if(board) board.position(game.fen());
      refreshNotation();

      setPersistentLastMove(source, target);

      try{
        if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitMove){
          window.firebaseMultiplayer.emitMove({ fen: game.fen(), move: { from: mv.from, to: mv.to, san: mv.san, promotion: mv.promotion || null } });
        }
        if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitFen){
          window.firebaseMultiplayer.emitFen({ fen: game.fen(), move: { from: mv.from, to: mv.to, san: mv.san, promotion: mv.promotion || null } });
        }
      }catch(e){ console.error('onDrop emit error:', e); }

      // If engine is enabled and it's engine's turn now, ask engine to play
      if(engineEnabled){ maybeAskEngineToMove(); }

      return;
    }

    // map levels 1..8 to search depths (adjustable)
    function levelToDepth(level){
      const lvl = Number(level)||1;
      const map = {1:1,2:2,3:3,4:4,5:6,6:8,7:10,8:12};
      return map[Math.max(1, Math.min(8, lvl))] || 4;
    }

    // ask engine to move when it's engine's turn
    function maybeAskEngineToMove(){
      if(!engineEnabled || !engine) return;
      if(!game) return;
      const turn = game.turn();
      const engColor = (engineColor==='white') ? 'w' : 'b';
      if(turn !== engColor) return; // not engine's turn

      const fen = game.fen();
      postToEngine('position fen ' + fen);
      const depth = levelToDepth(engineLevel);
      postToEngine('setoption name Threads value 1');
      postToEngine('isready');
      // choose go by depth (deterministic)
      postToEngine('go depth ' + depth);
      panelLog('log','Engine thinking (level ' + engineLevel + ', depth ' + depth + ')...');
      setMsg('Engine thinking (level ' + engineLevel + ')', 0);
    }

    // ===========================
    // Engine worker initialization
    // ===========================
    // Use local stockfish worker at /js/stockfish.js (you must host this file)
    const WORKER_PATH = '/js/stockfish.js';

    // Debug panel logger functions (panelLog used throughout)
    function panelLogAdd(text, level){
      try{
        const el = document.getElementById('engineLog');
        if(!el) return;
        const row = document.createElement('div');
        row.textContent = '[' + new Date().toLocaleTimeString() + '] ' + text;
        row.style.whiteSpace = 'pre-wrap';
        row.style.padding = '2px 4px';
        row.style.marginBottom = '2px';
        if(level === 'warn'){ row.style.color = '#ffd166'; }
        else if(level === 'error'){ row.style.color = '#ff6b6b'; }
        el.appendChild(row);
        el.scrollTop = el.scrollHeight;
      }catch(e){}
    }
    function panelLog(level, text){
      try{
        if(level === 'log') console.log(text);
        else if(level === 'warn') console.warn(text);
        else if(level === 'error') console.error(text);
        else console.log(text);
      }catch(e){}
      try{ panelLogAdd(text, level); }catch(e){}
    }

    // postToEngine wrapper (logs outgoing commands)
    function postToEngine(cmd){
      try{
        panelLog('log','[engine <=] ' + cmd);
        if(!engine){ panelLog('warn','[engine] no engine worker available'); return; }
        engine.postMessage(cmd);
      }catch(e){
        panelLog('error','[engine <=] post failed: ' + (e && e.message ? e.message : e));
      }
    }

    // hook engine logging to on-page panel
    function hookEngineLogging(worker){
      if(!worker) return;
      worker.onmessage = function(e){
        const raw = e.data;
        const line = (typeof raw === 'string') ? raw : (raw && raw.message) ? raw.message : JSON.stringify(raw);
        panelLog('log','[engine =>] ' + line);

        try{
          if(typeof line !== 'string' || !line) return;
          if(line.indexOf('uciok')!==-1) panelLog('log','[engine] uciok received');
          if(line.indexOf('readyok')!==-1) panelLog('log','[engine] readyok received');
        }catch(err){ panelLog('warn','engine parse warning ' + (err && err.message ? err.message : err)); }

        // handle bestmove automatically: apply it to the game
        if(line.startsWith('bestmove')){
          const parts = line.split(' ');
          if(parts.length >= 2){
            const mv = parts[1];
            if(mv && mv !== '(none)'){
              const from = mv.substring(0,2);
              const to = mv.substring(2,4);
              let promo = null;
              if(mv.length >= 5) promo = mv[4];
              try{
                const moveObj = { from: from, to: to };
                if(promo) moveObj.promotion = promo;
                const applied = game.move(moveObj);
                if(applied !== null){
                  if(board) board.position(game.fen());
                  refreshNotation();
                  setPersistentLastMove(from, to);
                  panelLog('log','[engine] applied move ' + (applied.san || (from+to)));
                  setMsg('Engine moved ' + (applied.san || (from+to)), 1000);
                  try{ if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitMove) window.firebaseMultiplayer.emitMove({ fen: game.fen(), move: { from, to, san: applied.san||null, promotion: applied.promotion||null } }); }catch(e){}
                } else {
                  panelLog('warn','[engine] engine move could not be applied: ' + mv);
                }
              }catch(e){ panelLog('warn','Failed to apply engine move ' + (e && e.message ? e.message : e)); }
            }
          }
        }
      };

      worker.onerror = function(err){
        panelLog('error','[engine] worker error: ' + (err && err.message ? err.message : JSON.stringify(err)));
      };
      worker.onmessageerror = function(err){
        panelLog('error','[engine] onmessageerror: ' + (err && err.message ? err.message : JSON.stringify(err)));
      };
    }

    // init engine worker (local only for reliability)
    function initEngineWorker(){
      if(engine){ try{ engine.terminate(); }catch(e){} engine = null; }
      try{
        panelLog('log','[engine] creating worker from ' + WORKER_PATH);
        engine = new Worker(WORKER_PATH);
        hookEngineLogging(engine);
        // initialize UCI
        postToEngine('uci');
        postToEngine('isready');
        panelLog('log','[engine] worker created and initialized from ' + WORKER_PATH);
      }catch(e){
        panelLog('error','[engine] worker create failed for ' + WORKER_PATH + ' ' + (e && e.message ? e.message : e));
        engine = null;
      }
    }

    // notation refresh
    function refreshNotation(){
      try{
        if(!movesList) return;
        if(!game) { movesList.innerHTML = 'No moves yet.'; return; }
        const hist = game.history() || [];
        if(hist.length === 0){ movesList.innerHTML = 'No moves yet.'; return; }

        movesList.innerHTML = '';
        for(let i=0;i<hist.length;i+=2){
          const no = Math.floor(i/2)+1;
          const w = hist[i]||'';
          const b = hist[i+1]||'';
          const div = document.createElement('div');
          div.className = 'move';
          div.innerHTML = `<strong>${no}.</strong>&nbsp;${w}${ b ? ('\u00A0' + b) : '' }`;
          movesList.appendChild(div);
        }
        movesList.scrollLeft = movesList.scrollWidth;
      }catch(e){ console.warn('refreshNotation error', e); }
    }

    // inbound move handler (multiplayer)
    window.onBoardMove = function(payload){
      try{
        if(!payload) return;

        if(typeof payload === 'string'){
          if(!game) game = new Chess();
          if(typeof game.load === 'function'){ game.load(payload); }
          if(board) board.position(game.fen());
          refreshNotation();
          return;
        }

        if(!game) game = new Chess();

        if(payload.move && payload.move.from && payload.move.to){
          const mvObj = { from: payload.move.from, to: payload.move.to };
          if(payload.move.promotion) mvObj.promotion = payload.move.promotion;
          const applied = game.move(mvObj);
          if(applied === null){
            if(payload.fen && typeof game.load === 'function'){
              game.load(payload.fen);
            }
          } else {
            setPersistentLastMove(payload.move.from, payload.move.to);
          }
        } else if(payload.fen){
          if(typeof game.load === 'function') game.load(payload.fen);
        }

        if(board) board.position(game.fen());
        refreshNotation();
      }catch(e){ console.warn('onBoardMove failed', e); }
    };

    // persistent last-move highlight
    function setPersistentLastMove(src, tgt){
      lastMoveSquares.forEach(sq => {
        const el = document.querySelector('.square-' + sq);
        if(el) el.classList.remove('cb-last-move');
      });
      lastMoveSquares = [];
      ['square-' + src, 'square-' + tgt].forEach(cls => {
        const el = document.querySelector('.' + cls);
        if(el) el.classList.add('cb-last-move');
        lastMoveSquares.push(cls.replace('square-',''));
      });
    }

    // boot
    async function boot(){
      await ensureChessLoaded();
      currentTheme = await chooseTheme();
      game = new Chess();
      createBoard(currentTheme);

      try{
        const uname = localStorage.getItem('username') || localStorage.getItem('email') || '';
        if(uname && emailInputBottom) emailInputBottom.value = uname;
      }catch(e){}

      // Auto-join online if username exists in input or localStorage
      try{
        const saved = (emailInputBottom && emailInputBottom.value) ? emailInputBottom.value.trim() : (localStorage.getItem('username') || localStorage.getItem('email') || '');
        if(saved){
          setTimeout(()=>{ if(window.firebaseMultiplayer && window.firebaseMultiplayer.autoJoin) window.firebaseMultiplayer.autoJoin(saved); }, 200);
        }
      }catch(e){}

      const initial = parseInt(getComputedStyle(boardWrapper).maxWidth,10) || boardWrapper.clientWidth || 570;
      setBoardSize(initial);
      setMsg('Ready', 700);

      drawOverlay.addEventListener('contextmenu', e => e.preventDefault());
      document.getElementById('board').addEventListener('contextmenu', e => e.preventDefault());

      // initialize engine UI state
      engineColor = engineColorSelect.value || 'black';
      engineLevel = Number(engineLevelSelect.value) || 8;
      engineMoveTime = Number(engineMoveTimeInput.value) || 300;

      engineLevelSelect.addEventListener('change', ()=>{ engineLevel = Number(engineLevelSelect.value)||8; });
      engineColorSelect.addEventListener('change', ()=>{ engineColor = engineColorSelect.value || 'black'; });
      engineMoveTimeInput.addEventListener('change', ()=>{ engineMoveTime = Number(engineMoveTimeInput.value)||300; });

      toggleEngineBtn.addEventListener('click', ()=>{
        engineEnabled = !engineEnabled;
        if(engineEnabled){
          toggleEngineBtn.textContent = 'Engine: ON';
          initEngineWorker();
          // If engine starts and it's engine to move on current position, ask it
          setTimeout(()=>{ maybeAskEngineToMove(); }, 300);
        } else {
          toggleEngineBtn.textContent = 'Play vs Engine';
          if(engine){ try{ engine.terminate(); }catch(e){} engine = null; }
        }
      });
    }
    boot();

    // UI handlers (undo/flip/resign/logout)
    undoBtn.addEventListener('click', ()=>{ 
      if(!game) return; 
      const mv = game.undo(); 
      if(mv) { 
        if(board) board.position(game.fen()); 
        refreshNotation(); 
        setMsg('Undid move',900);
        try{ 
          if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitFen){
            window.firebaseMultiplayer.emitFen({ fen: game.fen(), move: { from: mv.from, to: mv.to, san: mv.san, promotion: mv.promotion || null }, action: 'undo' });
          }
        }catch(e){}
      } 
    });
    flipBtn.addEventListener('click', ()=>{ if(board) board.flip(); setTimeout(updateOverlaySize,30); });
    resignBtn.addEventListener('click', ()=>{
      if(!game) return;
      game.reset();
      if(board) board.position('start');
      refreshNotation();
      setMsg('You resigned — game reset',1500);
      try{ 
        if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitMove){ 
          window.firebaseMultiplayer.emitMove({ type:'resign', by: window.firebaseMultiplayer.getMyId ? window.firebaseMultiplayer.getMyId() : null }); 
        }
        if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitFen){
          window.firebaseMultiplayer.emitFen({ fen: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKB1R w KQkq - 0 1', action: 'resign' });
        }
      }catch(e){}
      isPaired = false; myColor = null; pairedGameId = null; isSpectator = false;
      pairedBubble.style.display='none';
      multiplayStatus.textContent = 'Not connected';
      readonlyNote.style.display = 'none';
      createBoard(currentTheme);
      if(engine){ try{ engine.terminate(); }catch(e){} engine = null; }
      engineEnabled = false; toggleEngineBtn.textContent = 'Play vs Engine';
    });

    logoutBtn.addEventListener('click', ()=>{
      try{ localStorage.removeItem('role'); localStorage.removeItem('username'); localStorage.removeItem('email'); }catch(e){}
      try{ if(window.firebaseMultiplayer && window.firebaseMultiplayer.goOffline) window.firebaseMultiplayer.goOffline(); }catch(e){}
      window.location.href = 'index.html';
    });

    loadFenBtn.addEventListener('click', ()=>{
      const txt = pgnInput.value.trim();
      if(!txt){ setMsg('Paste a FEN string to load',1200); return; }
      try{
        if(!game) game = new Chess();
        const ok = game.load(txt);
        if(ok === false){ setMsg('Invalid FEN',1400); return; }
        if(board) board.position(game.fen());
        refreshNotation();
        setMsg('FEN loaded',1100);
        setTimeout(updateOverlaySize, 30);
        try{ 
          if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitFen){
            window.firebaseMultiplayer.emitFen({ fen: game.fen(), action: 'loadFen' });
          }
        }catch(e){}
        setTimeout(()=>{ maybeAskEngineToMove(); }, 200);
      }catch(e){ setMsg('Invalid FEN',1400); console.warn(e); }
    });

    clearPgn.addEventListener('click', ()=>{ pgnInput.value=''; setMsg('Cleared',900); });

    resetBtnLeft.addEventListener('click', ()=>{ 
      if(!game) game = new Chess(); 
      else game.reset(); 
      if(board) board.position(game.fen()); 
      refreshNotation(); 
      setMsg('Reset to start',900); 
      setTimeout(updateOverlaySize, 30); 
      try{ 
        if(window.firebaseMultiplayer && window.firebaseMultiplayer.emitFen){
          window.firebaseMultiplayer.emitFen({ fen: game.fen(), action: 'reset' });
        }
      }catch(e){}
      setTimeout(()=>{ maybeAskEngineToMove(); }, 200);
    });

    boardSizeRange.addEventListener('input', (e)=> setBoardSize(e.target.value));
    function setBoardSize(px){ if(!px || isNaN(px)) return; const clamped = Math.max(240, Math.min(1200, Number(px))); boardWrapper.style.maxWidth = clamped + 'px'; boardSizeRange.value = clamped; boardSizeLabel.textContent = clamped + 'px'; try{ if(board && typeof board.resize === 'function'){ board.resize(); } else { createBoard(currentTheme); } }catch(e){ createBoard(currentTheme); } setTimeout(updateOverlaySize,20); }

    // firebase code unchanged except spectate handling improvements below
  })();
  </script>

  <!-- FIREBASE (presence + spectate-response handling) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script>
  (function(){
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
      authDomain: "iq4u-chess-classroom.firebaseapp.com",
      databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iq4u-chess-classroom",
      storageBucket: "iq4uchess-classroom.firebasedestorage.app",
      messagingSenderId: "833620718306",
      appId: "1:833620718306:web:b599bb693d0736fe0da4bb"
    };
    try{ firebase.initializeApp(FIREBASE_CONFIG); }catch(e){ /* ignore if already initialized */ }

    (function(){
      const db = firebase.database();
      const onlineRef = db.ref('online');
      const challengesRef = db.ref('challenges');
      const gamesRef = db.ref('games');
      let movesRef = null;

      // consistent sessionStorage key
      let myId = sessionStorage.getItem('iq4u_clientId') || ('c_'+Math.random().toString(36).slice(2,10));
      sessionStorage.setItem('iq4u_clientId', myId);

      let myEmail = '';
      let currentGameId = null;
      let presenceTimer = null;

      // goOnline: writes role="student" and keeps record until explicit logout
      function goOnline(email){
        myEmail = email || ('anon-'+myId);
        const node = onlineRef.child(myId);
        node.set({ email: myEmail, role: 'student', ts: firebase.database.ServerValue.TIMESTAMP })
          .then(()=>{ document.getElementById('multiplayStatus').textContent = 'Connected as ' + myEmail; })
          .catch(()=>{ document.getElementById('multiplayStatus').textContent = 'Presence write error'; });

        if(presenceTimer) clearInterval(presenceTimer);
        presenceTimer = setInterval(()=> node.update({ ts: firebase.database.ServerValue.TIMESTAMP }), 25000);
      }
      function goOffline(){ if(presenceTimer) clearInterval(presenceTimer); onlineRef.child(myId).remove().catch(()=>{}); document.getElementById('multiplayStatus').textContent = 'Not connected'; }

      // populate online list
      onlineRef.on('value', snap=>{
        const v = snap.val()||{};
        const onlinePlayersBottom = document.getElementById('onlinePlayersBottom');
        if(!onlinePlayersBottom) return;
        onlinePlayersBottom.innerHTML='';
        let count=0;
        for(const id in v){
          if(!v.hasOwnProperty(id)) continue;
          if(id===myId) continue;
          const opt = document.createElement('option');
          opt.value=id;
          opt.textContent = v[id].email||id;
          onlinePlayersBottom.appendChild(opt);
          count++;
        }
        if(count===0){
          const opt = document.createElement('option');
          opt.value='';
          opt.disabled=true;
          opt.selected=true;
          opt.textContent='No Player';
          onlinePlayersBottom.appendChild(opt);
          document.getElementById('challengeBtnBottom').disabled=true;
        } else document.getElementById('challengeBtnBottom').disabled=false;
      });

      function sendChallengeTo(targetId){ if(!targetId) return; const ch = challengesRef.child(targetId).push(); ch.set({ fromId: myId, fromEmail: myEmail, ts: firebase.database.ServerValue.TIMESTAMP }).then(()=>{ document.getElementById('multiplayStatus').textContent = 'Challenge sent'; setTimeout(()=> ch.remove().catch(()=>{}), 60_000); }).catch(()=>{ document.getElementById('multiplayStatus').textContent = 'Challenge failed'; }); }

      // handle incoming challenge
      challengesRef.child(myId).on('child_added', snap=>{
        const data = snap.val(); const key = snap.key;
        if(!data) return;
        const fromEmail = data.fromEmail||data.fromId;
        const accept = confirm(fromEmail + ' challenges you. Accept?');
        if(accept){
          const gameNode = gamesRef.push();
          const gameId = gameNode.key;
          const gameData = { white: data.fromId, black: myId, createdAt: firebase.database.ServerValue.TIMESTAMP };
          gameNode.set(gameData).then(()=>{
            movesRef = db.ref('moves/'+gameId);
            currentGameId = gameId;
            document.getElementById('pairedBubble').style.display='inline-block';
            document.getElementById('multiplayStatus').textContent = 'Paired: You are Black';
            db.ref('notifications/'+data.fromId+'/'+gameId).set({ type:'startGame', gameId, white: data.fromId, black: myId });
            challengesRef.child(myId).child(key).remove().catch(()=>{});
            watchMoves(gameId);
            window.isPaired = true;
            if(window._onFirebaseGameStart) window._onFirebaseGameStart({ gameId: gameId, color: 'black', myId: myId });
            try{ localStorage.setItem('iq4u_last_game', gameId); localStorage.setItem('iq4u_last_color','black'); }catch(e){}
          });
        } else {
          if(data.fromId) db.ref('challengeDeclined/'+data.fromId+'/'+myId).set({ email: myEmail, ts: firebase.database.ServerValue.TIMESTAMP });
          challengesRef.child(myId).child(key).remove().catch(()=>{});
        }
      });

      // Watch for master's moves (master will write to moves/{myId})
      let masterMovesRef = null;
      function watchMasterMoves(){
        if(masterMovesRef) return;
        masterMovesRef = db.ref('moves/'+myId);
        masterMovesRef.on('child_added', snap=>{
          const m = snap.val();
          if(!m) return;
          if(!m.by || !m.by.startsWith('m_')) {
            return;
          }
          if(m.payload){
            try{ if(typeof window.onBoardMove === 'function') window.onBoardMove(m.payload); }catch(e){ console.warn(e); }
          }
        });
      }
      watchMasterMoves();

      // notifications
      db.ref('notifications/'+myId).on('child_added', snap=>{
        const n = snap.val();
        if(!n) return;
        if(n.type==='startGame' && n.gameId){
          currentGameId = n.gameId;
          watchMoves(currentGameId);
          document.getElementById('pairedBubble').style.display='inline-block';
          const color = (n.white===myId)?'white':((n.black===myId)?'black':null);
          if(color) document.getElementById('multiplayStatus').textContent = 'Paired: You are ' + (color.charAt(0).toUpperCase()+color.slice(1));
          if(window._onFirebaseGameStart) window._onFirebaseGameStart({ gameId: currentGameId, color: color, myId: myId });
          try{ localStorage.setItem('iq4u_last_game', currentGameId); if(color) localStorage.setItem('iq4u_last_color', color); }catch(e){}
        }
        snap.ref.remove().catch(()=>{});
      });

      db.ref('challengeDeclined/'+myId).on('child_added', snap=>{
        const d = snap.val();
        if(!d) return;
        document.getElementById('multiplayStatus').textContent = (d.email||'Player') + ' declined your challenge';
        snap.ref.remove().catch(()=>{});
      });

      // Spectate invites
      let isSpectatedByMaster = false;
      const spectateInvitePath = 'spectateInvites/'+myId;

      db.ref(spectateInvitePath).once('value', snap => {
        if(snap.exists()){
          snap.forEach(child => {
            processInvite(child);
          });
        }
      }).catch(err => {
        console.error('fetch invites error:', err);
      });

      db.ref(spectateInvitePath).on('child_added', snap => {
        processInvite(snap);
      }, err => { console.error('invite child_added error', err); });

      function processInvite(snap){
        const inv = snap.val();
        if(!inv) return;
        const fromEmail = inv.fromEmail || inv.fromId || 'Master';
        const accept = confirm(fromEmail + ' wants to spectate your board. Accept?');
        if(accept){
          isSpectatedByMaster = true;
          document.getElementById('multiplayStatus').textContent = 'Master is spectating';
          if(inv.fromId){
            const respPath = `spectateResponses/${inv.fromId}/${myId}`;
            const respRef = db.ref(respPath);
            const payload = { studentId: myId, accepted: true, boardId: inv.boardId || null, ts: firebase.database.ServerValue.TIMESTAMP };
            respRef.set(payload).then(()=>{}).catch(()=>{});
          }
        } else {
          if(inv.fromId){
            const respPath = `spectateResponses/${inv.fromId}/${myId}`;
            const respRef = db.ref(respPath);
            const payload = { studentId: myId, accepted: false, boardId: inv.boardId || null, ts: firebase.database.ServerValue.TIMESTAMP };
            respRef.set(payload).then(()=>{}).catch(()=>{});
          }
        }
        try{ snap.ref.remove().catch(()=>{}); }catch(e){}
      }

      function watchMoves(gameId){
        if(!gameId) return;
        movesRef = db.ref('moves/'+gameId);
        movesRef.on('child_added', snap=>{
          const m = snap.val();
          if(!m) return;
          if(m.by && m.by===myId) return;
          if(m.payload){
            try{ if(typeof window.onBoardMove === 'function') window.onBoardMove(m.payload); }catch(e){ console.warn(e); }
          } else if(m.fen){
            try{ if(typeof window.onBoardMove === 'function') window.onBoardMove({ fen: m.fen, move: m.move||null }); }catch(e){}
          }
          if(m.payload && m.payload.type === 'resign'){
            try{
              if(window.game) window.game.reset();
              if(window.board) window.board.position('start');
              if(document.getElementById('pairedBubble')) document.getElementById('pairedBubble').style.display='none';
              if(document.getElementById('multiplayStatus')) document.getElementById('multiplayStatus').textContent = 'Opponent resigned / game ended';
              try{ localStorage.removeItem('iq4u_last_game'); localStorage.removeItem('iq4u_last_color'); }catch(e){}
            }catch(e){}
          }
        });
      }

      function emitMoveForGame(gameId, payload){ if(!gameId || !payload) return; const node = db.ref('moves/'+gameId).push(); node.set({ payload: payload, by: myId, ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{}); }

      document.getElementById('joinBtnBottom').addEventListener('click', function(){
        const email = (document.getElementById('emailInputBottom').value||'').trim();
        if(!email) return alert('Enter username to join online');
        goOnline(email);
      });

      window.firebaseMultiplayer = {
        emitMove: function(arg){ if(!currentGameId) return console.warn('Not in game'); emitMoveForGame(currentGameId, arg); },
        emitFen: function(arg){ try{ const movesRef = db.ref('moves/' + myId); const node = movesRef.push(); node.set({ payload: arg, by: myId, ts: firebase.database.ServerValue.TIMESTAMP }); }catch(e){} },
        startWatchingGame: function(gameId){ currentGameId = gameId; watchMoves(gameId); },
        getMyId: () => myId,
        getMyEmail: () => myEmail,
        goOffline: goOffline,
        autoJoin: function(name){ if(!name) return; try{ document.getElementById('emailInputBottom').value = name; goOnline(name); }catch(e){ goOnline(name); } },
        getMyColor: () => null
      };

      document.getElementById('challengeBtnBottom').addEventListener('click', function(){
        const target = document.getElementById('onlinePlayersBottom').value;
        if(!target) return alert('Select a player');
        sendChallengeTo(target);
      });

      window.addEventListener('beforeunload', ()=>{ /* do not auto-remove presence on unload per request */ });
    })();

  })();
  </script>
</body>
</html>
