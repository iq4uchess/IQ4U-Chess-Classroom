<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IQ4U â€” Student Puzzle (student3)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    html,body{ overscroll-behavior-y: contain; height:100%; }
    body{ font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:16px; background:#f6f7fb; color:#111; -webkit-font-smoothing:antialiased; display:flex; flex-direction:column; align-items:center; }
    button{ padding:8px 12px; border:none; background:#0f172a; color:#fff; border-radius:8px; cursor:pointer; }
    .panel{ background:#fff; padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(2,6,23,.04); margin:0 auto; max-width:980px; width:100%; box-sizing:border-box; }
    .small{ font-size:13px; color:#555; }
    .muted{ color:#666; font-size:13px; }
    .info{ margin-top:8px; font-size:13px; color:#444; text-align:center; }
    .controls{ display:flex; gap:8px; justify-content:center; align-items:center; width:100%; }
    #board-wrapper{ width:100%; max-width:760px; display:flex; align-items:center; justify-content:center; transition: max-width 180ms ease; margin:0 auto; position:relative; padding:16px; }
    #board-wrapper, #board { touch-action: none; -webkit-user-select: none; -webkit-touch-callout: none; user-select: none; -ms-touch-action: none; }
    #board{ width:100%; aspect-ratio: 1 / 1; border:1px solid #e6eefc; box-sizing:border-box; background:#fff; max-height:88vh; min-width:520px; min-height:520px; box-shadow: 0 6px 18px rgba(2,6,23,0.04); border-radius:8px; padding:6px; }
    .resizer{ display:flex; gap:10px; align-items:center; background:transparent; justify-content:center; width:100%; }
    .resizer .range{ width:320px; }
    .resizer small{ color:#444; display:block; min-width:48px; text-align:center; font-size:13px; }
    textarea{ width:100%; max-width:720px; min-height:80px; padding:8px; border-radius:6px; border:1px solid #e6eefc; font-family:monospace; display:block; margin:0 auto; box-sizing:border-box; }
    .notation { margin-top:12px; padding:8px; border-radius:6px; border:1px solid #eef2ff; background:#fbfdff; min-height:44px; max-height:180px; overflow:auto; font-family:monospace; font-size:13px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .notation .move { white-space:normal; display:inline-block; padding:4px 8px; border-radius:6px; background:transparent; }
    .notation .move.current { background:#0f172a; color:#fff; }
    .tactic-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .solution-controls { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .solution-controls .small { margin-left:6px; margin-right:2px; }
    @media (max-width:900px){
      #board{ height:80vw; width:100%; aspect-ratio: auto; max-height:620px; min-width:300px; min-height:300px; }
      .resizer .range{ width:200px; }
    }
    .status-bubble { padding:8px 10px; border-radius:8px; background:#f3f6ff; border:1px solid #e6eeff; color:#0b2; font-weight:600; }
    .promote-modal { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; border-radius:10px; padding:12px; box-shadow:0 10px 30px rgba(2,6,23,0.2); z-index:9999; display:none; }
    .logout-btn { background:#dc2626; }
    .stats { margin-top:10px; display:flex; gap:16px; align-items:center; justify-content:flex-end; font-weight:600; color:#111; }
    .cb-last-move { outline: 3px solid rgba(255,200,0,0.95); outline-offset: -3px; box-shadow: inset 0 0 0 2px rgba(255,200,0,0.25); }
    .puzzle-meta { margin-left:8px; font-weight:600; color:#222; }
    .engine-controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 14px; }
    h1 { color: #0f172a; margin-bottom: 10px; text-align: center; }
    #engineOnBtn { background: #10b981; }
    #engineOffBtn { background: #ef4444; display: none; }
    .engine-status { padding: 4px 8px; border-radius: 4px; background: #f3f4f6; font-size: 12px; color: #666; }
    #engineThinking { display: none; color: #059669; font-weight: 600; }
  </style>
</head>

<body>

<h1>Student3 - Play vs Stockfish Engine</h1>

<div class="panel">
  <div class="controls">
    <button id="undoBtn">Undo</button>
    <button id="flipBtn">Flip</button>
    <button id="resetBtn" style="background:#8b0f0f;">Reset Game</button>
    <button id="logoutBtn" class="logout-btn" style="margin-left:auto;">Logout</button>
  </div>

  <div class="resizer">
    <input id="boardSizeRange" name="board-size" class="range" type="range" min="360" max="1400" step="10" value="760" aria-label="Board size">
    <small id="boardSizeLabel">760px</small>
  </div>

  <div id="board-wrapper" style="margin-top:12px;">
    <div id="board" aria-label="Chessboard container"></div>
  </div>

  <div id="status" class="info">White to move</div>
  
  <div id="movesList" class="notation" aria-live="polite" role="status">No moves yet.</div>
</div>

<!-- Engine Controls Panel -->
<div class="panel" style="margin-top:18px;">
  <div class="engine-controls">
    <div>
      <label class="small">Engine Side:</label>
      <select id="engineColor">
        <option value="white">Engine as White</option>
        <option value="black" selected>Engine as Black</option>
        <option value="both">Engine vs Engine</option>
        <option value="none">Human vs Human</option>
      </select>
    </div>
    
    <div>
      <label class="small">Skill Level:</label>
      <select id="engineLevel">
        <option value="0">0 (Easiest)</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20 (Hardest)</option>
      </select>
    </div>
    
    <div>
      <span id="engineThinking" style="display:none;">ðŸ¤” Thinking...</span>
      <span id="engineDepth" class="engine-status">Depth: -</span>
    </div>
    
    <button id="engineOnBtn">Start Stockfish</button>
    <button id="engineOffBtn" style="display:none;">Stop Stockfish</button>
  </div>
</div>

<!-- Online Presence Panel (same as student2.html) -->
<div class="panel multiplayer-panel" style="margin-top:18px;" id="multiplayerPanel">
  <div style="display:flex; gap:8px; align-items:center;">
    <label for="emailInputBottom" class="small">Your username:</label>
    <input id="emailInputBottom" name="username" type="text" placeholder="your username (e.g. student3)" />
    <button id="joinBtnBottom">Join Online</button>
  </div>

  <div style="margin-left:auto; display:flex; gap:8px; align-items:center; margin-top:10px;">
    <div id="multiplayStatus" class="muted">Not connected</div>
    <div id="pairedBubble" class="status-bubble" style="display:none;">Paired</div>
  </div>
</div>

<!-- Promotion Modal -->
<div class="promote-modal" id="promoteModal" role="dialog" aria-modal="true">
  <div style="font-weight:700; text-align:center; margin-bottom:8px;">Choose promotion</div>
  <div class="row">
    <button data-piece="q">Q</button>
    <button data-piece="r">R</button>
    <button data-piece="b">B</button>
    <button data-piece="n">N</button>
  </div>
</div>

<!-- Same libraries as student2.html -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

<script>
// GLOBAL GAME INSTANCE - REQUIRED FOR MASTER SPECTATING
window.game = null;

(function(){
  // Config - CORRECTED PIECE PATHS
  const PIECES_BASE = 'https://iq4uchess.github.io/IQ4U-Chess-Classroom/assets/pieces/cburnett/';
  
  // DOM
  const boardEl = document.getElementById('board');
  const boardWrapper = document.getElementById('board-wrapper');
  const boardSizeRange = document.getElementById('boardSizeRange');
  const boardSizeLabel = document.getElementById('boardSizeLabel');
  const statusEl = document.getElementById('status');
  const movesList = document.getElementById('movesList');
  const engineLevelSelect = document.getElementById('engineLevel');
  const engineColorSelect = document.getElementById('engineColor');
  const engineOnBtn = document.getElementById('engineOnBtn');
  const engineOffBtn = document.getElementById('engineOffBtn');
  const engineThinking = document.getElementById('engineThinking');
  const engineDepth = document.getElementById('engineDepth');
  const undoBtn = document.getElementById('undoBtn');
  const flipBtn = document.getElementById('flipBtn');
  const resetBtn = document.getElementById('resetBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const emailInputBottom = document.getElementById('emailInputBottom');
  const joinBtnBottom = document.getElementById('joinBtnBottom');
  const multiplayStatus = document.getElementById('multiplayStatus');
  const pairedBubble = document.getElementById('pairedBubble');

  // State
  let board = null;
  let game = new Chess(); // Local game instance
  window.game = game; // EXPOSED GLOBALLY FOR SPECTATING
  let engine = null;
  let engineEnabled = false;
  let engineColor = 'black';
  let engineLevel = 5;
  let isThinking = false;
  let lastMoveSquares = [];
  let pendingPromo = null;

  // Promotion Modal
  const promoteModal = document.getElementById('promoteModal');
  function showPromotionDialog(){ promoteModal.style.display='block'; }
  function hidePromotionDialog(){ promoteModal.style.display='none'; }
  promoteModal.addEventListener('click', function(e){
    if(e.target && e.target.dataset && e.target.dataset.piece){
      const p = e.target.dataset.piece;
      if(pendingPromo && pendingPromo.resolve) pendingPromo.resolve(p);
      pendingPromo = null;
      hidePromotionDialog();
    }
  });

  // FEN Emitter (for master spectating)
  window.emitFenToMaster = function() {
    if (!window.game || !window.firebaseMultiplayer) return;
    try {
      const fen = window.game.fen();
      if (window.firebaseMultiplayer.emitFen) {
        window.firebaseMultiplayer.emitFen({ fen: fen });
      }
    } catch(e) {
      console.warn('FEN emit failed:', e);
    }
  };

  // Helpers
  function pieceTheme(piece){ 
    // Convert piece notation to correct filename
    // chessboard-js uses format like 'wK', 'bQ', etc.
    // Our files are named like wK.svg, bQ.svg
    return PIECES_BASE + piece + '.svg'; 
  }
  
  function createBoard(){
    if(board && typeof board.destroy==='function'){ 
      try{ board.destroy(); }catch(e){} 
    }
    board = Chessboard('board', {
      draggable: true,
      position: game.fen(),
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: pieceTheme,
      orientation: 'white'
    });
    updateStatus();
    refreshNotation();
  }
  
  function onSnapEnd(){ 
    if(board) board.position(game.fen());
  }

  // Update game status
  function updateStatus() {
    let status = '';
    
    if (game.in_checkmate()) {
      status = 'Game over, ' + (game.turn() === 'w' ? 'black' : 'white') + ' wins by checkmate!';
    } else if (game.in_draw()) {
      status = 'Game over, drawn position';
    } else if (game.in_stalemate()) {
      status = 'Game over, stalemate';
    } else if (game.in_threefold_repetition()) {
      status = 'Game over, threefold repetition';
    } else if (game.insufficient_material()) {
      status = 'Game over, insufficient material';
    } else {
      status = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
      if (game.in_check()) {
        status += ', ' + (game.turn() === 'w' ? 'white' : 'black') + ' is in check';
      }
    }
    
    statusEl.innerHTML = status;
  }

  // Refresh move notation
  function refreshNotation() {
    try {
      const hist = game.history();
      if (!hist || hist.length === 0) {
        movesList.innerHTML = 'No moves yet.';
        return;
      }
      
      movesList.innerHTML = '';
      for (let i = 0; i < hist.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        const whiteMove = hist[i] || '';
        const blackMove = hist[i + 1] || '';
        
        const div = document.createElement('div');
        div.className = 'move';
        div.innerHTML = `<strong>${moveNum}.</strong>&nbsp;${whiteMove}`;
        if (blackMove) {
          div.innerHTML += `&nbsp;${blackMove}`;
        }
        movesList.appendChild(div);
      }
      
      // Scroll to latest move
      movesList.scrollTop = movesList.scrollHeight;
    } catch (e) {
      console.warn('Notation refresh error:', e);
    }
  }

  /* ---- LAST MOVE HIGHLIGHT ---- */
  function setPersistentLastMove(src, tgt){
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    ['square-'+src,'square-'+tgt].forEach(cls=>{
      const el = document.querySelector('.'+cls);
      if(el) el.classList.add('cb-last-move');
      lastMoveSquares.push(cls.replace('square-',''));
    });
  }

  // Drag start handler
  function onDragStart(source, piece, position, orientation) {
    // Don't allow dragging if game is over
    if (game.game_over()) {
      return false;
    }
    
    // Don't allow dragging if engine is thinking
    if (isThinking) {
      return false;
    }
    
    // Don't allow dragging if it's engine's turn
    if (engineEnabled && !isHumanTurn()) {
      return false;
    }
    
    // Only allow dragging own pieces
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false;
    }
    
    return true;
  }

  // Check if it's human's turn
  function isHumanTurn() {
    if (!engineEnabled) return true;
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    
    if (engineColor === 'both') return false;
    if (engineColor === 'none') return true;
    if (engineColor === 'white' && currentPlayer === 'white') return false;
    if (engineColor === 'black' && currentPlayer === 'black') return false;
    
    return true;
  }

  // Drop handler
  async function onDrop(source, target) {
    // Try the move
    const moveObj = { from: source, to: target };
    
    // Check for pawn promotion
    const legal = game.moves({verbose:true}) || [];
    const candidatePromo = legal.find(m => m.from === source && m.to === target && m.promotion);
    let chosenPromo = null;
    
    if (candidatePromo) {
      chosenPromo = await new Promise(resolve => { 
        pendingPromo = { from:source, to:target, resolve }; 
        showPromotionDialog(); 
      });
      pendingPromo = null;
      if (!chosenPromo) chosenPromo = 'q';
      moveObj.promotion = chosenPromo;
    }

    const mv = game.move(moveObj);
    if (mv === null) {
      return 'snapback';
    }

    // Update board and status
    board.position(game.fen());
    setPersistentLastMove(mv.from, mv.to);
    updateStatus();
    refreshNotation();
    
    // Update master board
    window.emitFenToMaster();
    
    // If engine is enabled and it's engine's turn, ask engine to move
    if (engineEnabled && engine && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 100);
    }
    
    return 'snap';
  }

  // Stockfish Engine Functions - Using your local Stockfish
  function createStockfishEngine() {
    // Create Stockfish Worker from your local file
    const stockfish = new Worker('https://iq4uchess.github.io/IQ4U-Chess-Classroom/js/stockfish/stockfish-17.1-8e4d048.js');
    
    let onMessageCallback = null;
    
    stockfish.onmessage = function(e) {
      const line = e.data;
      
      if (line.startsWith('bestmove')) {
        if (onMessageCallback) {
          onMessageCallback(line);
        }
      } else if (line.includes('depth')) {
        // Extract depth information
        const depthMatch = line.match(/depth (\d+)/);
        if (depthMatch) {
          engineDepth.textContent = `Depth: ${depthMatch[1]}`;
        }
      }
    };
    
    return {
      postMessage: function(cmd) {
        stockfish.postMessage(cmd);
      },
      
      setOnMessage: function(callback) {
        onMessageCallback = callback;
      },
      
      terminate: function() {
        stockfish.terminate();
      }
    };
  }

  // Initialize Stockfish engine - FIXED VERSION
  function initStockfish(engineObj) {
    // First send UCI command
    engineObj.postMessage('uci');
    
    // Set single-threaded mode BEFORE isready to avoid SharedArrayBuffer error
    engineObj.postMessage('setoption name Threads value 1');
    
    // Set skill level (0-20, where 20 is strongest)
    engineObj.postMessage(`setoption name Skill Level value ${engineLevel}`);
    
    // Reduce strength for lower levels
    if (engineLevel < 10) {
      engineObj.postMessage('setoption name Skill Level Maximum Error value 100');
      engineObj.postMessage('setoption name Skill Level Probability value 50');
    }
    
    // Now send isready
    engineObj.postMessage('isready');
  }

  // Process engine's best move
  function processBestMove(line) {
    if (!line.startsWith('bestmove')) return;
    
    const parts = line.split(' ');
    if (parts.length < 2) return;
    
    const moveStr = parts[1];
    if (moveStr === '(none)' || moveStr === 'none' || moveStr === 'null') return;
    
    // Convert UCI to chess.js format
    const from = moveStr.substring(0, 2);
    const to = moveStr.substring(2, 4);
    const promotion = moveStr.length > 4 ? moveStr.substring(4, 5) : null;
    
    // Make the move
    let move = null;
    if (promotion) {
      move = game.move({
        from: from,
        to: to,
        promotion: promotion.toLowerCase()
      });
    } else {
      move = game.move({
        from: from,
        to: to
      });
    }
    
    if (move) {
      // Update board
      board.position(game.fen());
      setPersistentLastMove(move.from, move.to);
      updateStatus();
      refreshNotation();
      isThinking = false;
      engineThinking.style.display = 'none';
      
      // Update master board
      window.emitFenToMaster();
      
      // If engine vs engine and game not over, trigger next move
      if (engineColor === 'both' && !game.game_over()) {
        setTimeout(askEngineToMove, 1000);
      }
    } else {
      console.log('Stockfish made illegal move: ' + moveStr);
      isThinking = false;
      engineThinking.style.display = 'none';
      
      // Try to make a different move
      setTimeout(() => {
        if (engineEnabled && !game.game_over() && !isHumanTurn()) {
          askEngineToMove();
        }
      }, 500);
    }
  }

  // Ask engine to make a move
  function askEngineToMove() {
    if (!engine || game.game_over() || isThinking) return;
    
    const currentPlayer = game.turn() === 'w' ? 'white' : 'black';
    if (engineColor === 'both' || 
        (engineColor === 'white' && currentPlayer === 'white') ||
        (engineColor === 'black' && currentPlayer === 'black')) {
      
      isThinking = true;
      engineThinking.style.display = 'inline';
      engineDepth.textContent = 'Depth: -';
      
      // Send position to engine
      engine.postMessage('position fen ' + game.fen());
      
      // Calculate thinking time based on level
      const thinkTime = Math.min(5000, 500 + (engineLevel * 200));
      const depth = Math.min(18, 8 + Math.floor(engineLevel/2));
      
      // Ask for move with time constraints
      engine.postMessage(`go depth ${depth} movetime ${thinkTime}`);
    }
  }

  // Start engine
  function startEngine() {
    if (engine && engine.terminate) {
      try { engine.terminate(); } catch(e) {}
      engine = null;
    }
    
    try {
      // Create Stockfish engine with your local version
      engine = createStockfishEngine();
      
      // Set up message handler
      engine.setOnMessage(function(line) {
        processBestMove(line);
      });
      
      // Initialize engine - with error handling
      initStockfish(engine);
      
      engineEnabled = true;
      engineOnBtn.style.display = 'none';
      engineOffBtn.style.display = 'inline-block';
      
      // Update multiplayer status
      if (multiplayStatus) {
        multiplayStatus.textContent = 'Playing vs Stockfish 17.1';
      }
      
      // If engine should move first
      if (!game.game_over() && !isHumanTurn()) {
        setTimeout(askEngineToMove, 1000);
      }
    } catch (error) {
      console.error('Failed to start Stockfish:', error);
      alert('Could not start Stockfish engine. The page may need to be served with proper security headers.');
      engineEnabled = false;
      engineOnBtn.style.display = 'inline-block';
      engineOffBtn.style.display = 'none';
    }
  }

  // Stop engine
  function stopEngine() {
    engineEnabled = false;
    isThinking = false;
    engineThinking.style.display = 'none';
    engineDepth.textContent = 'Depth: -';
    
    if (engine && engine.terminate) {
      try { 
        engine.terminate(); 
      } catch(e) {}
      engine = null;
    }
    
    engineOnBtn.style.display = 'inline-block';
    engineOffBtn.style.display = 'none';
    
    // Update multiplayer status
    if (multiplayStatus && multiplayStatus.textContent === 'Playing vs Stockfish 17.1') {
      multiplayStatus.textContent = 'Stockfish stopped';
    }
  }

  // Reset game
  function resetGame() {
    game = new Chess();
    window.game = game; // Update global reference
    board.position('start');
    updateStatus();
    refreshNotation();
    
    // Clear last move highlights
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    
    // Reset engine thinking
    isThinking = false;
    engineThinking.style.display = 'none';
    engineDepth.textContent = 'Depth: -';
    
    if (engineEnabled && !game.game_over() && !isHumanTurn()) {
      setTimeout(askEngineToMove, 500);
    }
    
    // Update master board
    window.emitFenToMaster();
  }

  // Undo move
  function undoMove() {
    if (!game || game.history().length === 0) {
      return;
    }
    
    // Undo last move
    game.undo();
    
    // If engine vs human and we just undid engine's move, also undo human's move
    if (engineEnabled && engineColor !== 'both' && game.history().length > 0) {
      game.undo();
    }
    
    board.position(game.fen());
    updateStatus();
    refreshNotation();
    
    // Clear last move highlights
    lastMoveSquares.forEach(sq=>{
      const el = document.querySelector('.square-'+sq);
      if(el) el.classList.remove('cb-last-move');
    });
    lastMoveSquares = [];
    
    // Reset engine thinking
    isThinking = false;
    engineThinking.style.display = 'none';
    engineDepth.textContent = 'Depth: -';
    
    // Update master board
    window.emitFenToMaster();
  }

  // Board size controls
  function setBoardSize(px){ 
    if(!px || isNaN(px)) return; 
    const clamped = Math.max(360, Math.min(1400, Number(px))); 
    boardWrapper.style.maxWidth = clamped + 'px'; 
    boardSizeRange.value = clamped; 
    boardSizeLabel.textContent = clamped + 'px'; 
    try{ 
      if(board && typeof board.resize === 'function'){ 
        board.resize(); 
      } 
    }catch(e){} 
  }

  // Event listeners
  $(document).ready(function() {
    // Initialize board
    createBoard();
    
    // Set initial board size
    const initial = parseInt(getComputedStyle(boardWrapper).maxWidth,10) || boardWrapper.clientWidth || 760;
    setBoardSize(initial);
    
    // Engine controls
    engineOnBtn.addEventListener('click', startEngine);
    engineOffBtn.addEventListener('click', stopEngine);

    // Game controls
    resetBtn.addEventListener('click', resetGame);
    undoBtn.addEventListener('click', undoMove);
    flipBtn.addEventListener('click', () => { 
      if(board) board.flip(); 
    });
    
    logoutBtn.onclick = () => { 
      localStorage.clear(); 
      if (window.firebaseMultiplayer && window.firebaseMultiplayer.goOffline) {
        window.firebaseMultiplayer.goOffline();
      }
      location.href = 'index.html'; 
    };
    
    // Engine settings
    engineColorSelect.addEventListener('change', () => {
      engineColor = engineColorSelect.value;
      
      if (engineEnabled && !game.game_over() && !isHumanTurn()) {
        setTimeout(askEngineToMove, 300);
      }
    });

    engineLevelSelect.addEventListener('change', () => {
      engineLevel = Number(engineLevelSelect.value);
      
      // Update Stockfish skill level if engine is running
      if (engineEnabled && engine) {
        engine.postMessage(`setoption name Skill Level value ${engineLevel}`);
        
        if (engineLevel < 10) {
          engine.postMessage('setoption name Skill Level Maximum Error value 100');
          engine.postMessage('setoption name Skill Level Probability value 50');
        }
      }
    });

    // Board size range
    boardSizeRange.addEventListener('input', (e) => setBoardSize(e.target.value));
    
    // Handle moves from master (same as student2.html)
    window.onBoardMove = function(payload){
      try{
        if(!payload) return;
        if(typeof payload === 'string'){
          if(game.load) game.load(payload);
          if(board) board.position(game.fen());
          updateStatus();
          refreshNotation();
          return;
        }
        if(payload.move && payload.move.from && payload.move.to){
          const mvObj = { from: payload.move.from, to: payload.move.to };
          if(payload.move.promotion) mvObj.promotion = payload.move.promotion;
          const applied = game.move(mvObj);
          if(applied === null){
            if(payload.fen && game.load){
              game.load(payload.fen);
            }
          } else {
            setPersistentLastMove(payload.move.from, payload.move.to);
          }
        } else if(payload.fen){
          if(game.load) game.load(payload.fen);
        }
        if(board) board.position(game.fen());
        updateStatus();
        refreshNotation();
      }catch(e){ console.warn('onBoardMove failed', e); }
    };
    
    // Auto-join if username exists
    try{ 
      const uname = localStorage.getItem('username') || localStorage.getItem('email') || ''; 
      if(uname && emailInputBottom) emailInputBottom.value = uname; 
    }catch(e){}
  });

})();
</script>

<!-- FIREBASE - IDENTICAL TO student2.html -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<script>
(function(){
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyAIefVM1tBjWz35FRWRxmIdEJeO_vpHSKM",
    authDomain: "iq4u-chess-classroom.firebaseapp.com",
    databaseURL: "https://iq4u-chess-classroom-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "iq4u-chess-classroom",
    storageBucket: "iq4uchess-classroom.firebasestorage.app",
    messagingSenderId: "833620718306",
    appId: "1:833620718306:web:b599bb6936fe0da4bb"
  };
  try{ firebase.initializeApp(FIREBASE_CONFIG); }catch(e){}

  (function(){
    const db = firebase.database();
    const onlineRef = db.ref('online');

    let myId = sessionStorage.getItem('iq4u_clientId') ||
      ('c_'+Math.random().toString(36).slice(2,10));
    sessionStorage.setItem('iq4u_clientId', myId);

    let myEmail = '';
    let currentGameId = null;
    let presenceTimer = null;
    let isSpectated = false;

    function goOnline(email){
      myEmail = email || ('anon-'+myId);
      const node = onlineRef.child(myId);
      node.set({ email: myEmail, role: 'student', ts: firebase.database.ServerValue.TIMESTAMP });
      if(presenceTimer) clearInterval(presenceTimer);
      presenceTimer = setInterval(
        ()=>node.update({ ts: firebase.database.ServerValue.TIMESTAMP }),
        25000
      );
      if (multiplayStatus) {
        multiplayStatus.textContent = 'Connected as ' + myEmail;
      }
    }

    function goOffline(){
      if(presenceTimer) clearInterval(presenceTimer);
      onlineRef.child(myId).remove().catch(()=>{});
      if (multiplayStatus) {
        multiplayStatus.textContent = 'Not connected';
      }
      isSpectated = false;
      if (pairedBubble) pairedBubble.style.display = 'none';
    }

    joinBtnBottom.addEventListener('click', ()=>{
      const email = (emailInputBottom.value||'').trim();
      if(!email) return alert('Enter username');
      localStorage.setItem('username', email);
      goOnline(email);
    });

    /* =========================================================
       SPECTATE INVITE HANDLER (IDENTICAL TO student2.html)
       ========================================================= */
    db.ref('spectateInvites/'+myId).on('child_added', snap=>{
      const invite = snap.val();
      if(!invite) return;

      const fromEmail = invite.fromEmail || invite.fromId || 'Master';
      const accept = confirm(fromEmail + ' wants to spectate your board. Accept?');

      // Get current FEN
      const currentFen = window.game ? window.game.fen() : 
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

      // Send response
      if(invite.fromId){
        const respPath = `spectateResponses/${invite.fromId}/${myId}`;
        
        db.ref(respPath).set({
          studentId: myId,
          studentEmail: myEmail || null,
          accepted: accept,
          boardId: invite.boardId || null,
          fen: accept ? currentFen : null,
          ts: firebase.database.ServerValue.TIMESTAMP
        }).catch(err=>{
          console.warn('[STUDENT3] spectate response failed', err);
        });
      }

      // If accepted, set flag
      if (accept) {
        isSpectated = true;
        if (multiplayStatus) {
          multiplayStatus.textContent = 'Master is spectating';
        }
      }

      snap.ref.remove().catch(()=>{});
    });

    /* =========================================================
       FIREBASE MULTIPLAYER OBJECT (IDENTICAL TO student2.html)
       ========================================================= */
    window.firebaseMultiplayer = {
      emitMove: function(arg){
        if(!currentGameId) return;
        db.ref('moves/'+currentGameId).push({
          payload: arg,
          by: myId,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      },
      emitFen: function(arg){
        // Write to moves/<myId> path
        db.ref('moves/'+myId).push({
          payload: arg,
          by: myId,
          ts: firebase.database.ServerValue.TIMESTAMP
        });
      },
      getMyId: ()=>myId,
      getMyEmail: ()=>myEmail,
      goOffline: goOffline
    };

    // Auto-join if username exists
    setTimeout(() => {
      const saved = (emailInputBottom && emailInputBottom.value) ? emailInputBottom.value.trim() : 
                   (localStorage.getItem('username') || localStorage.getItem('email') || '');
      if(saved){
        goOnline(saved);
      }
    }, 500);

  })();
})();
</script>

</body>
</html>
